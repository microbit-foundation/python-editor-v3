{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]\n    ) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "",
    "/typeshed/stdlib/array.pyi": "from typing import Generic, Iterable, MutableSequence, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode]\n\n_T = TypeVar(\"_T\", int, float)\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(\n        self: array[int],\n        typecode: _IntTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[float],\n        typecode: _FloatTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...\n    ) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n\nArrayType = array\n",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __slots__: str | Iterable[str]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls: Type[_T]) -> _T: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> str | Tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __name__: str\n    __qualname__: str\n    __text_signature__: str | None\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], dict: dict[str, Any], **kwds: Any\n    ) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: Type[_TT],\n        name: str,\n        bases: Tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwds: Any,\n    ) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> list[_TT]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(\n        metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any\n    ) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.UnionType: ...\n        def __ror__(self, t: Any) -> types.UnionType: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(\n        cls: Type[_T],\n        x: str | bytes | SupportsInt | SupportsIndex | _SupportsTrunc = ...,\n    ) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], x: str | bytes | bytearray, base: SupportsIndex\n    ) -> _T: ...\n    def to_bytes(\n        self,\n        length: SupportsIndex,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls,\n        bytes: Iterable[SupportsIndex] | SupportsBytes,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n    @overload\n    def __pow__(\n        self, __x: int, __modulo: int | None = ...\n    ) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(\n        cls: Type[_T], x: SupportsFloat | SupportsIndex | str | bytes | bytearray = ...\n    ) -> _T: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], real: str | SupportsComplex | SupportsIndex | complex\n    ) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...\n    ) -> _T: ...\n    def count(\n        self,\n        x: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self,\n        __suffix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def index(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: str | None = ...) -> str: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    def rfind(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def rstrip(self, __chars: str | None = ...) -> str: ...\n    def split(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def startswith(\n        self,\n        __prefix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __chars: str | None = ...) -> str: ...\n    def upper(self) -> str: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: int | slice) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ByteString | memoryview]) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytes: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray:\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[_T_co | _T, ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(\n        self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n\n# Can we remove this?\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: dict[str, Any]\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls: type[Self]) -> Self: ...\n    @overload\n    def __new__(cls: type[Self], __iterable: Iterable[_T_co]) -> Self: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(\n        self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(\n        self: list[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n    ) -> None: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, x: list[_T]) -> list[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: list[_T]) -> bool: ...\n    def __ge__(self, x: list[_T]) -> bool: ...\n    def __lt__(self, x: list[_T]) -> bool: ...\n    def __le__(self, x: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(\n        self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(\n        cls, __iterable: Iterable[_T], __value: None = ...\n    ) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(\n        self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> _T | _VT: ...\n\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exec(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(\n        self, __function: Callable[[_T], Any], __iterable: Iterable[_T]\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\n@overload\ndef getattr(__o: object, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: object, name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n    def issubclass(\n        __cls: type,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n\nelse:\n    def isinstance(\n        __obj: object, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef max(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef max(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef min(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef min(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIO: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes) -> int: ...\ndef print(\n    *values: object,\n    sep: str | None = ...,\n    end: str | None = ...,\n    file: SupportsWrite[str] | None = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(\n        base: int, exp: int, mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n) -> list[SupportsLessThanT]: ...\n@overload\ndef sorted(\n    __iterable: Iterable[_T],\n    *,\n    key: Callable[[_T], SupportsLessThan],\n    reverse: bool = ...,\n) -> list[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> _T | _S: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> _T | _S: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]\n    ) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Mapping[str, Any] | None = ...,\n    locals: Mapping[str, Any] | None = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(\n        self, *args: object, name: str | None = ..., path: str | None = ...\n    ) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass NotImplementedError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\n",
    "/typeshed/stdlib/errno.pyi": "from typing import Mapping\n\nerrorcode: Mapping[int, str]\n\nEACCES: int\nEADDRINUSE: int\nEAGAIN: int\nEALREADY: int\nEBADF: int\nECONNABORTED: int\nECONNREFUSED: int\nECONNRESET: int\nEEXIST: int\nEHOSTUNREACH: int\nEINPROGRESS: int\nEINVAL: int\nEIO: int\nEISDIR: int\nENOBUFS: int\nENODEV: int\nENOENT: int\nENOMEM: int\nENOTCONN: int\nEOPNOTSUPP: int\nEPERM: int\nETIMEDOUT: int\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Controla el recol\u00b7lector de mem\u00f2ria brossa\"\"\"\nfrom typing import overload\n\ndef enable() -> None:\n    \"\"\"Habilita la recol\u00b7lecci\u00f3 autom\u00e0tica de la mem\u00f2ria brossa (habilita)\"\"\"\n    ...\n\ndef disable() -> None:\n    \"\"\"Inhabilita la recol\u00b7lecci\u00f3 autom\u00e0tica de la mem\u00f2ria brossa (desactiva)\n\nHeap memory can still be allocated,\nand garbage collection can still be initiated manually using ``gc.collect``.\"\"\"\n\ndef collect() -> None:\n    \"\"\"Executa la recol\u00b7lecci\u00f3 autom\u00e0tica de la mem\u00f2ria brossa (Recull)\"\"\"\n    ...\n\ndef mem_alloc() -> int:\n    \"\"\"Obt\u00e9 el nombre de bytes assignats a la mem\u00f2ria din\u00e0mica. (espai de mem\u00f2ria)\n\n:return: The number of bytes allocated.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\ndef mem_free() -> int:\n    \"\"\"Obt\u00e9 el nombre disponible de bytes de la mem\u00f2ria din\u00e0mica, o -1 si no es coneix la quantitat. (mem\u00f2ria lliure)\n\n:return: The number of bytes free.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\n@overload\ndef threshold() -> int:\n    \"\"\"Consulta l'assignaci\u00f3 del llindar del col\u00b7lector d'escombraries. (llindar)\n\n:return: The GC allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\"\"\"\n    ...\n\n@overload\ndef threshold(amount: int) -> None:\n    \"\"\"Assigna un espai adicional al llindar del col\u00b7lector d'escombraries. (llindar)\n\nNormally, a collection is triggered only when a new allocation\ncannot be satisfied, i.e. on an  out-of-memory (OOM) condition.\nIf this function is called, in addition to OOM, a collection\nwill be triggered each time after ``amount`` bytes have been\nallocated (in total, since the previous time such an amount of bytes\nhave been allocated). ``amount`` is usually specified as less than the\nfull heap size, with the intention to trigger a collection earlier than when the\nheap becomes exhausted, and in the hope that an early collection will prevent\nexcessive memory fragmentation. This is a heuristic measure, the effect\nof which will vary from application to application, as well as\nthe optimal value of the ``amount`` parameter.\n\nA value of -1 means a disabled allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\n\n:param amount: (quantitat) El nombre de bytes despr\u00e9s del qual s'activar\u00e0 la recol\u00b7lecci\u00f3 de la mem\u00f2ria brossa.\"\"\"\n    ...",
    "/typeshed/stdlib/log.pyi": "\"\"\"Registre dades en la micro:bit V2 (registre)\"\"\"\nfrom typing import Literal, Mapping, Optional, Union, overload\nMILLISECONDS = 1\n\"\"\"Format de marca de temps de mil\u00b7lisegons. (mil\u00b7lisegons)\"\"\"\nSECONDS = 10\n\"\"\"Format de marca de temps de segons. (segons)\"\"\"\nMINUTES = 600\n\"\"\"Format de marca de temps de minuts. (minuts)\"\"\"\nHOURS = 36000\n\"\"\"Format de marca de temps d'hores. (hores)\"\"\"\nDAYS = 864000\n\"\"\"Format de marca de temps de dies. (dies)\"\"\"\n\ndef set_labels(*labels: str, timestamp: Optional[Literal[1, 10, 36000, 864000]]=SECONDS) -> None:\n    \"\"\"Defineix la cap\u00e7alera del fitxer de registre. (Defineix l'etiqueta)\n\nExample: ``log.set_labels('X', 'Y', 'Z', timestamp=log.MINUTES)``\n\nIdeally this function should be called a single time, before any data is\nlogged, to configure the data table header once.\n\nIf a log file already exists when the program starts, or if this function\nis called multiple times, it will check the labels already defined in the\nlog file. If this function call contains any new labels not already\npresent, it will generate a new header row with the additional columns.\n\nBy default the first column contains a timestamp for each row. The time\nunit can be selected via the timestamp argument.\n\n:param *labels: Qualsevol nombre d'arguments posicionals, corresponent cadascun a una entrada en la cap\u00e7alera del registre.\n:param timestamp: (marca hor\u00e0ria) Selecciona la unitat de la marca del temps que ser\u00e0 automaticament afegida com a primera columna de cada fila. Els valors de la marca del temps pot ser un de  ``log.MILLISECONDS``, ``log.SECONDS``, ``log.MINUTES``, ``log.HOURS``, ``log.DAYS`` o ``None``  per desactivar la marca del temps. El valor per defecte es ``log.SECONDS``.\"\"\"\n    ...\n\n@overload\ndef add(data_dictionary: Optional[Mapping[str, Union[str, int, float]]]) -> None:\n    \"\"\"Afegeix una fila de dades al registre passant un diccionari de cap\u00e7aleres i valors. (afegeix)\n\nExample: ``log.add({ 'temp': temperature() })``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\n\n:param data_dictionary: (diccionari de dades) Les dades a ser registrades com un diccionari amb una clau per cada cap\u00e7alera.\"\"\"\n    ...\n\n@overload\ndef add(**kwargs: Union[str, int, float]) -> None:\n    \"\"\"Afegeix una fila de dades al registre fent servir arguments de paraula clau. (afegeix)\n\nExample: ``log.add(temp=temperature())``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\"\"\"\n    ...\n\ndef delete(full=False):\n    \"\"\"Suprimeix el contingut del registre, incloses les cap\u00e7aleres. (suprimeix)\n\nExample: ``log.delete()``\n\nTo add the log headers again the ``set_labels`` function should to be called after this function.\n\nThere are two erase modes; \u201cfull\u201d completely removes the data from the physical storage,\nand \u201cfast\u201d invalidates the data without removing it.\n\n:param full: (ple) ``True`` selecciona un esborrat \"total\"  ``False`` selecciona un m\u00e8tode d'esborrat \"r\u00e0pid\".\"\"\"\n    ...\n\ndef set_mirroring(serial: bool):\n    \"\"\"Configura la duplicaci\u00f3 de l'activitat de registre de dades a la sortida en s\u00e8rie. (estableix mirall)\n\nExample: ``log.set_mirroring(True)``\n\nSerial mirroring is disabled by default. When enabled, it will print to serial each row logged into the log file.\n\n:param serial: ``True`` permet la duplicaci\u00f3 de les dades a la sortida s\u00e8rie.\"\"\"\n    ...",
    "/typeshed/stdlib/love.pyi": "def badaboom() -> None: ...\n",
    "/typeshed/stdlib/machine.pyi": "\"\"\"Utilitats de baix nivell. (m\u00e0quina)\"\"\"\nfrom typing import Any\nfrom .microbit import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Obt\u00e9 una cadena de bytes amb un identificador \u00fanic d'una placa.\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Reinicia el dispositiu d'una manera semblant a la de pr\u00e9mer el bot\u00f3 extern de REINICI. (reiniciar)\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Obt\u00e9 la freq\u00fc\u00e8ncia en Hertz de la CPU\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"Desactiva les sol\u00b7licituds d'interrupci\u00f3. (desabilita irq)\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"Torna a habilitar les sol\u00b7licituds d'interrupci\u00f3. (habilita irq)\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: (estat) El valor retornat per la crida m\u00e9s recent a la funci\u00f3 ``disable_irq``.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Cronometra una pulsaci\u00f3 en un pin. (mesura la durada d'una pulsaci\u00f3 en un pin)\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: El pin a utilitzar\n:param pulse_level: (nivell de pulsaci\u00f3) 0 per cronometrar la durada de l'estat baix o 1 per cronometrar la durada de l'estat alt\n:param timeout_us: (temps d'espera a la resposta excedit en microsegons) Temps d'espera d'un microsegon\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"La classe per a les vistes de la mem\u00f2ria ``mem8``, ``mem16`` i ``mem32``.\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Accedeix a un valor de la mem\u00f2ria\n\n:param address: (adre\u00e7a) L'adre\u00e7a de la mem\u00f2ria\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"Assigna un valor a l'adre\u00e7a donada\n\n:param address: (adre\u00e7a) L'adre\u00e7a de la mem\u00f2ria\n:param value: (valor) El valor enter que cal assignar.\"\"\"\n        ...\nmem8: mem\n\"\"\"vista de la mem\u00f2ria 8-bit (byte)\"\"\"\nmem16: mem\n\"\"\"vista de la mem\u00f2ria 16-bit\"\"\"\nmem32: mem\n\"\"\"vista de la mem\u00f2ria 32-bit\"\"\"",
    "/typeshed/stdlib/math.pyi": "\"\"\"Funcions matem\u00e0tiques (matem\u00e0tiques)\"\"\"\nfrom typing import Tuple\n\ndef acos(x: float) -> float:\n    \"\"\"Calcula l'invers del cosinus (arc cosinus)\n\nExample: ``math.acos(1)``\n\n:param x: Un nombre\n:return: The inverse cosine of ``x``\"\"\"\n    ...\n\ndef asin(x: float) -> float:\n    \"\"\"Calcula l'invers del sinus (arc sinus)\n\nExample: ``math.asin(0)``\n\n:param x: Un nombre\n:return: The inverse sine of ``x``\"\"\"\n    ...\n\ndef atan(x: float) -> float:\n    \"\"\"Calcula l'invers de la tangent (arc tangent)\n\nExample: ``math.atan(0)``\n\n:param x: Un nombre\n:return: The inverse tangent of ``x``\"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float:\n    \"\"\"Calcula el valor principal de l'invers de la tangent de ``y/x``. (arc tangent 2)\n\nExample: ``math.atan2(0, -1)``\n\n:param y: Un nombre\n:param x: Un nombre\n:return: The principal value of the inverse tangent of ``y/x``\"\"\"\n    ...\n\ndef ceil(x: float) -> float:\n    \"\"\"Arrodoneix un nombre cap a l'infinit positiu. (arrodoniment per exc\u00e9s)\n\nExample: ``math.ceil(0.1)``\n\n:param x: Un nombre\n:return: ``x`` rounded towards positive infinity.\"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float:\n    \"\"\"Calcula ``x`` amb el signe de ``y``.\n\nExample: ``math.copysign(1, -1)``\n\n:param x: Un nombre\n:param y: L'origen del signe pel valor retornat.\n:return: ``x`` with the sign of ``y``\"\"\"\n    ...\n\ndef cos(x: float) -> float:\n    \"\"\"Calcula el cosinus de ``x``. (cosinus)\n\nExample: ``math.cos(0)``\n\n:param x: Un nombre\n:return: The cosine of ``x``\"\"\"\n    ...\n\ndef degrees(x: float) -> float:\n    \"\"\"Convertir radiants a graus (graus)\n\nExample: ``math.degrees(2 * math.pi)``\n\n:param x: Un valor en radians\n:return: The value converted to degrees\"\"\"\n    ...\n\ndef exp(x: float) -> float:\n    \"\"\"Calcula l'exponencial de ``x``.\n\nExample: ``math.exp(1)``\n\n:param x: Un nombre\n:return: The exponential of ``x``.\"\"\"\n    ...\n\ndef fabs(x: float) -> float:\n    \"\"\"Retorna el valor absolut de ``x``.\n\nExample: ``math.fabs(-0.1)``\n\n:param x: Un nombre\n:return: The absolute value of ``x``\"\"\"\n    ...\n\ndef floor(x: float) -> int:\n    \"\"\"Arrodoneix un nombre cap a l'infinit negatiu. (arrodoniment per defecte)\n\nExample: ``math.floor(0.9)``\n\n:param x: Un nombre\n:return: ``x`` rounded towards negative infinity.\"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float:\n    \"\"\"Calcula el residu de ``x/y``.\n\nExample: ``math.fmod(10, 3)``\n\n:param x: El numerador\n:param y: El denominador\"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]:\n    \"\"\"Descompon un nombre de coma flotant en la seva mantissa i el seu exponent.\n\nExample: ``mantissa, exponent = math.frexp(2)``\n\nThe returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\nexactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\nthe relation ``0.5 <= abs(m) < 1`` holds.\n\n:param x: Un nombre de coma flotant\n:return: A tuple of length two containing its mantissa then exponent\"\"\"\n    ...\n\ndef isfinite(x: float) -> bool:\n    \"\"\"Verifica si un valor \u00e9s finit.\n\nExample: ``math.isfinite(float('inf'))``\n\n:param x: Un nombre.\n:return: ``True`` if ``x`` is finite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isinf(x: float) -> bool:\n    \"\"\"Verifica si un valor \u00e9s infinit.\n\nExample: ``math.isinf(float('-inf'))``\n\n:param x: Un nombre.\n:return: ``True`` if ``x`` is infinite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isnan(x: float) -> bool:\n    \"\"\"Verifica si un valor \u00e9s un \"no nombre\" (NaN)\n\nExample: ``math.isnan(float('nan'))``\n\n:param x: Un nombre\n:return: ``True`` if ``x`` is not-a-number (NaN), ``False`` otherwise.\"\"\"\n    ...\n\ndef ldexp(x: float, exp: int) -> float:\n    \"\"\"Calcula ``x * (2**exp)``. (ldexp (Calcula ``x * (2**exp)``))\n\nExample: ``math.ldexp(0.5, 2)``\n\n:param x: Un nombre\n:param exp: Exponent enter\n:return: ``x * (2**exp)``\"\"\"\n    ...\n\ndef log(x: float, base: float=e) -> float:\n    \"\"\"Calcula el logaritme ``x`` d'una base donada (per defecte al logaritme natural). (registre)\n\nExample: ``math.log(math.e)``\n\nWith one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as ``log(x)/log(base)``.\n\n:param x: Un nombre\n:param base: La base a utilitzar\n:return: The natural logarithm of ``x``\"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]:\n    \"\"\"Calcula les parts fraccion\u00e0ries i integrals de ``x``.\n\nExample: ``fractional, integral = math.modf(1.5)``\n\n:param x: Un nombre\n:return: A tuple of two floats representing the fractional then integral parts of ``x``.\n\nBoth the fractional and integral values have the same sign as ``x``.\"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float:\n    \"\"\"Retorna ``x`` a la pot\u00e8ncia de ``y``.\n\nExample: ``math.pow(4, 0.5)``\n\n:param x: Un nombre\n:param y: L'exponent\n:return: ``x`` to the power of ``y``\"\"\"\n    ...\n\ndef radians(x: float) -> float:\n    \"\"\"Converteix graus a radians\n\nExample: ``math.radians(360)``\n\n:param x: Un valor en graus\n:return: The value converted to radians\"\"\"\n    ...\n\ndef sin(x: float) -> float:\n    \"\"\"Calcula el sinus de ``x``. (sinus)\n\nExample: ``math.sin(math.pi/2)``\n\n:param x: Un nombre\n:return: The sine of ``x``\"\"\"\n    ...\n\ndef sqrt(x: float) -> float:\n    \"\"\"Calcula l'arrel quadrada de ``x``.\n\nExample: ``math.sqrt(4)``\n\n:param x: Un nombre\n:return: The square root of ``x``\"\"\"\n    ...\n\ndef tan(x: float) -> float:\n    \"\"\"Calcula la tangent de ``x``.\n\nExample: ``math.tan(0)``\n\n:param x: Un nombre\n:return: The tangent of ``x``.\"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\"Arrodoneix un nombre cap al 0. (trunca)\n\nExample: ``math.trunc(-0.9)``\n\n:param x: Un nombre\n:return: ``x`` rounded towards zero.\"\"\"\n    ...\ne: float\n\"\"\"Base del logaritme natural\"\"\"\npi: float\n\"\"\"La relaci\u00f3 entre la circumfer\u00e8ncia d'un cercle i el seu di\u00e0metre\"\"\"",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"Components interns de MicroPython.\"\"\"\nfrom typing import Any, TypeVar, overload\n_T = TypeVar('_T')\n\ndef const(expr: _T) -> _T:\n    \"\"\"S'utilitza per declarar que l'expressi\u00f3 \u00e9s una constant perqu\u00e8 el compilador pugui\noptimitzar-la.\n\nThe use of this function should be as follows::\n\n    from micropython import const\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\nConstants declared this way are still accessible as global variables from\noutside the module they are declared in. On the other hand, if a constant\nbegins with an underscore then it is hidden, it is not available as a\nglobal variable, and does not take up any memory during execution.\n\n:param expr: Una expressi\u00f3 constant\"\"\"\n    ...\n\n@overload\ndef opt_level() -> int:\n    \"\"\"Obt\u00e9 el nivell d'optimitzaci\u00f3 actual per a la compilaci\u00f3 d'scripts.\n\nExample: ``micropython.opt_level()``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\n:return: An integer representing the current level.\"\"\"\n    ...\n\n@overload\ndef opt_level(level: int) -> None:\n    \"\"\"Estableix el nivell d'optimitzaci\u00f3 per a la compilaci\u00f3 posterior dels scripts.\n\nExample: ``micropython.opt_level(1)``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\nThe default optimisation level is usually level 0.\n\n:param level: Un nivell d'optimitzaci\u00f3 enter.\"\"\"\n    ...\n\ndef mem_info(verbose: Any=None) -> None:\n    \"\"\"Imprimeix informaci\u00f3 sobre la mem\u00f2ria utilitzada actualment. (informaci\u00f3 de la mem\u00f2ria)\n\nExample: ``micropython.mem_info()``\n\n:param verbose: Si es dona l'argument ``verbose``, s'imprimeix informaci\u00f3 addicional.\"\"\"\n    ...\n\ndef qstr_info(verbose: Any=None) -> None:\n    \"\"\"Imprimeix informaci\u00f3 sobre les cadenes internades actualment.\n\nExample: ``micropython.qstr_info()``\n\n:param verbose: Si es dona l'argument ``verbose``, s'imprimeix informaci\u00f3 addicional.\n\nThe information that is printed is implementation dependent, but currently\nincludes the number of interned strings and the amount of RAM they use.  In\nverbose mode it prints out the names of all RAM-interned strings.\"\"\"\n    ...\n\ndef stack_use() -> int:\n    \"\"\"Retorna un nombre enter que representa la quantitat actual de pila que est\u00e0 sent\nutilitzada.\n\nExample: ``micropython.stack_use()``\n\nThe absolute value of this is not particularly useful, rather it\nshould be used to compute differences in stack usage at different points.\n\n:return: An integer representing current stack use.\"\"\"\n    ...\n\ndef heap_lock() -> None:\n    \"\"\"Bloqueja el munt.\n\nExample: ``micropython.heap_lock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef heap_unlock() -> None:\n    \"\"\"Desbloqueja el munt.\n\nExample: ``micropython.heap_unlock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"Estableix el car\u00e0cter que generar\u00e0 una excepci\u00f3 ``KeyboardInterrupt``.\n\nExample: ``micropython.kbd_intr(-1)``\n\n:param chr: Codi de car\u00e0cter per augmentar la interrupci\u00f3 o -1 per desactivar la captura de Ctrl-C.\n\nBy default this is set to 3 during script execution, corresponding to Ctrl-C.\nPassing -1 to this function will disable capture of Ctrl-C, and passing 3\nwill restore it.\n\nThis function can be used to prevent the capturing of Ctrl-C on the\nincoming stream of characters that is usually used for the REPL, in case\nthat stream is used for other purposes.\"\"\"\n    ...",
    "/typeshed/stdlib/music.pyi": "\"\"\"Crea i toca melodies. (m\u00fasica)\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .microbit import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"Melodia: l'obertura de la cinquena simfonia de Beethoven en Do menor.\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"Melodia: el fragment inicial del cl\u00e0ssic  Ragtime de Scott Joplin \"The Entertainer\".\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"Melodia: obertura del primer Preludi en Do Major dels 48 Preludis i Fugues de J.S. Bach. (preludi)\"\"\"\nODE: Tuple[str, ...]\n\"\"\"Melodia: el tema \"Oda a l'alegria\" de la 9a simfonia en Re menor de Beethoven. (oda)\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"Melodia: el tema Nyan Cat (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"Melodia: quelcom que sona com un to de trucada de tel\u00e8fon m\u00f2bil. (to de trucada)\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"Melodia: una l\u00ednia de baix funky per a agents secrets i cervells criminals.\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"Melodia: un  blues walking bass boogie-woogie de dotze compassos.\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"Melodia:  \u201cFeli\u00e7 aniversari\u2026\u201d (aniversari)\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"Melodia: el cor nupcial de l'\u00f2pera Lohengrin de Wagner. (casament)\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"Melodia: la \u201cmarxa f\u00fanebre\u201d com es coneix  la Sonata per a piano No 2. en Si bemoll menor Op. 35 de Fr\u00e9d\u00e9ric Chopin .\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"Melodia: un fragment divertit que significa que s'ha fet una broma.\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"Melodia: la marxa de John Philip Sousa \"Liberty Bell\", tamb\u00e9 conegut com, el tema de \"Monty Python's Flying Circus\" (a partir de la qual s'anomena el llenguatge de programaci\u00f3 Python).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"Melodia: entrada d'un dolent a l'era del cinema mut. (dolent)\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"Melodia: escena de persecuci\u00f3 de l'era del cinema mut. (persecuci\u00f3)\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"Melodia: senyal breu per indicar que alguna cosa ha passat.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"Melodia: un tromb\u00f3 molt trist.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"Melodia: per utilitzar-se en un joc, indicant moviment cap amunt. (saltar cap amunt)\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"Melodia: per utilitzar en un joc, que indica moviment cap avall. (saltar cap avall)\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"Melodia: una fanf\u00e0rria per indicar un assoliment desbloquejat. (engegar)\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"Melodia: una trista fanf\u00e0rria per indicar un assoliment perdut. (apagar)\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"Estableix el tempo aproximat per la reproducci\u00f3.\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: El nombre de tics que constitueixen un ritme.\n:param bpm: Un nombre enter determinant quantes pulsacions per minut.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"Obt\u00e9 el tempo actual com una tupla d'enters:``(ticks, bpm)``. (obt\u00e9 el tempo)\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Tocar m\u00fasica\n\nExample: ``music.play(music.NYAN)``\n\n:param music: (m\u00fasica) m\u00fasica especificada en `una notaci\u00f3 especial <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: el pin de sortida per utilitzar-lo amb un altaveu extern (``pin0`` per defecte), ``None`` per no fer so.\n:param wait: (espera) Si ``wait`` s'estableix en ``True``, aquesta funci\u00f3 est\u00e0 bloquejant.\n:param loop: (bucle) Si el ``loop`` s'estableix en ``True``, la melodia es repeteix fins que es crida ``stop`` o s'interromp la trucada de bloqueig.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Toca una nota. (altura del to)\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: (freq\u00fc\u00e8ncia) Una freq\u00fc\u00e8ncia de nombre enter\n:param duration: (Durada - duraci\u00f3) Una duraci\u00f3 d'un mil\u00b7lisegon. Si \u00e9s negativa, el so \u00e9s continu fins a la nova crida o una crida a  ``stop``.\n:param pin: Pin de sortida opcional (``pin0`` per defecte).\n:param wait: (espera) Si ``wait`` s'estableix en ``True``, aquesta funci\u00f3 est\u00e0 bloquejant.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Atura tota la reproducci\u00f3 de m\u00fasica a l'altaveu integrat i qualsevol so de sortida de pin. (atura)\n\nExample: ``music.stop()``\n\n:param pin: Es pot proporcionar un argument opcional per especificar un pin, per exemple ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Restableix els tics, ppm, duraci\u00f3 i octava al seu valor per defecte. (reiniciar)\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Cintes LED RGB i RGBW adre\u00e7ables individualment.\"\"\"\nfrom .microbit import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"Inicialitza una nova tira de LED de neopixel controlada mitjan\u00e7ant un pin.\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: El pin que controla la tira de neop\u00edxels.\n:param n: El nombre de neop\u00edxels de la tira.\n:param bpp: Bytes per p\u00edxel. Per al suport del neopixel RGBW , passa 4 en lloc dels 3 per defecte per a RGB i GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Esborra tots els p\u00edxels.\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"mostra els p\u00edxels.\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Mostra els p\u00edxels (nom\u00e9s micro:bit V2) (escriu)\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Acoloreix tots els p\u00edxels amb un valor RGB/RGBW determinat (nom\u00e9s micro:bit V2). (omple)\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: (color) Una tupla de la mateixa longitud que el nombre de bytes per p\u00edxel (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"Estableix un color de p\u00edxel.\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: El nombre de p\u00edxels.\n:param value: (valor) El color.\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"Obt\u00e9 un color de p\u00edxel.\n\nExample: ``r, g, b = np[0]``\n\n:param key: El nombre de p\u00edxels.\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"Obt\u00e9 la longitud d'aquesta cinta de p\u00edxels.\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "\"\"\"Accedeix al sistema de fitxers.\"\"\"\nfrom typing import Tuple\nfrom typing import List\n\ndef listdir() -> List[str]:\n    \"\"\"Llista dels fitxers.\n\nExample: ``os.listdir()``\n\n:return: A list of the names of all the files contained within the local\npersistent on-device file system.\"\"\"\n    ...\n\ndef remove(filename: str) -> None:\n    \"\"\"Eliminar (suprimir) un fitxer. (eliminar)\n\nExample: ``os.remove('data.txt')``\n\n:param filename: (nom del fitxer) El fitxer a suprimir.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n    ...\n\ndef size(filename: str) -> int:\n    \"\"\"Retorna la mida d'un fitxer (mida)\n\nExample: ``os.size('data.txt')``\n\n:param filename: (nom del fitxer) El fitxer\n:return: The size in bytes.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n\nclass uname_result(Tuple[str, str, str, str, str]):\n    \"\"\"Resultat de ``os.uname()``\"\"\"\n    sysname: str\n    \"\"\"Nom del sistema operatiu.\"\"\"\n    nodename: str\n    \"\"\"Nom de la m\u00e0quina a la xarxa (definida per la implementaci\u00f3).\"\"\"\n    release: str\n    \"\"\"Versi\u00f3 del sistema operatiu. (versi\u00f3)\"\"\"\n    version: str\n    \"\"\"Versi\u00f3 del sistema operatiu. (versi\u00f3)\"\"\"\n    machine: str\n    \"\"\"Identificador del maquinari. (m\u00e0quina)\"\"\"\n\ndef uname() -> uname_result:\n    \"\"\"Retorna informaci\u00f3 que identifica el sistema operatiu actual.\n\nExample: ``os.uname()``\n\nThe return value is an object with five attributes:\n\n- ``sysname`` - operating system name\n- ``nodename`` - name of machine on network (implementation-defined)\n- ``release`` - operating system release\n- ``version`` - operating system version\n- ``machine`` - hardware identifier\n\nThere is no underlying operating system in MicroPython. As a result the\ninformation returned by the ``uname`` function is mostly useful for\nversioning details.\"\"\"\n    ...",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "\"\"\"Comunicar-se entre micro:bits amb la r\u00e0dio integrada. (r\u00e0dio)\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom typing import Optional, Tuple\nRATE_1MBIT: int\n\"\"\"La constant utilitzada per indicar un rendiment d'1 Mbit per segon. (velocitat de transmissi\u00f3 1mbit)\"\"\"\nRATE_2MBIT: int\n\"\"\"La constant utilitzada per indicar un rendiment de 2 Mbit per segon. (velocitat de transmissi\u00f3 2mbit)\"\"\"\n\ndef on() -> None:\n    \"\"\"Enc\u00e9n la r\u00e0dio.\n\nExample: ``radio.on()``\n\nThis needs to be explicitly called since the radio draws power and takes\nup memory that you may otherwise need.\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Apaga la r\u00e0dio, estalviant energia i mem\u00f2ria.\n\nExample: ``radio.off()``\"\"\"\n    ...\n\ndef config(length: int=32, queue: int=3, channel: int=7, power: int=6, address: int=1969383796, group: int=0, data_rate: int=RATE_1MBIT) -> None:\n    \"\"\"Configura la r\u00e0dio.\n\nExample: ``radio.config(group=42)``\n\nThe default configuration is suitable for most use.\n\n:param length: (llargada) (per defecte=32) defineix la longitud m\u00e0xima, en bytes, d'un missatge enviat a trav\u00e9s de la r\u00e0dio.\nPot tenir una longitud de fins a 251 bytes (254 - 3 bytes per al pre\u00e0mbul S0, LENGTH i S1).\n:param queue: (cua) (per defecte=3) especifica el nombre de missatges que es poden emmagatzemar a la cua de missatges entrants.\nSi no queden espais a la cua per als missatges entrants, s'elimina el missatge entrant.\n:param channel: (canal) (per defecte=7) un valor enter de 0 a 83 (inclosos) que defineix un \"canal\" arbitrari al qual est\u00e0 sintonitzada la r\u00e0dio.\nEls missatges s'enviaran a trav\u00e9s d'aquest canal i nom\u00e9s els missatges rebuts per aquest canal es posaran a la cua de missatges entrants. Cada pas t\u00e9 una amplada d'1MHz, basat en 2400MHz.\n:param power: (per defecte=6) \u00e9s un valor enter de 0 a 7 (inclosos) per indicar la intensitat del senyal utilitzat quan s'emet un missatge.\nCom m\u00e9s alt sigui el valor, m\u00e9s fort \u00e9s el senyal, per\u00f2 m\u00e9s pot\u00e8ncia consumeix el dispositiu. La numeraci\u00f3 es tradueix en posicions a la llista seg\u00fcent de valors en dBm (decibels mil\u00b7liwatts): -30, -20, -16, -12, -8, -4, 0, 4.\n:param address: (adre\u00e7a) (per defecte=0x75626974) un nom arbitrari, expressat com una adre\u00e7a de 32 bits, que s'utilitza per filtrar els paquets entrants a nivell de maquinari, conservant nom\u00e9s els que coincideixen amb l'adre\u00e7a que has establert.\nLa configuraci\u00f3 predeterminada utilitzada per altres plataformes relacionades amb micro:bit \u00e9s la configuraci\u00f3 predeterminada que s'utilitza aqu\u00ed.\n:param group: (grup) (per defecte=0) un valor de 8 bits (0-255) utilitzat amb l'``address`` (adre\u00e7a) en filtrar missatges.\nConceptualment, \"adre\u00e7a\" \u00e9s com una adre\u00e7a de casa/oficina i \"grup\" \u00e9s com la persona a aquesta adre\u00e7a a la qual vols enviar el teu missatge.\n:param data_rate: (velocitat de dades) (per defecte=``radio.RATE_1MBIT``) indica la velocitat a la qual es produeix la transmissi\u00f3 de les dades.\nPot ser una de les constants seg\u00fcents definides al m\u00f2dul ``radio``: ``RATE_250KBIT``, ``RATE_1MBIT`` o ``RATE_2MBIT``.\n\nIf ``config`` is not called then the defaults described above are assumed.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Restableix la configuraci\u00f3 als seus valors predeterminats. (reiniciar)\n\nExample: ``radio.reset()``\n\nThe defaults as as per the ``config`` function above.\"\"\"\n    ...\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Envia un  missatge que cont\u00e9 bytes. (enviar bytes)\n\nExample: ``radio.send_bytes(b'hello')``\n\n:param message: (missatge) Els bytes a ser enviats.\"\"\"\n    ...\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Rebr\u00e0s el seg\u00fcent missatge entrant a la cua de missatges. (rebre bytes)\n\nExample: ``radio.receive_bytes()``\n\n:return: The message bytes if any, otherwise ``None``.\"\"\"\n    ...\n\ndef receive_bytes_into(buffer: WriteableBuffer) -> Optional[int]:\n    \"\"\"Copia el seg\u00fcent missatge entrant de la cua de missatges a una mem\u00f2ria interm\u00e8dia. (rebre bytes a)\n\nExample: ``radio.receive_bytes_info(buffer)``\n\n:param buffer: (mem\u00f2ria interm\u00e8dia) La mem\u00f2ria interm\u00e8dia objectiu. El missatge es trunca si \u00e9s m\u00e9s gran que la mem\u00f2ria interm\u00e8dia.\n:return: ``None`` if there are no pending messages, otherwise it returns the length of the message (which might be more than the length of the buffer).\"\"\"\n    ...\n\ndef send(message: str) -> None:\n    \"\"\"Envia una cadena de missatge. (envia)\n\nExample: ``radio.send('hello')``\n\nThis is the equivalent of ``radio.send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\nprepended to the front (to make it compatible with other platforms that target the micro:bit).\n\n:param message: (missatge) La cadena a enviar.\"\"\"\n    ...\n\ndef receive() -> Optional[str]:\n    \"\"\"Funciona exactament de la mateixa manera que ``receive_bytes`` per\u00f2 retorna el que s'ha enviat.\n\nExample: ``radio.receive()``\n\nEquivalent to ``str(receive_bytes(), 'utf8')`` but with a check that the the first\nthree bytes are ``b'\\x01\\x00\\x01'`` (to make it compatible with other platforms that\nmay target the micro:bit).\n\n:return: The message with the prepended bytes stripped and converted to a string.\n\nA ``ValueError`` exception is raised if conversion to string fails.\"\"\"\n    ...\n\ndef receive_full() -> Optional[Tuple[bytes, int, int]]:\n    \"\"\"Retorna una tupla que cont\u00e9 tres valors que representen el seg\u00fcent missatge entrant a la cua de missatges. (rebre ple)\n\nExample: ``radio.receive_full()``\n\nIf there are no pending messages then ``None`` is returned.\n\nThe three values in the tuple represent:\n\n- the next incoming message on the message queue as bytes.\n- the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n- a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\nFor example::\n\n    details = radio.receive_full()\n    if details:\n        msg, rssi, timestamp = details\n\nThis function is useful for providing information needed for triangulation\nand/or trilateration with other micro:bit devices.\n\n:return: ``None`` if there is no message, otherwise a tuple of length three with the bytes, strength and timestamp values.\"\"\"\n    ...",
    "/typeshed/stdlib/random.pyi": "\"\"\"Genera nombres aleatoris. (aleatori)\"\"\"\nfrom typing import TypeVar, Sequence, Union, overload\n\ndef getrandbits(n: int) -> int:\n    \"\"\"Genera un nombre enter amb ``n`` bits aleatoris.\n\nExample: ``random.getrandbits(1)``\n\n:param n: Un valor entre 1-30 (inclusiu).\"\"\"\n    ...\n\ndef seed(n: int) -> None:\n    \"\"\"Inicialitza el generador de nombres aleatoris. (llavor)\n\nExample: ``random.seed(0)``\n\n:param n: The integer seed\n\nThis will give you reproducibly deterministic randomness from a given starting\nstate (``n``).\"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int:\n    \"\"\"Tria un nombre enter aleatori entre ``a`` i ``b`` inclosos.\n\nExample: ``random.randint(0, 9)``\n\n:param a: Valor inicial de l'interval (incl\u00f2s)\n:param b: Valor final de l'interval (incl\u00f2s)\n\nAlias for ``randrange(a, b + 1)``.\"\"\"\n    ...\n\n@overload\ndef randrange(stop: int) -> int:\n    \"\"\"Tria un nombre enter seleccionat aleat\u00f2riament entre zero i fins a (per\u00f2 no\nincl\u00f2s) ``stop``.\n\nExample: ``random.randrange(10)``\n\n:param stop: (atura) Valor final de l'interval (excl\u00f2s)\"\"\"\n    ...\n\n@overload\ndef randrange(start: int, stop: int, step: int=1) -> int:\n    \"\"\"Tria un element seleccionat aleat\u00f2riament de ``range(start, stop, step)``.\n\nExample: ``random.randrange(0, 10)``\n\n:param start: L'inici de l'interval (incl\u00f2s)\n:param stop: (atura) El final de l'interval (exclusiu)\n:param step: El pas.\"\"\"\n    ...\n_T = TypeVar('_T')\n\ndef choice(seq: Sequence[_T]) -> _T:\n    \"\"\"Tria un element aleatori de la seq\u00fc\u00e8ncia no buida ``seq``.\n\nExample: ``random.choice([Image.HAPPY, Image.SAD])``\n\n:param seq: Una seq\u00fc\u00e8ncia.\n\nIf ``seq`` is  empty, raises ``IndexError``.\"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"Genera un nombre aleatori de coma flotant en l'interval [0.0, 1.0). (aleatori)\n\nExample: ``random.random()``\n\n:return: The random floating point number\"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float:\n    \"\"\"Retorna un nombre de coma flotant aleatori entre ``a`` i ``b`` inclosos. (uniforme)\n\nExample: ``random.uniform(0, 9)``\n\n:param a: Valor inicial de l'interval (incl\u00f2s)\n:param b: Valor final de l'interval (incl\u00f2s)\"\"\"\n    ...",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Fes que la micro:bit parli, canti i fer altres expressions com els sons.\"\"\"\nfrom typing import Optional\nfrom .microbit import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Tradueix paraules angleses a fonemes. (tradueix)\n\nExample: ``speech.translate('hello world')``\n\n:param words: (paraules) Una cadena de paraules angleses.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Pronuncia fonemes. (pronuncia)\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemes) La cadena de fonemes a pronunciar\n:param pitch: (to) Un nombre que representa la freq\u00fc\u00e8ncia de la veu\n:param speed: (velocitat) Un nombre que representa la velocitat de la veu\n:param mouth: (boca) Un nombre que representa la boca de la veu\n:param throat: Un nombre que representa la gola de la veu\n:param pin: L'argument opcional per especificar el pin de sortida es pot utilitzar per anul\u00b7lar el valor predeterminat de ``pin0``.\nSi no vols que es reprodueixi cap so en els pins, podts utilitzar ``pin=None``. Nom\u00e9s micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Digues paraules en angl\u00e8s.\n\nExample: ``speech.say('hello world')``\n\n:param words: (paraules) La cadena de paraules a dir.\n:param pitch: (to) Un nombre que representa la freq\u00fc\u00e8ncia de la veu\n:param speed: (velocitat) Un nombre que representa la velocitat de la veu\n:param mouth: (boca) Un nombre que representa la boca de la veu\n:param throat: Un nombre que representa la gola de la veu\n:param pin: L'argument opcional per especificar el pin de sortida es pot utilitzar per anul\u00b7lar el valor predeterminat del ``pin0``.\nSi no vols que es reprodueixi cap so en els pins, pots utilitzar ``pin=None``. Nom\u00e9s micro:bit V2.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Cantar fonemes.\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemes) La cadena de paraules a cantar.\n:param pitch: (to) Un nombre que representa la freq\u00fc\u00e8ncia de la veu\n:param speed: (velocitat) Un nombre que representa la velocitat de la veu\n:param mouth: (boca) Un nombre que representa la boca de la veu\n:param throat: Un nombre que representa la gola de la veu\n:param pin: L'argument opcional per especificar el pin de sortida es pot utilitzar per anul\u00b7lar el valor predeterminat de ``pin0``.\nSi no vols que es reprodueixi cap so en els pins, podts utilitzar ``pin=None``. Nom\u00e9s micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "\"\"\"Empaquetar i desempaquetar tipus de dades primitius.\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom typing import Any, Tuple, Union\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"Obt\u00e9 el nombre de bytes necessaris per emmagatzemar el ``fmt`` donat.\n\nExample: ``struct.calcsize('hf')``\n\n:param fmt: Una cadena de format.\n:return The number of bytes needed to store such a value.\"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"Empaqueta els valors segons una cadena de format.\n\nExample: ``struct.pack('hf', 1, 3.1415)``\n\n:param fmt: La cadena de format.\n:param v1: El primer valor.\n:param *vn: La resta de valors.\n:return A bytes object encoding the values.\"\"\"\n    ...\n\ndef pack_into(fmt: str, buffer: WriteableBuffer, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"Empaqueta els valors segons una cadena de format.\n\nExample: ``struct.pack_info('hf', buffer, 1, 3.1415)``\n\n:param fmt: La cadena de format.\n:param buffer: (mem\u00f2ria interm\u00e8dia) La mem\u00f2ria interm\u00e8dia de destinaci\u00f3 on escriure.\n:param offset: El despla\u00e7ament a la mem\u00f2ria interm\u00e8dia. Pot ser negatiu per comptar des del final de la mem\u00f2ria interm\u00e8dia.\n:param v1: El primer valor.\n:param *vn: La resta de valors.\"\"\"\n    ...\n\ndef unpack(fmt: str, data: ReadableBuffer) -> Tuple[Any, ...]:\n    \"\"\"Desempaqueta les dades segons una cadena de format.\n\nExample: ``v1, v2 = struct.unpack('hf', buffer)``\n\n:param fmt: La cadena de format.\n:param data: Les dades.\n:return: A tuple of the unpacked values.\"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: ReadableBuffer, offset: int=0) -> Tuple:\n    \"\"\"Desempaqueta les dades d'una mem\u00f2ria interm\u00e8dia  segons una cadena de format. (desempaqueta des de)\n\nExample: ``v1, v2 = struct.unpack_from('hf', buffer)``\n\n:param fmt: La cadena de format.\n:param buffer: (mem\u00f2ria interm\u00e8dia) La mem\u00f2ria interm\u00e8dia d'origen d'on llegir.\n:param offset: El despla\u00e7ament a la mem\u00f2ria interm\u00e8dia. Pot ser negatiu per comptar des del final de la mem\u00f2ria interm\u00e8dia.\n:return: A tuple of the unpacked values.\"\"\"\n    ...",
    "/typeshed/stdlib/sys.pyi": "\"\"\"Funcions espec\u00edfiques del sistema\"\"\"\nfrom typing import Any, Dict, List, NoReturn, TextIO, Tuple\n\ndef exit(retval: object=...) -> NoReturn:\n    \"\"\"Finalitza el programa actual amb un codi de sortida determinat.\n\nExample: ``sys.exit(1)``\n\nThis function raises a ``SystemExit`` exception. If an argument is given, its\nvalue given as an argument to ``SystemExit``.\n\n:param retval: El codi o missatge de sortida.\"\"\"\n    ...\n\ndef print_exception(exc: Exception) -> None:\n    \"\"\"Imprimeix una excepci\u00f3 amb un rastreig.\n\nExample: ``sys.print_exception(e)``\n\n:param exc: L'excepci\u00f3 a imprimir\n\nThis is simplified version of a function which appears in the\n``traceback`` module in CPython.\"\"\"\nargv: List[str]\n\"\"\"Una llista mutable d'arguments amb qu\u00e8 s'ha iniciat el programa actual.\"\"\"\nbyteorder: str\n\"\"\"L'ordre dels bytes del sistema (``\"little\"`` o ``\"big\"``).\"\"\"\n\nclass _implementation:\n    name: str\n    version: Tuple[int, int, int]\nimplementation: _implementation\n\"\"\"Objecte amb informaci\u00f3 sobre la implementaci\u00f3 actual de Python. (implementaci\u00f3)\n\nFor MicroPython, it has following attributes:\n\n- ``name`` - string \"micropython\"\n- ``version`` - tuple (major, minor, micro), e.g. (1, 7, 0)\n\nThis object is the recommended way to distinguish MicroPython from other\nPython implementations (note that it still may not exist in the very\nminimal ports).\n\nCPython mandates more attributes for this object, but the actual useful\nbare minimum is implemented in MicroPython.\n\"\"\"\nmaxsize: int\n\"\"\"\nValor m\u00e0xim que pot tenir un tipus d'enter natiu a la plataforma actual,\no valor m\u00e0xim representable pel tipus d'enter MicroPython, si \u00e9s m\u00e9s petit\nque el valor m\u00e0xim de la plataforma (\u00e9s el cas dels ports MicroPython sense\nsuport d'enter llarg - long int support).\n\nThis attribute is useful for detecting \"bitness\" of a platform (32-bit vs\n64-bit, etc.). It's recommended to not compare this attribute to some\nvalue directly, but instead count number of bits in it::\n\n    bits = 0\n    v = sys.maxsize\n    while v:\n        bits += 1\n        v >>= 1\n    if bits > 32:\n        # 64-bit (or more) platform\n        ...\n    else:\n        # 32-bit (or less) platform\n        # Note that on 32-bit platform, value of bits may be less than 32\n        # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n        # \"> 32\", \"> 64\" style of comparisons.\n\"\"\"\nmodules: Dict[str, Any]\n\"\"\"Diccionari de m\u00f2duls carregats. (m\u00f2duls) \n\nOn some ports, it may not include builtin modules.\"\"\"\npath: List[str]\n\"\"\"Una llista mutable de directoris per cercar m\u00f2duls importats.\"\"\"\nplatform: str\n\"\"\"La plataforma en qu\u00e8 s'executa MicroPython. (plataforma) \n\nFor OS/RTOS ports, this is usually an identifier of the OS, e.g. ``\"linux\"``.\nFor baremetal ports it is an identifier of a board, e.g. ``\"pyboard\"`` for \nthe original MicroPython reference board. It thus can be used to\ndistinguish one board from another.\n\nIf you need to check whether your program runs on MicroPython (vs other\nPython implementation), use ``sys.implementation`` instead.\n\"\"\"\nversion: str\n\"\"\"Versi\u00f3 del llenguatge Python a la qual s'ajusta aquesta implementaci\u00f3, com a cadena. (versi\u00f3)\"\"\"\nversion_info: Tuple[int, int, int]\n\"\"\"Versi\u00f3 del llenguatge Python a la qual s'ajusta aquesta implementaci\u00f3, com una tupla d'enters. (informaci\u00f3 de la versi\u00f3)\n\nOnly the first three version numbers (major, minor, micro) are supported and\nthey can be referenced only by index, not by name.\n\"\"\"",
    "/typeshed/stdlib/this.pyi": "def authors() -> str: ...\n",
    "/typeshed/stdlib/time.pyi": "\"\"\"Mesura el temps i afegeix retards als programes. (temps)\"\"\"\nfrom typing import Union\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"Retarda uns segons. (dormir)\n\nExample: ``time.sleep(1)``\n\n:param seconds: (segons) El nombre de segons per posar en pausa.\nUtilitza un nombre de coma flotant per posar en pausa durant una fracci\u00f3 de segons.\"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"Retard per a un nombre determinat de mil\u00b7lisegons. (retard en mil\u00b7lisegons)\n\nExample: ``time.sleep_ms(1_000_000)``\n\n:param ms: El nombre de mil\u00b7lisegons de retard (>= 0).\"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"Retard per a un nombre determinat de microsegons.\n\nExample: ``time.sleep_us(1000)``\n\n:param us: El nombre de microsegons de retard (>= 0).\"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"Obt\u00e9 un comptador creixent de mil\u00b7lisegons amb un punt de refer\u00e8ncia arbitrari,\nque es desborda despr\u00e9s d'algun valor. (tics mil\u00b7lisegons)\n\nExample: ``time.ticks_ms()``\n\n:return: The counter value in milliseconds.\"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"Obt\u00e9 un comptador creixent de microsegons amb un punt de refer\u00e8ncia arbitrari,\nque es desborda despr\u00e9s d'algun valor. (tics microsegons)\n\nExample: ``time.ticks_us()``\n\n:return: The counter value in microseconds.\"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"Afegeix al valor de tics un despla\u00e7ament determinat, que pot ser positiu o\nnegatiu. (tics compensa)\n\nExample: ``time.ticks_add(time.ticks_ms(), 200)``\n\nGiven a ticks value, this function allows to calculate ticks\nvalue delta ticks before or after it, following modular-arithmetic\ndefinition of tick values.\n\n:param ticks: Un valor de tics\n:param delta: Un despla\u00e7ament enter\n\nExample::\n\n    # Find out what ticks value there was 100ms ago\n    print(ticks_add(time.ticks_ms(), -100))\n\n    # Calculate deadline for operation and test for it\n    deadline = ticks_add(time.ticks_ms(), 200)\n    while ticks_diff(deadline, time.ticks_ms()) > 0:\n        do_a_little_of_something()\n\n    # Find out TICKS_MAX used by this port\n    print(ticks_add(0, -1))\"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"Mesura la difer\u00e8ncia dels tics entre els valors retornats\n``time.ticks_ms()`` o ``ticks_us()``, com a valor amb signe\nque pot desbordar-se.\n\nExample: ``time.ticks_diff(scheduled_time, now)``\n\n:param ticks1: El valor a restar de\n:param ticks2: El valor a restar\n\nThe argument order is the same as for subtraction operator,\n``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n``ticks_diff()`` is designed to accommodate various usage\npatterns, among them:\n\nPolling with timeout. In this case, the order of events is known, and you\nwill deal only with positive results of :func:`time.ticks_diff()`::\n\n    # Wait for GPIO pin to be asserted, but at most 500us\n    start = time.ticks_us()\n    while pin.value() == 0:\n        if time.ticks_diff(time.ticks_us(), start) > 500:\n            raise TimeoutError\n\n\nScheduling events. In this case, :func:`time.ticks_diff()` result may be\nnegative if an event is overdue::\n\n    # This code snippet is not optimized\n    now = time.ticks_ms()\n    scheduled_time = task.scheduled_time()\n    if ticks_diff(scheduled_time, now) > 0:\n        print(\"Too early, let's nap\")\n        sleep_ms(ticks_diff(scheduled_time, now))\n        task.run()\n    elif ticks_diff(scheduled_time, now) == 0:\n        print(\"Right at time!\")\n        task.run()\n    elif ticks_diff(scheduled_time, now) < 0:\n        print(\"Oops, running late, tell task to run faster!\")\n        task.run(run_faster=True)\"\"\"\n    ...",
    "/typeshed/stdlib/types.pyi": "import sys\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    __hash__: None  # type: ignore\n    cell_contents: Any\n\n@final\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    __globals__: dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: None  # type: ignore\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: dict[str, Any]\n    __package__: str | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: GeneratorType[_T_co, _T_contra, Any] | None\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Awaitable[Any] | None\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\n@final\nclass CoroutineType:\n    cr_await: Any | None\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: object | None, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    __closure__: Tuple[_Cell, ...] | None  # inherited from the added function\n    __defaults__: Tuple[Any, ...] | None  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    __self__: object | ModuleType\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    @final\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    @final\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\n@final\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(\n            self,\n            tb_next: TracebackType | None,\n            tb_frame: FrameType,\n            tb_lasti: int,\n            tb_lineno: int,\n        ) -> None: ...\n        tb_next: TracebackType | None\n    else:\n        @property\n        def tb_next(self) -> TracebackType | None: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    f_back: FrameType | None\n    f_builtins: dict[str, Any]\n    f_code: CodeType\n    f_globals: dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: dict[str, Any]\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: dict[str, Any] | None = ...\n) -> Tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    @final\n    class UnionType:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> UnionType: ...\n        def __ror__(self, obj: Any) -> UnionType: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = ...,\n    localns: dict[str, Any] | None = ...,\n    include_extras: bool = ...,\n) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Type[Any] | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: None | Type[Any] | str = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "from array import *\n",
    "/typeshed/stdlib/ucollections.pyi": "from collections import *\n",
    "/typeshed/stdlib/uerrno.pyi": "from errno import *\n",
    "/typeshed/stdlib/urandom.pyi": "from random import *\n",
    "/typeshed/stdlib/ustruct.pyi": "from struct import *\n",
    "/typeshed/stdlib/usys.pyi": "from sys import *\n",
    "/typeshed/stdlib/utime.pyi": "from time import *\n",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any]]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any]]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"Pins, imatges, sons, temperatura i volum.\"\"\"\nfrom typing import Any, Callable, List, Optional, Tuple, Union, overload\nfrom _typeshed import ReadableBuffer\nfrom . import accelerometer as accelerometer\nfrom . import audio as audio\nfrom . import compass as compass\nfrom . import display as display\nfrom . import i2c as i2c\nfrom . import microphone as microphone\nfrom . import speaker as speaker\nfrom . import spi as spi\nfrom . import uart as uart\n\ndef run_every(callback: Optional[Callable[[], None]]=None, days: int=0, h: int=0, min: int=0, s: int=0, ms: int=0) -> Callable[[Callable[[], None]], Callable[[], None]]:\n    \"\"\"Programa l'execuci\u00f3 d'una funci\u00f3 a cada interval especificat pels arguments de temps  **nom\u00e9s V2**.\n\nExample: ``run_every(my_logging, min=5)``\n\n``run_every`` can be used in two ways:\n\nAs a Decorator - placed on top of the function to schedule. For example::\n\n    @run_every(h=1, min=20, s=30, ms=50)\n    def my_function():\n        # Do something here\n\nAs a Function - passing the callback as a positional argument. For example::\n\n    def my_function():\n        # Do something here\n    run_every(my_function, s=30)\n\nEach argument corresponds to a different time unit and they are additive.\nSo ``run_every(min=1, s=30)`` schedules the callback every minute and a half.\n\nWhen an exception is thrown inside the callback function it deschedules the\nfunction. To avoid this you can catch exceptions with ``try/except``.\n\n:param callback: Funci\u00f3 a cridar a l'interval previst. Omet quan el fas servir com decorador.\n:param days: (dies) Estableix la marca del dia per la programaci\u00f3\n:param h: Estableix la marca de l'hora per la programaci\u00f3\n:param min: Estableix la marca del minut per la programaci\u00f3\n:param s: Estableix la marca del segon per la programaci\u00f3\n:param ms: Estableix la marca del mil\u00b7lisegon per la programaci\u00f3\"\"\"\n\ndef panic(n: int) -> None:\n    \"\"\"Entrar en mode p\u00e0nic. (p\u00e0nic)\n\nExample: ``panic(127)``\n\n:param n: Un nombre enter arbitrari <= 255 per indicar un estat.\n\nRequires restart.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Reinicialitza la placa. (reiniciar)\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[int, int]) -> int:\n    \"\"\"Converteix un valor d'un interval a un interval de nombre enter. (escala)\n\nExample: ``volume = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))``\n\nFor example, to convert an accelerometer X value to a speaker volume.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\n\n    temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))\n\n:param value: (valor) Un nombre a convertir.\n:param from_: (des de) Una tupla des d'on definir l'interval a convertir\n:param to: (a) Una tupla que defineix l'interval d'arribada\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[float, float]) -> float:\n    \"\"\"Converteix un valor d'un interval a un altre interval de coma flotant. (escala)\n\nExample: ``temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))``\n\nFor example, to convert temperature from a Celsius scale to Fahrenheit.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\nIf they are both integers (i.e ``10``), it will return an integer::\n\n    returns_int = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))\n\n:param value: (valor) Un nombre a convertir.\n:param from_: (des de) Una tupla des d'on definir l'interval a convertir\n:param to: (a) Una tupla que defineix l'interval d'arribada de la conversi\u00f3.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\ndef sleep(n: float) -> None:\n    \"\"\"Espera per ``n`` mil\u00b7lisegons. (dormir)\n\nExample: ``sleep(1000)``\n\n:param n: El nombre de mil\u00b7lisegons a esperar\n\nOne second is 1000 milliseconds, so::\n\n    microbit.sleep(1000)\n\nwill pause the execution for one second.\"\"\"\n\ndef running_time() -> int:\n    \"\"\"Obt\u00e9 el temps d'execuci\u00f3 de la placa. (temps d'execuci\u00f3)\n\n:return: The number of milliseconds since the board was switched on or restarted.\"\"\"\n\ndef temperature() -> int:\n    \"\"\"Obt\u00e9 la temperatura de la micro:bit en graus Celsius. (temperatura)\"\"\"\n\ndef set_volume(v: int) -> None:\n    \"\"\"Configura el volum (assigna volum)\n\nExample: ``set_volume(127)``\n\n:param v: un valor entre 0 (baix) i 255 (alt).\n\nOut of range values will be clamped to 0 or 255.\n\n**V2** only.\"\"\"\n    ...\n\nclass Button:\n    \"\"\"La classe dels botons ``button_a`` i ``button_b``. (bot\u00f3)\"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"Verifica si el bot\u00f3 est\u00e0 premut. (\u00e9s premut)\n\n:return: ``True`` if the specified button ``button`` is pressed, and ``False`` otherwise.\"\"\"\n        ...\n\n    def was_pressed(self) -> bool:\n        \"\"\"Verifica si el bot\u00f3 ha estat premut d'en\u00e7\u00e0 que el dispositiu va arrancar o l'\u00faltima vegada que aquest m\u00e8tode va ser cridat. (ha estat premut)\n\nCalling this method will clear the press state so\nthat the button must be pressed again before this method will return\n``True`` again.\n\n:return: ``True`` if the specified button ``button`` was pressed, and ``False`` otherwise\"\"\"\n        ...\n\n    def get_presses(self) -> int:\n        \"\"\"Obt\u00e9 el total acumulat de pressions dels botons i restableix aquest total\na zero abans de tornar. (obt\u00e9 pitjades)\n\n:return: The number of presses since the device started or the last time this method was called\"\"\"\n        ...\nbutton_a: Button\n\"\"\"L'objecte bot\u00f3 esquerre ``Button`` . (bot\u00f3 a)\"\"\"\nbutton_b: Button\n\"\"\"L'objecte el bot\u00f3 dret ``Button``. (bot\u00f3 b)\"\"\"\n\nclass MicroBitDigitalPin:\n    \"\"\"Un pin digital.\n\nSome pins support analog and touch features using the ``MicroBitAnalogDigitalPin`` and ``MicroBitTouchPin`` subclasses.\"\"\"\n    NO_PULL: int\n    PULL_UP: int\n    PULL_DOWN: int\n\n    def read_digital(self) -> int:\n        \"\"\"Obt\u00e9 el valor digital del pin. (llegeix digital)\n\nExample: ``value = pin0.read_digital()``\n\n:return: 1 if the pin is high, and 0 if it's low.\"\"\"\n        ...\n\n    def write_digital(self, value: int) -> None:\n        \"\"\"Assigna el valor digital del pin. (escriu digital)\n\nExample: ``pin0.write_digital(1)``\n\n:param value: (valor) 1 per posar el pin alt o 0 per posar el pin baix\"\"\"\n        ...\n\n    def set_pull(self, value: int) -> None:\n        \"\"\"Configura les resist\u00e8ncies de pull-up/pull-down un dels tres valors possibles: ``PULL_UP``, ``PULL_DOWN`` o ``NO_PULL``. (configuraci\u00f3 de les resist\u00e8ncies de pull up/down)\n\nExample: ``pin0.set_pull(pin0.PULL_UP)``\n\n:param value: (valor) L'estat del pull-up/pull-down del pin corresponent, per ex. ``pin0.PULL_UP``.\"\"\"\n        ...\n\n    def get_pull(self) -> int:\n        \"\"\"Obt\u00e9 l'estat de pull-up/pull-down d'un pin.\n\nExample: ``pin0.get_pull()``\n\n:return: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``\n\nThese are set using the ``set_pull()`` method or automatically configured\nwhen a pin mode requires it.\"\"\"\n        ...\n\n    def get_mode(self) -> str:\n        \"\"\"Retorna el mode del pin (obt\u00e9 el mode)\n\nExample: ``pin0.get_mode()``\n\nWhen a pin is used for a specific function, like\nwriting a digital value, or reading an analog value, the pin mode\nchanges.\n\n:return: ``\"unused\"``, ``\"analog\"``, ``\"read_digital\"``, ``\"write_digital\"``, ``\"display\"``, ``\"button\"``, ``\"music\"``, ``\"audio\"``, ``\"touch\"``, ``\"i2c\"``, or ``\"spi\"``\"\"\"\n        ...\n\n    def write_analog(self, value: int) -> None:\n        \"\"\"Genera un senyal PWM al pin, amb el cicle de treball proporcional a ``value``. (escriu anal\u00f2gic)\n\nExample: ``pin0.write_analog(254)``\n\n:param value: (valor) Un nombre enter o de coma flotant entre 0 (cicle de treball del 0%) i 1023 (cicle de treball del 100%).\"\"\"\n\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"Estableix el per\u00edode del senyal PWM a ``period`` en mil\u00b7lisegons. (configura el per\u00edode amb un valor anal\u00f2gic)\n\nExample: ``pin0.set_analog_period(10)``\n\n:param period: (per\u00edode) El per\u00edode en mil\u00b7lisegons amb un valor m\u00ednim v\u00e0lid d'1\\u202fms\"\"\"\n\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"Estableix el per\u00edode del senyal PWM a ``period`` microsegons. (configura el per\u00edode amb un valor anal\u00f2gic en microsegons)\n\nExample: ``pin0.set_analog_period_microseconds(512)``\n\n:param period: (per\u00edode) El per\u00edode en microsegons amb un valor v\u00e0lid m\u00ednim  de 256\\u202f\u00b5s.\"\"\"\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    \"\"\"Un pin amb funcions anal\u00f2giques i digitals.\"\"\"\n\n    def read_analog(self) -> int:\n        \"\"\"Llegeix el voltatge aplicat al pin. (llegeix anal\u00f2gic)\n\nExample: ``pin0.read_analog()``\n\n:return: An integer between 0 (meaning 0V) and 1023 (meaning 3.3V).\"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    \"\"\"Un pin amb  caracter\u00edstiques anal\u00f2giques, digitals i t\u00e0ctils.\"\"\"\n    CAPACITIVE: int\n    RESISTIVE: int\n\n    def is_touched(self) -> bool:\n        \"\"\"Comprova si el pin est\u00e0 sent tocat. (est\u00e0 tocat)\n\nExample: ``pin0.is_touched()``\n\nThe default touch mode for the pins on the edge connector is ``resistive``.\nThe default for the logo pin **V2** is ``capacitive``.\n\n**Resistive touch**\nThis test is done by measuring how much resistance there is between the\npin and ground.  A low resistance gives a reading of ``True``.  To get\na reliable reading using a finger you may need to touch the ground pin\nwith another part of your body, for example your other hand.\n\n**Capacitive touch**\nThis test is done by interacting with the electric field of a capacitor\nusing a finger as a conductor. `Capacitive touch\n<https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_\ndoes not require you to make a ground connection as part of a circuit.\n\n:return: ``True`` if the pin is being touched with a finger, otherwise return ``False``.\"\"\"\n        ...\n\n    def set_touch_mode(self, value: int) -> None:\n        \"\"\"Estableix el mode t\u00e0ctil per al pin. (estableix el mode t\u00e0ctil)\n\nExample: ``pin0.set_touch_mode(pin0.CAPACITIVE)``\n\nThe default touch mode for the pins on the edge connector is\n``resistive``. The default for the logo pin **V2** is ``capacitive``.\n\n:param value: (valor) ``CAPACITIVE`` o ``RESISTIVE`` del pin corresponent.\"\"\"\n        ...\npin0: MicroBitTouchPin\n\"\"\"Pin amb caracter\u00edstiques digitals, anal\u00f2giques i t\u00e0ctils.\"\"\"\npin1: MicroBitTouchPin\n\"\"\"Pin amb caracter\u00edstiques digitals, anal\u00f2giques i t\u00e0ctils.\"\"\"\npin2: MicroBitTouchPin\n\"\"\"Pin amb caracter\u00edstiques digitals, anal\u00f2giques i t\u00e0ctils.\"\"\"\npin3: MicroBitAnalogDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals i anal\u00f2giques.\"\"\"\npin4: MicroBitAnalogDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals i anal\u00f2giques.\"\"\"\npin5: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin6: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin7: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin8: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin9: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin10: MicroBitAnalogDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals i anal\u00f2giques.\"\"\"\npin11: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin12: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin13: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin14: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin15: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin16: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin19: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin20: MicroBitDigitalPin\n\"\"\"Pin amb caracter\u00edstiques digitals.\"\"\"\npin_logo: MicroBitTouchPin\n\"\"\"Un logotip t\u00e0ctil a la part frontal de la micro:bit, que per defecte est\u00e0 establert al mode t\u00e0ctil capacitiu. (pin logotip)\"\"\"\npin_speaker: MicroBitAnalogDigitalPin\n\"\"\"Un pin per adre\u00e7ar-se a l'altaveu micro:bit. (pin altaveu)\n\nThis API is intended only for use in Pulse-Width Modulation pin operations e.g. pin_speaker.write_analog(128).\n\"\"\"\n\nclass Image:\n    \"\"\"Una imatge per mostrar a la pantalla LED de micro:bit. (imatge)\n\nGiven an image object it's possible to display it via the ``display`` API::\n\n    display.show(Image.HAPPY)\"\"\"\n    HEART: Image\n    \"\"\"Imatge d'un cor. (cor)\"\"\"\n    HEART_SMALL: Image\n    \"\"\"Imatge d'un cor petit (cor petit)\"\"\"\n    HAPPY: Image\n    \"\"\"Imatge d'una cara feli\u00e7 (feli\u00e7)\"\"\"\n    SMILE: Image\n    \"\"\"Imatge d'una cara somrient (somriure)\"\"\"\n    SAD: Image\n    \"\"\"Imatge d'una cara trista (tristesa)\"\"\"\n    CONFUSED: Image\n    \"\"\"Imatge de cara confusa. (confusa)\"\"\"\n    ANGRY: Image\n    \"\"\"Imatge d'una cara enfadada. (enfadat)\"\"\"\n    ASLEEP: Image\n    \"\"\"Imatge d'una cara dormint. (despert)\"\"\"\n    SURPRISED: Image\n    \"\"\"Imatge d'una cara de sorpresa (sorpr\u00e8s)\"\"\"\n    SILLY: Image\n    \"\"\"Imatge d'una cara ximple. (ximple)\"\"\"\n    FABULOUS: Image\n    \"\"\"Imatge d'una cara amb ulleres de sol. (fabul\u00f3s)\"\"\"\n    MEH: Image\n    \"\"\"Imatge d'una cara inexpressiva. (BAH avorrit)\"\"\"\n    YES: Image\n    \"\"\"Imatge d'una marca tic. (s\u00ed)\"\"\"\n    NO: Image\n    \"\"\"Imatge d'una creu.\"\"\"\n    CLOCK12: Image\n    \"\"\"Imatge d'una l\u00ednia apuntant les dotze. (les dotze)\"\"\"\n    CLOCK11: Image\n    \"\"\"Imatge d'una l\u00ednia apuntant les onze. (les onze)\"\"\"\n    CLOCK10: Image\n    \"\"\"Imatge d'una l\u00ednia apuntant les deu. (les deu)\"\"\"\n    CLOCK9: Image\n    \"\"\"Imatge d'una l\u00ednia apuntant les nou. (les nou)\"\"\"\n    CLOCK8: Image\n    \"\"\"Imatge d'una l\u00ednia apuntant les vuit. (les vuit)\"\"\"\n    CLOCK7: Image\n    \"\"\"Imatge d'una l\u00ednia apuntant les set. (les set)\"\"\"\n    CLOCK6: Image\n    \"\"\"Imatge amb una l\u00ednia apuntant a les 6 en punt. (les sis)\"\"\"\n    CLOCK5: Image\n    \"\"\"Imatge amb una l\u00ednia apuntant a les 5 en punt. (les cinc)\"\"\"\n    CLOCK4: Image\n    \"\"\"Imatge amb una l\u00ednia apuntant a les 4 en punt. (les quatre)\"\"\"\n    CLOCK3: Image\n    \"\"\"Imatge amb una l\u00ednia apuntant a les 3 en punt. (les tres)\"\"\"\n    CLOCK2: Image\n    \"\"\"Imatge amb una l\u00ednia apuntant a les 2 en punt. (les dues)\"\"\"\n    CLOCK1: Image\n    \"\"\"Imatge amb una l\u00ednia apuntant a la 1 en punt. (la una)\"\"\"\n    ARROW_N: Image\n    \"\"\"Imatge de fletxa apuntant al nord. (fletxa n)\"\"\"\n    ARROW_NE: Image\n    \"\"\"Imatge de fletxa apuntant al nord-est. (fletxa ne)\"\"\"\n    ARROW_E: Image\n    \"\"\"Imatge de fletxa apuntant a l'est. (fletxa e)\"\"\"\n    ARROW_SE: Image\n    \"\"\"Imatge de fletxa apuntant al sud-est. (fletxa se)\"\"\"\n    ARROW_S: Image\n    \"\"\"Imatge de fletxa apuntant al sud. (fletxa s)\"\"\"\n    ARROW_SW: Image\n    \"\"\"Imatge de fletxa apuntant al sud-oest. (fletxa so)\"\"\"\n    ARROW_W: Image\n    \"\"\"Imatge de fletxa apuntant a l'oest. (fletxa o)\"\"\"\n    ARROW_NW: Image\n    \"\"\"Imatge de fletxa apuntant al nord-oest. (fletxa no)\"\"\"\n    TRIANGLE: Image\n    \"\"\"Imatge d'un triangle apuntant amunt.\"\"\"\n    TRIANGLE_LEFT: Image\n    \"\"\"Imatge d'un triangle en la cantonada esquerra. (triangle a l'esquerra)\"\"\"\n    CHESSBOARD: Image\n    \"\"\"Leds alternatius il\u00b7luminats en un patr\u00f3 d'escacs. (Tauler d'escacs)\"\"\"\n    DIAMOND: Image\n    \"\"\"Imatge d'un diamant (diamant)\"\"\"\n    DIAMOND_SMALL: Image\n    \"\"\"Imatge d'un diamant petit (diamant petit)\"\"\"\n    SQUARE: Image\n    \"\"\"Imatge d'un quadrat (quadrat)\"\"\"\n    SQUARE_SMALL: Image\n    \"\"\"Imatge d'un quadrat petit (quadrat petit)\"\"\"\n    RABBIT: Image\n    \"\"\"Imatge d'un conill. (conill)\"\"\"\n    COW: Image\n    \"\"\"Imatge d'una vaca. (vaca)\"\"\"\n    MUSIC_CROTCHET: Image\n    \"\"\"Imatge de la nota musical negra (nota musical negra)\"\"\"\n    MUSIC_QUAVER: Image\n    \"\"\"Imatge de la nota musical corxera (nota musical corxera)\"\"\"\n    MUSIC_QUAVERS: Image\n    \"\"\"Imatge d'un parell de notes musicals corxeres (nota musical corxera)\"\"\"\n    PITCHFORK: Image\n    \"\"\"Imatge d'una forca. (forca)\"\"\"\n    XMAS: Image\n    \"\"\"Imatge d'un arbre de Nadal (nadal)\"\"\"\n    PACMAN: Image\n    \"\"\"Imatge del personatge de Pac-man a arcade\"\"\"\n    TARGET: Image\n    \"\"\"Imatge d'objectiu. (diana)\"\"\"\n    TSHIRT: Image\n    \"\"\"Imatge de samarreta. (Imatge d'una samarreta T-shirt)\"\"\"\n    ROLLERSKATE: Image\n    \"\"\"Imatge d'un patinet. (patinet)\"\"\"\n    DUCK: Image\n    \"\"\"Imatge d'un \u00e0nec. (\u00e0nec)\"\"\"\n    HOUSE: Image\n    \"\"\"Imatge d'una casa. (casa)\"\"\"\n    TORTOISE: Image\n    \"\"\"Imatge d'una tortuga. (tortuga)\"\"\"\n    BUTTERFLY: Image\n    \"\"\"Imatge d'una papallona. (papallona)\"\"\"\n    STICKFIGURE: Image\n    \"\"\"Imatge de figura d'un pal. (imatge d'un pal)\"\"\"\n    GHOST: Image\n    \"\"\"Imatge d'un fantasma. (fantasma)\"\"\"\n    SWORD: Image\n    \"\"\"Imatge d'una espasa (espasa)\"\"\"\n    GIRAFFE: Image\n    \"\"\"Imatge d'una girafa. (girafa)\"\"\"\n    SKULL: Image\n    \"\"\"Imatge d'un crani. (crani)\"\"\"\n    UMBRELLA: Image\n    \"\"\"Imatge d'un paraigua, (paraigua)\"\"\"\n    SNAKE: Image\n    \"\"\"Imatge d'una serp. (serp)\"\"\"\n    SCISSORS: Image\n    \"\"\"Imatge d'unes tisores. (tisores)\"\"\"\n    ALL_CLOCKS: List[Image]\n    \"\"\"Una llista que cont\u00e9 totes les imatges CLOCK_ en seq\u00fc\u00e8ncia. (tots els rellotges)\"\"\"\n    ALL_ARROWS: List[Image]\n    \"\"\"Una llista que cont\u00e9 totes les ARROW_images en seq\u00fc\u00e8ncia. (totes les fletxes)\"\"\"\n\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"Crea una imatge a partir d'una cadena que descrigui quins leds estan encesos.\n\n``string`` has to consist of digits 0-9 arranged into lines,\ndescribing the image, for example::\n\n    image = Image(\"90009:\"\n                  \"09090:\"\n                  \"00900:\"\n                  \"09090:\"\n                  \"90009\")\n\nwill create a 5\u00d75 image of an X. The end of a line is indicated by a\ncolon. It's also possible to use newlines (\\\\n) insead of the colons.\n\n:param string: (cadena) La cadena descrivint la imatge.\"\"\"\n        ...\n\n    @overload\n    def __init__(self, width: int=5, height: int=5, buffer: ReadableBuffer=None) -> None:\n        \"\"\"Crea una imatge buida amb ``width`` columnes i ``height`` files.\n\n:param width: (amplada) Amplada opcional de la imatge\n:param height: (al\u00e7\u00e0ria) Al\u00e7\u00e0ria opcional de la imatge\n:param buffer: (mem\u00f2ria interm\u00e8dia) Llistes o bytes opcionals d'enters de ``width``\u00d7``height`` dins l'interval de 0 a 9 per inicialitzar la imatge\n\nExamples::\n\n    Image(2, 2, b'\\x08\\x08\\x08\\x08')\n    Image(2, 2, bytearray([9,9,9,9]))\n\nThese create 2 x 2 pixel images at full brightness.\"\"\"\n        ...\n\n    def width(self) -> int:\n        \"\"\"Obt\u00e9 el nombre de columnes (amplada)\n\n:return: The number of columns in the image\"\"\"\n        ...\n\n    def height(self) -> int:\n        \"\"\"Obt\u00e9 el nombre de files. (al\u00e7\u00e0ria)\n\n:return: The number of rows in the image\"\"\"\n        ...\n\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"Estableix la brillantor d'un p\u00edxel. (estableix p\u00edxel)\n\nExample: ``my_image.set_pixel(0, 0, 9)``\n\n:param x: El nombre de la columna\n:param y: El nombre de la fila\n:param value: (valor) La brillantor com a nombre enter entre 0 (fosc) i 9 (brillant)\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"Obt\u00e9 la brillantor d'un p\u00edxel. (obt\u00e9 p\u00edxel)\n\nExample: ``my_image.get_pixel(0, 0)``\n\n:param x: El nombre de la columna\n:param y: El nombre de la fila\n:return: The brightness as an integer between 0 and 9.\"\"\"\n        ...\n\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Crea una imatge nova movent-la cap a l'esquerra. (despla\u00e7a a l'esquerra)\n\nExample: ``Image.HEART_SMALL.shift_left(1)``\n\n:param n: El nombre de columnes per despla\u00e7ar-se\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Crea una imatge nova movent-la cap a la dreta. (despla\u00e7a a la dreta)\n\nExample: ``Image.HEART_SMALL.shift_right(1)``\n\n:param n: El nombre de columnes per despla\u00e7ar-se\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Crea una imatge nova despla\u00e7ant la imatge cap amunt. (despla\u00e7a cap amunt)\n\nExample: ``Image.HEART_SMALL.shift_up(1)``\n\n:param n: El nombre de files per despla\u00e7ar-se\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Crea una imatge nova despla\u00e7ant-la cap avall. (despla\u00e7a cap avall)\n\nExample: ``Image.HEART_SMALL.shift_down(1)``\n\n:param n: El nombre de files per despla\u00e7ar-se\n:return: The shifted image\"\"\"\n        ...\n\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Crea una imatge nova retallant la imatge. (retalla)\n\nExample: ``Image.HEART.crop(1, 1, 3, 3)``\n\n:param x: La columna de despla\u00e7ament del retall\n:param y: La fila de despla\u00e7ament del retall\n:param w: L'amplada del retall\n:param h: L'al\u00e7\u00e0ria del retall\n:return: The new image\"\"\"\n        ...\n\n    def copy(self) -> Image:\n        \"\"\"Crea una c\u00f2pia exacta de la imatge (c\u00f2pia)\n\nExample: ``Image.HEART.copy()``\n\n:return: The new image\"\"\"\n        ...\n\n    def invert(self) -> Image:\n        \"\"\"Crea una imatge nova invertint la brillantor dels p\u00edxels de la imatge\nfont. (inverteix)\n\nExample: ``Image.SMALL_HEART.invert()``\n\n:return: The new image.\"\"\"\n        ...\n\n    def fill(self, value: int) -> None:\n        \"\"\"Assigna la brillantor de tots els p\u00edxels de la imatge (omple)\n\nExample: ``my_image.fill(5)``\n\n:param value: (valor) La nova brillantor com a nombre entre 0 (fosc) i 9 (brillant).\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def blit(self, src: Image, x: int, y: int, w: int, h: int, xdest: int=0, ydest: int=0) -> None:\n        \"\"\"Copia una \u00e0rea d'una altra imatge a aquesta imatge.\n\nExample: ``my_image.blit(Image.HEART, 1, 1, 3, 3, 1, 1)``\n\n:param src: (font) La imatge font\n:param x: Despla\u00e7ament de la columna inicial a la imatge d'origen\n:param y: Despla\u00e7ament de la fila inicial a la imatge d'origen\n:param w: El nombre de columnes a copiar\n:param h: El nombre de files a copiar\n:param xdest: El despla\u00e7ament de columna a modificar en aquesta imatge\n:param ydest: El despla\u00e7ament de fila que cal modificar en aquesta imatge\n\nPixels outside the source image are treated as having a brightness of 0.\n\n``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\nand ``crop()`` can are all implemented by using ``blit()``.\n\nFor example, img.crop(x, y, w, h) can be implemented as::\n\n    def crop(self, x, y, w, h):\n        res = Image(w, h)\n        res.blit(self, x, y, w, h)\n        return res\"\"\"\n        ...\n\n    def __repr__(self) -> str:\n        \"\"\"Obt\u00e9 una representaci\u00f3 de cadena compacta de la imatge. (repr - Obt\u00e9 una representaci\u00f3 de cadena compacta de la imatge.)\"\"\"\n        ...\n\n    def __str__(self) -> str:\n        \"\"\"Obt\u00e9 una representaci\u00f3 de cadena llegible de la imatge.\"\"\"\n        ...\n\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Crea una imatge nova afegint els valors de brillantor de les dues\nimatges per a cada p\u00edxel. (afegeix)\n\nExample: ``Image.HEART + Image.HAPPY``\n\n:param other: (altre) La imatge a afegir.\"\"\"\n        ...\n\n    def __sub__(self, other: Image) -> Image:\n        \"\"\"Crea una imatge nova restant els valors de brillantor d'una altra imatge d'aquesta imatge.\n\nExample: ``Image.HEART - Image.HEART_SMALL``\n\n:param other: (altre) La imatge a restar.\"\"\"\n        ...\n\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Crea una imatge nova multiplicant la brillantor de cada p\u00edxel per\n``n``.\n\nExample: ``Image.HEART * 0.5``\n\n:param n: El valor per multiplicar.\"\"\"\n        ...\n\n    def __truediv__(self, n: float) -> Image:\n        \"\"\"Crea una imatge nova dividint la brillantor de cada p\u00edxel per\n``n``.\n\nExample: ``Image.HEART / 2``\n\n:param n: El valor del divisor.\"\"\"\n        ...\n\nclass SoundEvent:\n    LOUD: SoundEvent\n    \"\"\"Representa la transici\u00f3 dels esdeveniments de so, des de ``quiet`` a ``loud`` com picant de mans o cridant. (so fort)\"\"\"\n    QUIET: SoundEvent\n    \"\"\"Representa la transici\u00f3 dels esdeveniments de so, des de ``loud`` a ``quiet`` com parlant o m\u00fasica de fons. (so fluix)\"\"\"\n\nclass Sound:\n    \"\"\"Els sons integrats es poden reproduir mitjan\u00e7ant ``audio.play(Sound.NAME)``. (so)\"\"\"\n    GIGGLE: Sound\n    \"\"\"So de riure (riure)\"\"\"\n    HAPPY: Sound\n    \"\"\"So feli\u00e7. (feli\u00e7)\"\"\"\n    HELLO: Sound\n    \"\"\"So de salutaci\u00f3. (hola)\"\"\"\n    MYSTERIOUS: Sound\n    \"\"\"So misteri\u00f3s. (misteri\u00f3s)\"\"\"\n    SAD: Sound\n    \"\"\"So trist. (tristesa)\"\"\"\n    SLIDE: Sound\n    \"\"\"So lliscant (so lliscant)\"\"\"\n    SOARING: Sound\n    \"\"\"So creixent. (creixent)\"\"\"\n    SPRING: Sound\n    \"\"\"So primaveral. (primaveral)\"\"\"\n    TWINKLE: Sound\n    \"\"\"So de centelleig. (centelleig)\"\"\"\n    YAWN: Sound\n    \"\"\"So de badall. (badall)\"\"\"",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"Mesura l'acceleraci\u00f3 de la micro:bit i reconeix els gestos. (acceler\u00f2metre)\"\"\"\nfrom typing import Tuple\n\ndef get_x() -> int:\n    \"\"\"Obt\u00e9 la mesura de l'acceleraci\u00f3 a l'eix ``x`` en mili-g. (obt\u00e9 x)\n\nExample: ``accelerometer.get_x()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Obt\u00e9 la mesura de l'acceleraci\u00f3 a l'eix ``y`` en mili-g. (obt\u00e9 y)\n\nExample: ``accelerometer.get_y()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Obt\u00e9 la mesura de l'acceleraci\u00f3 a l'eix ``z`` en mili-g. (obt\u00e9 z)\n\nExample: ``accelerometer.get_z()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"Obt\u00e9 les mesures d'acceleraci\u00f3 en tots els eixos alhora com una tupla. (obt\u00e9 valors)\n\nExample: ``x, y, z = accelerometer.get_values()``\n\n:return: a three-element tuple of integers ordered as X, Y, Z, each value a positive or negative integer depending on direction in the range +/- 2000mg\"\"\"\n    ...\n\ndef get_strength() -> int:\n    \"\"\"Obt\u00e9 la mesura de l'acceleraci\u00f3 de tots els eixos combinats, com un nombre enter positiu. Aquest ser\u00e0 la suma Pitag\u00f2rica dels eixos X, Y i Z. (obt\u00e9 la for\u00e7a)\n\nExample: ``accelerometer.get_strength()``\n\n:return: The combined acceleration strength of all the axes, in milli-g.\"\"\"\n    ...\n\ndef current_gesture() -> str:\n    \"\"\"Obt\u00e9 el nom del gest actual. (El gest actual)\n\nExample: ``accelerometer.current_gesture()``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:return: The current gesture\"\"\"\n    ...\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"Comprova si el gest nomenat est\u00e0 actiu actualment.\n\nExample: ``accelerometer.is_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (nom) El nom del gest\n:return: ``True`` if the gesture is active, ``False`` otherwise.\"\"\"\n    ...\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"Comprova si el gest nomenat ha estat actiu des de l'\u00faltima crida.\n\nExample: ``accelerometer.was_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (nom) El nom del gest\n:return: ``True`` if the gesture was active since the last call, ``False`` otherwise.\"\"\"\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Retorna una tupla de l'historial de gestos. (obt\u00e9 gestos)\n\nExample: ``accelerometer.get_gestures()``\n\nClears the gesture history before returning.\n\nGestures are not updated in the background so there needs to be constant\ncalls to some accelerometer method to do the gesture detection. Usually\ngestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n\n:return: The history as a tuple, most recent last.\"\"\"\n    ...\n\ndef set_range(value: int) -> None:\n    \"\"\"Estableix l'interval de la sensibilitat de l'acceler\u00f2metre, en g (gravetat est\u00e0ndard), al valor m\u00e9s proper acceptat pel maquinari, arrodonit a ``2``, ``4``, o ``8``\n\nExample: ``accelerometer.set_range(8)``\n\n:param value: (valor) Nou interval per a l'acceler\u00f2metre, un nombre enter a ``g``.\"\"\"",
    "/typeshed/stdlib/microbit/audio.pyi": "\"\"\"Reprodueix sons amb la micro:bit (importa ``audio`` per a la compatibilitat amb V1). (\u00e0udio)\"\"\"\nfrom ..microbit import MicroBitDigitalPin, Sound, pin0\nfrom typing import ClassVar, Iterable, Union\n\ndef play(source: Union[Iterable[AudioFrame], Sound, SoundEffect], wait: bool=True, pin: MicroBitDigitalPin=pin0, return_pin: Union[MicroBitDigitalPin, None]=None) -> None:\n    \"\"\"Reprodueix un so incorporat, un efecte de s\u00f3 o marcs d'\u00e0udio personalitzats.\n\nExample: ``audio.play(Sound.GIGGLE)``\n\n:param source: (origen) Un objecte de ``Sound`` incorporat com ``Sound.GIGGLE``, un ``SoundEffect`` o una data de mostra com un iterable de ``AudioFrame`` .\n:param wait: (espera) Si ``wait`` \u00e9s ``True``, aquesta funci\u00f3 es bloquejar\u00e0 fins que s'acabi el so.\n:param pin: Es pot utilitzar un argument opcional per especificar el pin de sortida per anul\u00b7lar el valor predeterminat de ``pin0``. Si no vols que es reprodueixi cap so, pots utilitzar ``pin=None``.\n:param return_pin: (retorna el pin) Especifica un pin diferent del connector d'expansi\u00f3 per connectar-lo a un altaveu extern en lloc de posar a terra. Aix\u00f2 s'ignora per a la revisi\u00f3 **V2**.\"\"\"\n\ndef is_playing() -> bool:\n    \"\"\"Verifica si s'est\u00e0 reproduint un so. (est\u00e0 reproduint)\n\nExample: ``audio.is_playing()``\n\n:return: ``True`` if audio is playing, otherwise ``False``.\"\"\"\n    ...\n\ndef stop() -> None:\n    \"\"\"Atura tota la reproducci\u00f3 d'\u00e0udio. (atura)\n\nExample: ``audio.stop()``\"\"\"\n    ...\n\nclass SoundEffect:\n    \"\"\"Un efecte sonor, compost per un conjunt de par\u00e0metres configurats via el constructor o atributs.\"\"\"\n    WAVEFORM_SINE: ClassVar[int]\n    \"\"\"Opci\u00f3 d'ona sinusoidal pel par\u00e0metre ``waveform``. (forma d'ona sinusoidal)\"\"\"\n    WAVEFORM_SAWTOOTH: ClassVar[int]\n    \"\"\"Opci\u00f3 d'ona de dent de serra pel par\u00e0metre ``waveform``. (forma d'ona de dent de serra)\"\"\"\n    WAVEFORM_TRIANGLE: ClassVar[int]\n    \"\"\"Opci\u00f3 d'ona triangular pel par\u00e0metre ``waveform``. (forma d'ona triangular)\"\"\"\n    WAVEFORM_SQUARE: ClassVar[int]\n    \"\"\"Opci\u00f3 d'ona quadrada pel par\u00e0metre ``waveform``. (forma d'ona quadrada)\"\"\"\n    WAVEFORM_NOISE: ClassVar[int]\n    \"\"\"Opci\u00f3 d'ona de soroll pel par\u00e0metre ``waveform``. (forma d'ona de soroll)\"\"\"\n    SHAPE_LINEAR: ClassVar[int]\n    \"\"\"Opci\u00f3 d'ona lineal pel par\u00e0metre ``shape``. (forma lineal)\"\"\"\n    SHAPE_CURVE: ClassVar[int]\n    \"\"\"Opci\u00f3 d'interpolaci\u00f3 de corba usada pel par\u00e0metre ``shape``. (forma de corba)\"\"\"\n    SHAPE_LOG: ClassVar[int]\n    \"\"\"Opci\u00f3 d'interpolaci\u00f3 logar\u00edtmica utilitzada pel par\u00e0metre ``shape``. (forma logar\u00edtmica)\"\"\"\n    FX_NONE: ClassVar[int]\n    \"\"\"Opci\u00f3 de cap efecte utilitzat pel par\u00e0metre ``fx``. (fx cap)\"\"\"\n    FX_TREMOLO: ClassVar[int]\n    \"\"\"Opci\u00f3 d'efecte tr\u00e8molo utilitzat pel par\u00e0metre ``fx``. (fx tr\u00e9molo)\"\"\"\n    FX_VIBRATO: ClassVar[int]\n    \"\"\"Opci\u00f3 d'efecte vibrato utilitzat pel par\u00e0metre ``fx``.\"\"\"\n    FX_WARBLE: ClassVar[int]\n    \"\"\"Opci\u00f3 d'efecte gorjeu utilitzat pel par\u00e0metre ``fx``. (Efecte gorjeu)\"\"\"\n    freq_start: int\n    \"\"\"Freq\u00fc\u00e8ncia inicial en Hertz (Hz), un nombre entre ``0`` i ``9999`` (freq\u00fc\u00e8ncia inicial)\"\"\"\n    freq_end: int\n    \"\"\"Freq\u00fc\u00e8ncia final en Hertz (Hz), un nombre entre ``0`` i ``9999`` (frequ\u00e8ncia final)\"\"\"\n    duration: int\n    \"\"\"Durada del so en mil\u00b7lisegons, un nombre entre ``0`` and ``9999`` (Durada - duraci\u00f3)\"\"\"\n    vol_start: int\n    \"\"\"Volum inicial, un nombre entre ``0`` and ``255`` (volum inicial)\"\"\"\n    vol_end: int\n    \"\"\"Valor del volum final, un nombre entre ``0`` and ``255`` (volum final)\"\"\"\n    waveform: int\n    \"\"\"Tipus de forma d'ona, un d'aquest valors: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (randomly generated noise) (forma d'ona)\"\"\"\n    fx: int\n    \"\"\"Efecte a afegir al so, un dels seg\u00fcents valors: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``, or ``FX_NONE`` (efecte)\"\"\"\n    shape: int\n    \"\"\"El tipus de corba d'interpolaci\u00f3 entre les freq\u00fc\u00e8ncies inicial i final, diferents formes d'ona tenen diferents r\u00e0tios de canvi en la freq\u00fc\u00e8ncia. Un dels seg\u00fcents valors: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG`` (forma)\"\"\"\n\n    def __init__(self, freq_start: int=500, freq_end: int=2500, duration: int=500, vol_start: int=255, vol_end: int=0, waveform: int=WAVEFORM_SQUARE, fx: int=FX_NONE, shape: int=SHAPE_LOG):\n        \"\"\"Crea un efecte de so nou. (inicial)\n\nExample: ``my_effect = SoundEffect(duration=1000)``\n\nAll the parameters are optional, with default values as shown above, and\nthey can all be modified via attributes of the same name. For example, we\ncan first create an effect ``my_effect = SoundEffect(duration=1000)``,\nand then change its attributes ``my_effect.duration = 500``.\n\n:param freq_start: (freq\u00fc\u00e8ncia inicial) Freq\u00fc\u00e8ncia inicial en Hertz (Hz), un nombre entre ``0`` i ``9999``.\n:param freq_end: (frequ\u00e8ncia final) Freq\u00fc\u00e8ncia final en Hertz (Hz), un nombre entre ``0`` i ``9999``.\n:param duration: (Durada - duraci\u00f3) Duraci\u00f3 del so en mil\u00b7lisegons, un nombre entre ``0`` i ``9999``.\n:param vol_start: (volum inicial) Valor del volum inicial, un nombre entre ``0`` i ``255``.\n:param vol_end: (volum final) Valor del volum final, un nombre entre ``0`` i ``255``.\n:param waveform: (forma d'ona) Tipus de forma d'ona, un d'aquests valors: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (soroll generat aleat\u00f2riament).\n:param fx: (efecte) Efecte a afegir al so, un del seg\u00fcents valors: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``, or ``FX_NONE``.\n:param shape: (forma) El tipus de corba d'interpolaci\u00f3 entre les freq\u00fc\u00e8ncies inicial i final, diferents formes d'ona tenen diferents r\u00e0tios de canvi en la freq\u00fc\u00e8ncia. Un dels seg\u00fcents valors: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``\"\"\"\n\n    def copy(self) -> SoundEffect:\n        \"\"\"Crea una c\u00f2pia d'aquest ``SoundEffect``. (c\u00f2pia)\n\nExample: ``sound_2 = sound_1.copy()``\n\n:return: A copy of the SoundEffect.\"\"\"\n\nclass AudioFrame:\n    \"\"\"Un objecte ``AudioFrame`` \u00e9s una llista de 32 mostres cadascuna de les quals \u00e9s un byte sense signar\n(nombre enter entre 0 i 255).\n\nIt takes just over 4 ms to play a single frame.\n\nExample::\n\n    frame = AudioFrame()\n    for i in range(len(frame)):\n        frame[i] = 252 - i * 8\"\"\"\n\n    def copyfrom(self, other: AudioFrame) -> None:\n        \"\"\"Sobreposa les dades d'aquest ``AudioFrame`` amb les dades d'una altra inst\u00e0ncia ``AudioFrame`` . (copia desde)\n\nExample: ``my_frame.copyfrom(source_frame)``\n\n:param other: (altre) ``AudioFrame`` inst\u00e0ncia de la qual copiar les dades.\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __setitem__(self, key: int, value: int) -> None:\n        ...\n\n    def __getitem__(self, key: int) -> int:\n        ...",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"Utilitza la br\u00faixola integrada. (br\u00faixola)\"\"\"\n\ndef calibrate() -> None:\n    \"\"\"Comen\u00e7a el proc\u00e9s de calibraci\u00f3 (calibrar)\n\nExample: ``compass.calibrate()``\n\nAn instructive message will be scrolled to the user after which they will need\nto rotate the device in order to draw a circle on the LED display.\"\"\"\n    ...\n\ndef is_calibrated() -> bool:\n    \"\"\"Verifica si la br\u00faixola est\u00e0 calibrada. (s'ha calibrat)\n\nExample: ``compass.is_calibrated()``\n\n:return: ``True`` if the compass has been successfully calibrated, ``False`` otherwise.\"\"\"\n    ...\n\ndef clear_calibration() -> None:\n    \"\"\"Desf\u00e0 el calibratge, fent que la br\u00faixola torni a estar sense calibraci\u00f3. (esborra la calibraci\u00f3)\n\nExample: ``compass.clear_calibration()``\"\"\"\n    ...\n\ndef get_x() -> int:\n    \"\"\"Obt\u00e9 la intensitat del camp magn\u00e8tic de l'eix ``x`` . (obt\u00e9 x)\n\nExample: ``compass.get_x()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Obt\u00e9 la intensitat del camp magn\u00e8tic de l'eix ``y`` . (obt\u00e9 y)\n\nExample: ``compass.get_y()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Obt\u00e9 la intensitat del camp magn\u00e8tic a l'eix ``z``. (obt\u00e9 z)\n\nExample: ``compass.get_z()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef heading() -> int:\n    \"\"\"Obt\u00e9 l'orientaci\u00f3 de la br\u00faixola.\n\nExample: ``compass.heading()``\n\n:return: An integer in the range from 0 to 360, representing the angle in degrees, clockwise, with north as 0.\"\"\"\n    ...\n\ndef get_field_strength() -> int:\n    \"\"\"Obt\u00e9 la magnitud del camp magn\u00e8tic al voltant del dispositiu. (obt\u00e9 la intensitat del camp)\n\nExample: ``compass.get_field_strength()``\n\n:return: An integer indication of the magnitude of the magnetic field in nano tesla.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"Mostra text, imatges i animacions a la pantalla LED 5\u00d75. (pantalla)\"\"\"\nfrom ..microbit import Image\nfrom typing import Union, overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"Obt\u00e9 la brillantor del LED a la columna ``x`` i la fila ``y``. (obt\u00e9 p\u00edxel)\n\nExample: ``display.get_pixel(0, 0)``\n\n:param x: La columna de la pantalla (0...4)\n:param y: La fila de la pantalla (0...4)\n:return: A number between 0 (off) and 9 (bright)\"\"\"\n    ...\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"Estableix la brillantor del LED a la columna ``x`` i la fila ``y``. (estableix p\u00edxel)\n\nExample: ``display.set_pixel(0, 0, 9)``\n\n:param x: La columna de la pantalla (0...4)\n:param y: La fila de la pantalla (0...4)\n:param value: (valor) La brillantor entre 0 (apagat) i 9 (brillant)\"\"\"\n    ...\n\ndef clear() -> None:\n    \"\"\"Estableix la brillantor de tots els leds a 0 (apagat).\n\nExample: ``display.clear()``\"\"\"\n    ...\n\ndef show(image: Union[str, float, int, Image, Iterable[Image]], delay: int=400, wait: bool=True, loop: bool=False, clear: bool=False) -> None:\n    \"\"\"Mostra imatges, lletres o d\u00edgits en la pantalla LED. (mostra)\n\nExample: ``display.show(Image.HEART)``\n\nWhen ``image`` is an image or a list of images then each image is displayed in turn.\nIf ``image`` is a string or number, each letter or digit is displayed in turn.\n\n:param image: (imatge) Una cadena, un nombre, una imatge o una llista d'imatges per mostrar.\n:param delay: (retard) Cada lletra, d\u00edgit o imatge es mostra amb un ``delay`` mil\u00b7lisegons entre ells.\n:param wait: (espera) Si ``wait`` \u00e9s ``True``, aquesta funci\u00f3 es bloquejar\u00e0 fins que s'acabi l'animaci\u00f3, en cas contrari, l'animaci\u00f3 passar\u00e0 en segon pla.\n:param loop: (bucle) Si el ``loop`` \u00e9s ``True``, l'animaci\u00f3 es repetir\u00e0 per sempre.\n:param clear: Si ``clear`` \u00e9s ``True``, la pantalla s'esborrar\u00e0 un cop finalitzada la seq\u00fc\u00e8ncia.\n\nThe ``wait``, ``loop`` and ``clear`` arguments must be specified using their keyword.\"\"\"\n    ...\n\ndef scroll(text: Union[str, float, int], delay: int=150, wait: bool=True, loop: bool=False, monospace: bool=False) -> None:\n    \"\"\"Despla\u00e7a un n\u00famero o text per la pantalla LED.\n\nExample: ``display.scroll('micro:bit')``\n\n:param text: La cadena per a despla\u00e7ar. Si ``text`` \u00e9s un nombre enter o flotant, primer es converteix en una cadena mitjan\u00e7ant ``str()``.\n:param delay: (retard) El par\u00e0metre ``delay`` controla la rapidesa amb qu\u00e8 es despla\u00e7a el text.\n:param wait: (espera) Si ``wait`` \u00e9s ``True``, aquesta funci\u00f3 es bloquejar\u00e0 fins que s'acabi l'animaci\u00f3, en cas contrari, l'animaci\u00f3 passar\u00e0 en segon pla.\n:param loop: (bucle) Si el ``loop`` \u00e9s ``True``, l'animaci\u00f3 es repetir\u00e0 per sempre.\n:param monospace: Si ``monospace`` \u00e9s ``True``, tots els car\u00e0cters ocuparan 5 columnes de p\u00edxels d'amplada, en cas contrari, hi haur\u00e0 exactament 1 columna de p\u00edxels en blanc entre cada car\u00e0cter mentre es desplacen.\n\nThe ``wait``, ``loop`` and ``monospace`` arguments must be specified\nusing their keyword.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Enc\u00e9n la pantalla LED.\n\nExample: ``display.on()``\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Apaga la pantalla LED (desactivar la pantalla et permet reutilitzar els pins GPIO per a altres finalitats).\n\nExample: ``display.off()``\"\"\"\n    ...\n\ndef is_on() -> bool:\n    \"\"\"Comprova si la pantalla LED est\u00e0 habilitada.\n\nExample: ``display.is_on()``\n\n:return: ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n    ...\n\ndef read_light_level() -> int:\n    \"\"\"Llegeix el nivell de llum. (llegir el nivell de llum)\n\nExample: ``display.read_light_level()``\n\nUses the display's LEDs in reverse-bias mode to sense the amount of light\nfalling on the display.\n\n:return: An integer between 0 and 255 representing the light level, with larger meaning more light.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"Comunicar-se amb dispositius mitjan\u00e7ant el protocol de bus I\u00b2C.\"\"\"\nfrom _typeshed import ReadableBuffer\nfrom ..microbit import MicroBitDigitalPin, pin19, pin20\nfrom typing import List\n\ndef init(freq: int=100000, sda: MicroBitDigitalPin=pin20, scl: MicroBitDigitalPin=pin19) -> None:\n    \"\"\"Reinicialitzar un perif\u00e8ric.\n\nExample: ``i2c.init()``\n\n:param freq: freq\u00fc\u00e8ncia del rellotge\n:param sda: Pin ``sda`` (per defecte 20)\n:param scl: pin ``scl``  (per defecte 19)\n\nOn a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\nthe accelerometer and compass stop working, as they are connected\ninternally to those pins. This warning does not apply to the **V2**\nrevision of the micro:bit as this has `separate I\u00b2C lines <https://tech.microbit.org/hardware/i2c/>`_\nfor the motion sensors and the edge connector.\"\"\"\n    ...\n\ndef scan() -> List[int]:\n    \"\"\"Escaneja el bus dels dispositius\n\nExample: ``i2c.scan()``\n\n:return: A list of 7-bit addresses corresponding to those devices that responded to the scan.\"\"\"\n    ...\n\ndef read(addr: int, n: int, repeat: bool=False) -> bytes:\n    \"\"\"Llegeix bytes des d'un dispositiu. (llegeix)\n\nExample: ``i2c.read(0x50, 64)``\n\n:param addr: L'adre\u00e7a de 7-bit del dispositiu\n:param n: El nombre de bytes a llegir\n:param repeat: (repeteix) Si ``True``, no s'enviar\u00e0 cap bit d'aturada\n:return: The bytes read\"\"\"\n    ...\n\ndef write(addr: int, buf: ReadableBuffer, repeat: bool=False) -> None:\n    \"\"\"Escriu bytes en un dispositiu (escriu)\n\nExample: ``i2c.write(0x50, bytes([1, 2, 3]))``\n\n:param addr: L'adre\u00e7a de 7-bit del dispositiu\n:param buf: Una mem\u00f2ria interm\u00e8dia que cont\u00e9 els bytes per escriure\n:param repeat: (repeteix) Si ``True``, no s'enviar\u00e0 cap bit d'aturada\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/microphone.pyi": "\"\"\"Respon al so fent servir el micr\u00f2fon integrat (nom\u00e9s V2). (micr\u00f2fon)\"\"\"\nfrom typing import Optional, Tuple\nfrom ..microbit import SoundEvent\n\ndef current_event() -> Optional[SoundEvent]:\n    \"\"\"Obt\u00e9 l'\u00faltim esdeveniment de sonor gravat (esdeveniment actual)\n\nExample: ``microphone.current_event()``\n\n:return: The event, ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.\"\"\"\n    ...\n\ndef was_event(event: SoundEvent) -> bool:\n    \"\"\"Comprova si s'ha sentit un so almenys una vegada des de l'\u00faltima crida. (va ser un esdeveniment)\n\nExample: ``microphone.was_event(SoundEvent.LOUD)``\n\nThis call clears the sound history before returning.\n\n:param event: (esdeveniment) L'esdeveniment per comprovar, com ara ``SoundEvent.LOUD`` o ``SoundEvent.QUIET``\n:return: ``True`` if sound was heard at least once since the last call, otherwise ``False``.\"\"\"\n    ...\n\ndef is_event(event: SoundEvent) -> bool:\n    \"\"\"Comprova l'esdeveniment sonor m\u00e9s recent detectat. (\u00e9s un esdeveniment)\n\nExample: ``microphone.is_event(SoundEvent.LOUD)``\n\nThis call does not clear the sound event history.\n\n:param event: (esdeveniment) L'esdeveniment per comprovar, com ara ``SoundEvent.LOUD`` o ``SoundEvent.QUIET``\n:return: ``True`` if sound was the most recent heard, ``False`` otherwise.\"\"\"\n    ...\n\ndef get_events() -> Tuple[SoundEvent, ...]:\n    \"\"\"Obt\u00e9 l'historial d'esdeveniments sonors com una tupla. (obt\u00e9 esdeveniments)\n\nExample: ``microphone.get_events()``\n\nThis call clears the sound history before returning.\n\n:return: A tuple of the event history with the most recent event last.\"\"\"\n    ...\n\ndef set_threshold(event: SoundEvent, value: int) -> None:\n    \"\"\"Assigna el llinar per un esdeveniment sonor (estableix llindar)\n\nExample: ``microphone.set_threshold(SoundEvent.LOUD, 250)``\n\nA high threshold means the event will only trigger if the sound is very loud (>= 250 in the example).\n\n:param event: (esdeveniment) Un esdeveniment sonor, com ara ``SoundEvent.LOUD`` o ``SoundEvent.QUIET``.\n:param value: (valor) El llindar en l'interval 0-255.\"\"\"\n    ...\n\ndef sound_level() -> int:\n    \"\"\"Obt\u00e9 el nivell de pressi\u00f3 sonora. (nivell de so)\n\nExample: ``microphone.sound_level()``\n\n:return: A representation of the sound pressure level in the range 0 to 255.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/speaker.pyi": "\"\"\"Controla l'altaveu integrat (nom\u00e9s V2). (altaveu)\"\"\"\n\ndef off() -> None:\n    \"\"\"Apaga l'altaveu.\n\nExample: ``speaker.off()``\n\nThis does not disable sound output to an edge connector pin.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Enc\u00e9n l'altaveu.\n\nExample: ``speaker.on()``\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"Comunica amb dispositius mitjan\u00e7ant el bus d'interf\u00edcie perif\u00e8rica s\u00e8rie (SPI).\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom ..microbit import pin13, pin14, pin15, MicroBitDigitalPin\n\ndef init(baudrate: int=1000000, bits: int=8, mode: int=0, sclk: MicroBitDigitalPin=pin13, mosi: MicroBitDigitalPin=pin15, miso: MicroBitDigitalPin=pin14) -> None:\n    \"\"\"Inicialitzar la comunicaci\u00f3 SPI.\n\nExample: ``spi.init()``\n\nFor correct communication, the parameters have to be the same on both communicating devices.\n\n:param baudrate: (Velocitat de bauds) La velocitat de comunicaci\u00f3.\n:param bits: L'amplada en bits de cada transfer\u00e8ncia. Actualment nom\u00e9s ``bits=8`` \u00e9s acceptada . Tot i que aix\u00f2 pot canviar en el futur\n:param mode: Determina la combinaci\u00f3 de polaritat i fase del rellotge: `consulta la taula en l\u00ednia <https://microbit-micropython.readthedocs.io/en/v2-docs/spi.html#microbit.spi.init>`_.\n:param sclk: pin sclk (per defecte 13)\n:param mosi: mosi pin (per defecte 15)\n:param miso: miso pin (per defecte 14)\"\"\"\n    ...\n\ndef read(nbytes: int) -> bytes:\n    \"\"\"Llegeix bytes (llegeix)\n\nExample: ``spi.read(64)``\n\n:param nbytes: Nombre m\u00e0xim de bytes per llegir.\n:return: The bytes read.\"\"\"\n    ...\n\ndef write(buffer: ReadableBuffer) -> None:\n    \"\"\"Escriu bytes al bus. (escriu)\n\nExample: ``spi.write(bytes([1, 2, 3]))``\n\n:param buffer: (mem\u00f2ria interm\u00e8dia) Una mem\u00f2ria interm\u00e8dia per a llegir dades.\"\"\"\n    ...\n\ndef write_readinto(out: WriteableBuffer, in_: ReadableBuffer) -> None:\n    \"\"\"Escriu la mem\u00f2ria interm\u00e8dia ``out`` al bus i llegeix qualsevol resposta a la mem\u00f2ria interm\u00e8dia ``in_``.\n\nExample: ``spi.write_readinto(out_buffer, in_buffer)``\n\nThe length of the buffers should be the same. The buffers can be the same object.\n\n:param out: La mem\u00f2ria interm\u00e8dia per a escriure qualsevol resposta.\n:param in_: La mem\u00f2ria interm\u00e8dia per a llegir dades.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"Comunica amb un dispositiu mitjan\u00e7ant una interf\u00edcie s\u00e8rie.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom ..microbit import MicroBitDigitalPin\nfrom typing import Optional, Union\nODD: int\n\"\"\"Paritat senar (senar)\"\"\"\nEVEN: int\n\"\"\"Paritat parella (parell)\"\"\"\n\ndef init(baudrate: int=9600, bits: int=8, parity: Optional[int]=None, stop: int=1, tx: Optional[MicroBitDigitalPin]=None, rx: Optional[MicroBitDigitalPin]=None) -> None:\n    \"\"\"Inicialitzar la comunicaci\u00f3 en s\u00e8rie.\n\nExample: ``uart.init(115200, tx=pin0, rx=pin1)``\n\n:param baudrate: (Velocitat de bauds) La velocitat de comunicaci\u00f3.\n:param bits: La mida dels bytes que es transmeten. micro:bit nom\u00e9s n'admet 8.\n:param parity: (paritat) Com es verifica la paritat, ``None``, ``uart.ODD`` o ``uart.EVEN``.\n:param stop: (atura) El nombre de bits de parada ha de ser 1 per micro:bit.\n:param tx: Pin transmissor.\n:param rx: Receiving pin.\n\nInitializing the UART on external pins will cause the Python console on\nUSB to become unaccessible, as it uses the same hardware. To bring the\nconsole back you must reinitialize the UART without passing anything for\n``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\nthat calling ``uart.init(115200)`` is enough to restore the Python console.\n\nFor more details see `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/uart.html>`_.\"\"\"\n    ...\n\ndef any() -> bool:\n    \"\"\"Verifica si hi ha alguna data esperant.\n\nExample: ``uart.any()``\n\n:return: ``True`` if any data is waiting, else ``False``.\"\"\"\n    ...\n\ndef read(nbytes: Optional[int]=None) -> Optional[bytes]:\n    \"\"\"Llegeix bytes (llegeix)\n\nExample: ``uart.read()``\n\n:param nbytes: Si s'especifica ``nbytes``, llegeix com a m\u00e0xim tants bytes, en cas contrari llegeix tants bytes com sigui possible\n:return: A bytes object or ``None`` on timeout\"\"\"\n    ...\n\ndef readinto(buf: WriteableBuffer, nbytes: Optional[int]=None) -> Optional[int]:\n    \"\"\"Llegeix bytes al ``buf``.\n\nExample: ``uart.readinto(input_buffer)``\n\n:param buf: La mem\u00f2ria interm\u00e8dia a on escriure.\n:param nbytes: Si s'especifica ``nbytes``, llegeix com a m\u00e0xim aquests bytes, en cas contrari llegeix ``len(buf)`` bytes.\n:return: number of bytes read and stored into ``buf`` or ``None`` on timeout.\"\"\"\n    ...\n\ndef readline() -> Optional[bytes]:\n    \"\"\"Llegir una l\u00ednia que acaba en un car\u00e0cter de nova l\u00ednia.\n\nExample: ``uart.readline()``\n\n:return: The line read or ``None`` on timeout. The newline character is included in the returned bytes.\"\"\"\n    ...\n\ndef write(buf: Union[bytes, str]) -> Optional[int]:\n    \"\"\"Escriu una mem\u00f2ria interm\u00e8dia al bus (escriu)\n\nExample: ``uart.write('hello world')``\n\n:param buf: Un objecte bytes o una cadena.\n:return: The number of bytes written, or ``None`` on timeout.\n\nExamples::\n\n    uart.write('hello world')\n    uart.write(b'hello world')\n    uart.write(bytes([1, 2, 3]))\"\"\"\n    ...",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Optional,\n    Reversible,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n)\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}