{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]\n    ) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "",
    "/typeshed/stdlib/array.pyi": "from typing import Generic, Iterable, MutableSequence, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode]\n\n_T = TypeVar(\"_T\", int, float)\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(\n        self: array[int],\n        typecode: _IntTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[float],\n        typecode: _FloatTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...\n    ) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n\nArrayType = array\n",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __slots__: str | Iterable[str]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls: Type[_T]) -> _T: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> str | Tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __name__: str\n    __qualname__: str\n    __text_signature__: str | None\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], dict: dict[str, Any], **kwds: Any\n    ) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: Type[_TT],\n        name: str,\n        bases: Tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwds: Any,\n    ) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> list[_TT]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(\n        metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any\n    ) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.UnionType: ...\n        def __ror__(self, t: Any) -> types.UnionType: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(\n        cls: Type[_T],\n        x: str | bytes | SupportsInt | SupportsIndex | _SupportsTrunc = ...,\n    ) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], x: str | bytes | bytearray, base: SupportsIndex\n    ) -> _T: ...\n    def to_bytes(\n        self,\n        length: SupportsIndex,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls,\n        bytes: Iterable[SupportsIndex] | SupportsBytes,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n    @overload\n    def __pow__(\n        self, __x: int, __modulo: int | None = ...\n    ) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(\n        cls: Type[_T], x: SupportsFloat | SupportsIndex | str | bytes | bytearray = ...\n    ) -> _T: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], real: str | SupportsComplex | SupportsIndex | complex\n    ) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...\n    ) -> _T: ...\n    def count(\n        self,\n        x: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self,\n        __suffix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def index(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: str | None = ...) -> str: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    def rfind(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def rstrip(self, __chars: str | None = ...) -> str: ...\n    def split(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def startswith(\n        self,\n        __prefix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __chars: str | None = ...) -> str: ...\n    def upper(self) -> str: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: int | slice) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ByteString | memoryview]) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytes: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray:\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[_T_co | _T, ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(\n        self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n\n# Can we remove this?\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: dict[str, Any]\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls: type[Self]) -> Self: ...\n    @overload\n    def __new__(cls: type[Self], __iterable: Iterable[_T_co]) -> Self: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(\n        self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(\n        self: list[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n    ) -> None: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, x: list[_T]) -> list[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: list[_T]) -> bool: ...\n    def __ge__(self, x: list[_T]) -> bool: ...\n    def __lt__(self, x: list[_T]) -> bool: ...\n    def __le__(self, x: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(\n        self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(\n        cls, __iterable: Iterable[_T], __value: None = ...\n    ) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(\n        self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> _T | _VT: ...\n\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exec(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(\n        self, __function: Callable[[_T], Any], __iterable: Iterable[_T]\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\n@overload\ndef getattr(__o: object, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: object, name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n    def issubclass(\n        __cls: type,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n\nelse:\n    def isinstance(\n        __obj: object, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef max(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef max(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef min(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef min(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIO: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes) -> int: ...\ndef print(\n    *values: object,\n    sep: str | None = ...,\n    end: str | None = ...,\n    file: SupportsWrite[str] | None = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(\n        base: int, exp: int, mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n) -> list[SupportsLessThanT]: ...\n@overload\ndef sorted(\n    __iterable: Iterable[_T],\n    *,\n    key: Callable[[_T], SupportsLessThan],\n    reverse: bool = ...,\n) -> list[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> _T | _S: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> _T | _S: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]\n    ) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Mapping[str, Any] | None = ...,\n    locals: Mapping[str, Any] | None = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(\n        self, *args: object, name: str | None = ..., path: str | None = ...\n    ) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass NotImplementedError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\n",
    "/typeshed/stdlib/errno.pyi": "from typing import Mapping\n\nerrorcode: Mapping[int, str]\n\nEACCES: int\nEADDRINUSE: int\nEAGAIN: int\nEALREADY: int\nEBADF: int\nECONNABORTED: int\nECONNREFUSED: int\nECONNRESET: int\nEEXIST: int\nEHOSTUNREACH: int\nEINPROGRESS: int\nEINVAL: int\nEIO: int\nEISDIR: int\nENOBUFS: int\nENODEV: int\nENOENT: int\nENOMEM: int\nENOTCONN: int\nEOPNOTSUPP: int\nEPERM: int\nETIMEDOUT: int\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Contr\u00f4ler le ramasse-miettes\"\"\"\nfrom typing import overload\n\ndef enable() -> None:\n    \"\"\"Active la collecte automatique du ramasse-miettes.\"\"\"\n    ...\n\ndef disable() -> None:\n    \"\"\"D\u00e9sactive la collecte automatique du ramasse-miettes.\n\nHeap memory can still be allocated,\nand garbage collection can still be initiated manually using ``gc.collect``.\"\"\"\n\ndef collect() -> None:\n    \"\"\"Ex\u00e9cute une collecte avec le ramasse-miettes\"\"\"\n    ...\n\ndef mem_alloc() -> int:\n    \"\"\"Obtenir le nombre d'octets allou\u00e9s pour le tas en RAM\n\n:return: The number of bytes allocated.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\ndef mem_free() -> int:\n    \"\"\"Obtenir le nombre d'octets disponibles pour le tas en RAM, ou -1 si ce nombre est inconnu.\n\n:return: The number of bytes free.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\n@overload\ndef threshold() -> int:\n    \"\"\"Demander le seuil d'allocation suppl\u00e9mentaire GC.\n\n:return: The GC allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\"\"\"\n    ...\n\n@overload\ndef threshold(amount: int) -> None:\n    \"\"\"Fixer le seuil d'allocation suppl\u00e9mentaire GC.\n\nNormally, a collection is triggered only when a new allocation\ncannot be satisfied, i.e. on an  out-of-memory (OOM) condition.\nIf this function is called, in addition to OOM, a collection\nwill be triggered each time after ``amount`` bytes have been\nallocated (in total, since the previous time such an amount of bytes\nhave been allocated). ``amount`` is usually specified as less than the\nfull heap size, with the intention to trigger a collection earlier than when the\nheap becomes exhausted, and in the hope that an early collection will prevent\nexcessive memory fragmentation. This is a heuristic measure, the effect\nof which will vary from application to application, as well as\nthe optimal value of the ``amount`` parameter.\n\nA value of -1 means a disabled allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\n\n:param amount: Le nombre d'octets apr\u00e8s lequel un passage du ramasse-miettes doit \u00eatre d\u00e9clench\u00e9.\"\"\"\n    ...",
    "/typeshed/stdlib/log.pyi": "\"\"\"Journalisez des donn\u00e9es sur votre micro:bit V2.\"\"\"\nfrom typing import Literal, Mapping, Optional, Union, overload\nMILLISECONDS = 1\n\"\"\"Format d'horodatage en millisecondes.\"\"\"\nSECONDS = 10\n\"\"\"Format d'horodatage en secondes.\"\"\"\nMINUTES = 600\n\"\"\"Format d'horodatage en minutes.\"\"\"\nHOURS = 36000\n\"\"\"Format d'horodatage en heures.\"\"\"\nDAYS = 864000\n\"\"\"Format d'horodatage en jours.\"\"\"\n\ndef set_labels(*labels: str, timestamp: Optional[Literal[1, 10, 36000, 864000]]=SECONDS) -> None:\n    \"\"\"D\u00e9finir l'en-t\u00eate du fichier journal\n\nExample: ``log.set_labels('X', 'Y', 'Z', timestamp=log.MINUTES)``\n\nIdeally this function should be called a single time, before any data is\nlogged, to configure the data table header once.\n\nIf a log file already exists when the program starts, or if this function\nis called multiple times, it will check the labels already defined in the\nlog file. If this function call contains any new labels not already\npresent, it will generate a new header row with the additional columns.\n\nBy default the first column contains a timestamp for each row. The time\nunit can be selected via the timestamp argument.\n\n:param *labels: Un nombre quelconque d'arguments positionnels, chacun correspondant \u00e0 une entr\u00e9e dans l'en-t\u00eate du journal.\n:param timestamp: (horodatage) S\u00e9lectionnez l'unit\u00e9 d'horodatage qui sera automatiquement ajout\u00e9e comme premi\u00e8re colonne de chaque ligne. Les valeurs d'horodatage peuvent \u00eatre l'une des suivantes ``log.MILLISECONDS``, ``log.SECONDS``, ``log.MINUTES``, ``log.HOURS``, ``log.DAYS`` ou ``None`` pour d\u00e9sactiver l'horodatage. La valeur par d\u00e9faut est ``log.SECONDS``.\"\"\"\n    ...\n\n@overload\ndef add(data_dictionary: Optional[Mapping[str, Union[str, int, float]]]) -> None:\n    \"\"\"Ajoute une ligne de donn\u00e9es au journal en passant un dictionnaire d'en-t\u00eates et de valeurs.\n\nExample: ``log.add({ 'temp': temperature() })``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\n\n:param data_dictionary: Les donn\u00e9es \u00e0 enregistrer sous forme de dictionnaire avec une cl\u00e9 pour chaque en-t\u00eate.\"\"\"\n    ...\n\n@overload\ndef add(**kwargs: Union[str, int, float]) -> None:\n    \"\"\"Ajoute une ligne de donn\u00e9es au journal en utilisant des arguments nomm\u00e9s.\n\nExample: ``log.add(temp=temperature())``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\"\"\"\n    ...\n\ndef delete(full=False):\n    \"\"\"Supprime le contenu du journal, y compris les en-t\u00eates.\n\nExample: ``log.delete()``\n\nTo add the log headers again the ``set_labels`` function should to be called after this function.\n\nThere are two erase modes; \u201cfull\u201d completely removes the data from the physical storage,\nand \u201cfast\u201d invalidates the data without removing it.\n\n:param full: ``True`` s\u00e9lectionne un effacement \"complet\" et ``False`` s\u00e9lectionne la m\u00e9thode d'effacement \"rapide\".\"\"\"\n    ...\n\ndef set_mirroring(serial: bool):\n    \"\"\"Configurez la mise en miroir de l'activit\u00e9 d'enregistrement des donn\u00e9es sur la sortie s\u00e9rie.\n\nExample: ``log.set_mirroring(True)``\n\nSerial mirroring is disabled by default. When enabled, it will print to serial each row logged into the log file.\n\n:param serial: ``True`` active la mise en miroir des donn\u00e9es sur la sortie s\u00e9rie.\"\"\"\n    ...",
    "/typeshed/stdlib/love.pyi": "def badaboom() -> None: ...\n",
    "/typeshed/stdlib/machine.pyi": "\"\"\"Utilitaires bas niveau\"\"\"\nfrom typing import Any\nfrom .microbit import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"R\u00e9cup\u00e8re une cha\u00eene d'octets repr\u00e9sentant un identifiant unique d'une carte.\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"R\u00e9initialise l'appareil d'une mani\u00e8re similaire \u00e0 la pression sur le bouton RESET externe.\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"R\u00e9cup\u00e8re la fr\u00e9quence du CPU en hertz.\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"D\u00e9sactiver les demandes d'interruption.\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"R\u00e9activer les demandes d'interruption.\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: La valeur qui a \u00e9t\u00e9 renvoy\u00e9e par l'appel le plus r\u00e9cent \u00e0 la fonction ``disable_irq``.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Chronom\u00e9trer une impulsion sur une broche.\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: (broche) La broche \u00e0 utiliser\n:param pulse_level: 0 pour chronom\u00e9trer une impulsion basse ou 1 pour chronom\u00e9trer une impulsion haute.\n:param timeout_us: Un d\u00e9lai d'attente en microseconde\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"La classe pour les vues m\u00e9moire ``mem8``, ``mem16`` et ``mem32``.\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Acc\u00e9der \u00e0 une valeur dans la m\u00e9moire.\n\n:param address: L'adresse en m\u00e9moire.\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"\u00c9crire une valeur \u00e0 une adresse donn\u00e9e.\n\n:param address: L'adresse en m\u00e9moire.\n:param value: La valeur enti\u00e8re \u00e0 \u00e9crire.\"\"\"\n        ...\nmem8: mem\n\"\"\"Vue de la m\u00e9moire au format 8-bit (octet).\"\"\"\nmem16: mem\n\"\"\"Vue de la m\u00e9moire au format 16-bit.\"\"\"\nmem32: mem\n\"\"\"Vue de la m\u00e9moire au format 32-bit.\"\"\"",
    "/typeshed/stdlib/math.pyi": "\"\"\"Fonctions math\u00e9matiques.\"\"\"\nfrom typing import Tuple\n\ndef acos(x: float) -> float:\n    \"\"\"Calculer le cosinus invers\u00e9.\n\nExample: ``math.acos(1)``\n\n:param x: Un nombre\n:return: The inverse cosine of ``x``\"\"\"\n    ...\n\ndef asin(x: float) -> float:\n    \"\"\"Calculer le sinus invers\u00e9.\n\nExample: ``math.asin(0)``\n\n:param x: Un nombre\n:return: The inverse sine of ``x``\"\"\"\n    ...\n\ndef atan(x: float) -> float:\n    \"\"\"Calculer la tangente inverse.\n\nExample: ``math.atan(0)``\n\n:param x: Un nombre\n:return: The inverse tangent of ``x``\"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float:\n    \"\"\"Calculer la valeur principale de la tangente inverse de ``y/x``.\n\nExample: ``math.atan2(0, -1)``\n\n:param y: Un nombre\n:param x: Un nombre\n:return: The principal value of the inverse tangent of ``y/x``\"\"\"\n    ...\n\ndef ceil(x: float) -> float:\n    \"\"\"Arrondir un nombre vers l'infini positif.\n\nExample: ``math.ceil(0.1)``\n\n:param x: Un nombre\n:return: ``x`` rounded towards positive infinity.\"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float:\n    \"\"\"Calculer ``x`` avec le signe de ``y``.\n\nExample: ``math.copysign(1, -1)``\n\n:param x: Un nombre\n:param y: La source du signe pour la valeur de retour\n:return: ``x`` with the sign of ``y``\"\"\"\n    ...\n\ndef cos(x: float) -> float:\n    \"\"\"Calculer le cosinus de ``x``.\n\nExample: ``math.cos(0)``\n\n:param x: Un nombre\n:return: The cosine of ``x``\"\"\"\n    ...\n\ndef degrees(x: float) -> float:\n    \"\"\"Convertir les radians en degr\u00e9s. (degr\u00e9s)\n\nExample: ``math.degrees(2 * math.pi)``\n\n:param x: Une valeur en radians\n:return: The value converted to degrees\"\"\"\n    ...\n\ndef exp(x: float) -> float:\n    \"\"\"Calculer l'exponentiel de ``x``.\n\nExample: ``math.exp(1)``\n\n:param x: Un nombre\n:return: The exponential of ``x``.\"\"\"\n    ...\n\ndef fabs(x: float) -> float:\n    \"\"\"Renvoie la valeur absolue de ``x``.\n\nExample: ``math.fabs(-0.1)``\n\n:param x: Un nombre\n:return: The absolute value of ``x``\"\"\"\n    ...\n\ndef floor(x: float) -> int:\n    \"\"\"Arrondir un nombre vers l'infini n\u00e9gatif.\n\nExample: ``math.floor(0.9)``\n\n:param x: Un nombre\n:return: ``x`` rounded towards negative infinity.\"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float:\n    \"\"\"Calculer le reste de ``x/y``.\n\nExample: ``math.fmod(10, 3)``\n\n:param x: Le num\u00e9rateur\n:param y: Le d\u00e9nominateur\"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]:\n    \"\"\"D\u00e9compose un nombre \u00e0 virgule flottante en sa mantisse et son exposant.\n\nExample: ``mantissa, exponent = math.frexp(2)``\n\nThe returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\nexactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\nthe relation ``0.5 <= abs(m) < 1`` holds.\n\n:param x: Un nombre \u00e0 virgule flottante\n:return: A tuple of length two containing its mantissa then exponent\"\"\"\n    ...\n\ndef isfinite(x: float) -> bool:\n    \"\"\"V\u00e9rifier si une valeur est finie.\n\nExample: ``math.isfinite(float('inf'))``\n\n:param x: Un nombre.\n:return: ``True`` if ``x`` is finite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isinf(x: float) -> bool:\n    \"\"\"V\u00e9rifie si une valeur est infinie.\n\nExample: ``math.isinf(float('-inf'))``\n\n:param x: Un nombre.\n:return: ``True`` if ``x`` is infinite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isnan(x: float) -> bool:\n    \"\"\"V\u00e9rifie si une valeur n'est pas un nombre (NaN).\n\nExample: ``math.isnan(float('nan'))``\n\n:param x: Un nombre\n:return: ``True`` if ``x`` is not-a-number (NaN), ``False`` otherwise.\"\"\"\n    ...\n\ndef ldexp(x: float, exp: int) -> float:\n    \"\"\"Calculer ``x * (2**exp)``.\n\nExample: ``math.ldexp(0.5, 2)``\n\n:param x: Un nombre\n:param exp: Exposant entier\n:return: ``x * (2**exp)``\"\"\"\n    ...\n\ndef log(x: float, base: float=e) -> float:\n    \"\"\"Calculer le logarithme de ``x`` \u00e0 la base donn\u00e9e (logarithme naturel par d\u00e9faut).\n\nExample: ``math.log(math.e)``\n\nWith one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as ``log(x)/log(base)``.\n\n:param x: Un nombre\n:param base: La base \u00e0 utiliser\n:return: The natural logarithm of ``x``\"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]:\n    \"\"\"Calculer les parties fractionnelles et int\u00e9grales de ``x``.\n\nExample: ``fractional, integral = math.modf(1.5)``\n\n:param x: Un nombre\n:return: A tuple of two floats representing the fractional then integral parts of ``x``.\n\nBoth the fractional and integral values have the same sign as ``x``.\"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float:\n    \"\"\"Renvoie ``x`` \u00e0 la puissance ``y``.\n\nExample: ``math.pow(4, 0.5)``\n\n:param x: Un nombre\n:param y: L'exposant\n:return: ``x`` to the power of ``y``\"\"\"\n    ...\n\ndef radians(x: float) -> float:\n    \"\"\"Convertir les degr\u00e9s en radians.\n\nExample: ``math.radians(360)``\n\n:param x: Une valeur en degr\u00e9s\n:return: The value converted to radians\"\"\"\n    ...\n\ndef sin(x: float) -> float:\n    \"\"\"Calculer le sinus de ``x``.\n\nExample: ``math.sin(math.pi/2)``\n\n:param x: Un nombre\n:return: The sine of ``x``\"\"\"\n    ...\n\ndef sqrt(x: float) -> float:\n    \"\"\"Calculer la racine carr\u00e9e de ``x``.\n\nExample: ``math.sqrt(4)``\n\n:param x: Un nombre\n:return: The square root of ``x``\"\"\"\n    ...\n\ndef tan(x: float) -> float:\n    \"\"\"Calculer la tangente de ``x``.\n\nExample: ``math.tan(0)``\n\n:param x: Un nombre\n:return: The tangent of ``x``.\"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\"Arrondir un nombre vers 0.\n\nExample: ``math.trunc(-0.9)``\n\n:param x: Un nombre\n:return: ``x`` rounded towards zero.\"\"\"\n    ...\ne: float\n\"\"\"Base du logarithme naturel\"\"\"\npi: float\n\"\"\"Le ratio entre la circonf\u00e9rence d'un cercle et son diam\u00e8tre\"\"\"",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"Les coulisses de MicroPython.\"\"\"\nfrom typing import Any, TypeVar, overload\n_T = TypeVar('_T')\n\ndef const(expr: _T) -> _T:\n    \"\"\"Utilis\u00e9 pour d\u00e9clarer que l'expression est une constante afin que le compilateur puisse\nl'optimiser.\n\nThe use of this function should be as follows::\n\n    from micropython import const\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\nConstants declared this way are still accessible as global variables from\noutside the module they are declared in. On the other hand, if a constant\nbegins with an underscore then it is hidden, it is not available as a\nglobal variable, and does not take up any memory during execution.\n\n:param expr: Une expression constante.\"\"\"\n    ...\n\n@overload\ndef opt_level() -> int:\n    \"\"\"R\u00e9cup\u00e8re le niveau d'optimisation actuel pour la compilation des scripts.\n\nExample: ``micropython.opt_level()``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\n:return: An integer representing the current level.\"\"\"\n    ...\n\n@overload\ndef opt_level(level: int) -> None:\n    \"\"\"D\u00e9finir le niveau d'optimisation pour la compilation ult\u00e9rieure des scripts.\n\nExample: ``micropython.opt_level(1)``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\nThe default optimisation level is usually level 0.\n\n:param level: Un entier indiquant le niveau d'optimisation.\"\"\"\n    ...\n\ndef mem_info(verbose: Any=None) -> None:\n    \"\"\"Afficher des informations sur la m\u00e9moire actuellement utilis\u00e9e.\n\nExample: ``micropython.mem_info()``\n\n:param verbose: Si l'argument ``verbose`` est sp\u00e9cifi\u00e9, des informations suppl\u00e9mentaires seront affich\u00e9es.\"\"\"\n    ...\n\ndef qstr_info(verbose: Any=None) -> None:\n    \"\"\"Affiche des informations sur les cha\u00eenes de caract\u00e8res internalis\u00e9es.\n\nExample: ``micropython.qstr_info()``\n\n:param verbose: Si l'argument ``verbose`` est sp\u00e9cifi\u00e9, des informations suppl\u00e9mentaires seront affich\u00e9es.\n\nThe information that is printed is implementation dependent, but currently\nincludes the number of interned strings and the amount of RAM they use.  In\nverbose mode it prints out the names of all RAM-interned strings.\"\"\"\n    ...\n\ndef stack_use() -> int:\n    \"\"\"Renvoie un nombre entier repr\u00e9sentant la taille de la pile en cours d'utilisation.\n\nExample: ``micropython.stack_use()``\n\nThe absolute value of this is not particularly useful, rather it\nshould be used to compute differences in stack usage at different points.\n\n:return: An integer representing current stack use.\"\"\"\n    ...\n\ndef heap_lock() -> None:\n    \"\"\"Verrouille le tas (heap).\n\nExample: ``micropython.heap_lock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef heap_unlock() -> None:\n    \"\"\"D\u00e9verrouille le tas (heap).\n\nExample: ``micropython.heap_unlock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"D\u00e9finir le caract\u00e8re qui l\u00e8vera une exception ``KeyboardInterrupt``.\n\nExample: ``micropython.kbd_intr(-1)``\n\n:param chr: Code de caract\u00e8re pour g\u00e9n\u00e9rer l'interruption ou -1 pour d\u00e9sactiver la capture de Ctrl-C.\n\nBy default this is set to 3 during script execution, corresponding to Ctrl-C.\nPassing -1 to this function will disable capture of Ctrl-C, and passing 3\nwill restore it.\n\nThis function can be used to prevent the capturing of Ctrl-C on the\nincoming stream of characters that is usually used for the REPL, in case\nthat stream is used for other purposes.\"\"\"\n    ...",
    "/typeshed/stdlib/music.pyi": "\"\"\"Cr\u00e9er et jouer des m\u00e9lodies.\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .microbit import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"M\u00e9lodie : l'ouverture de la 5e symphonie en do mineur de Beethoven.\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"M\u00e9lodie : le fragment d'ouverture du classique de ragtime \"The Entertainer\" de Scott Joplin.\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"M\u00e9lodie : le pr\u00e9lude et fugue en ut majeur (BWV 846) de Jean-S\u00e9bastien Bach.\"\"\"\nODE: Tuple[str, ...]\n\"\"\"M\u00e9lodie : le th\u00e8me de l'\"Ode \u00e0 la joie\" de la 9e symphonie en r\u00e9 mineur de Beethoven.\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"M\u00e9lodie : le th\u00e8me de Nyan Cat (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"M\u00e9lodie : son qui ressemble \u00e0 une sonnerie de t\u00e9l\u00e9phone mobile.\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"M\u00e9lodie : une ligne de basse funky pour les agents secrets et les cerveaux criminels.\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"M\u00e9lodie : une walking bass blues de boogie-woogie \u00e0 12 mesures.\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"M\u00e9lodie : \u00ab Joyeux anniversaire\u2026\u00bb\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"M\u00e9lodie : la marche nuptiale de l'op\u00e9ra \"Lohengrin\" de Wagner.\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"M\u00e9lodie : la \"marche fun\u00e8bre \" aussi connue sous le nom de Sonate pour piano n\u00b0 2 en B\u266d mineur, opus 35 de Fr\u00e9d\u00e9ric Chopin.\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"M\u00e9lodie : un extrait amusant qui signifie qu'une blague a \u00e9t\u00e9 faite.\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"M\u00e9lodie : La marche \"Liberty Bell\" de John Philip Sousa, alias le th\u00e8me du \"Monty Python's Flying Circus\" (qui a donn\u00e9 son nom au langage de programmation Python).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"M\u00e9lodie\\xa0: entr\u00e9e d'un m\u00e9chant \u00e0 l'\u00e9poque des films muets.\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"M\u00e9lodie : sc\u00e8ne de poursuite \u00e0 l'\u00e9poque du film muet.\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"M\u00e9lodie : un signal court pour indiquer que quelque chose s'est produit.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"M\u00e9lodie : un trombone tr\u00e8s triste.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"M\u00e9lodie\\xa0: pour une utilisation dans un jeu, indiquant un mouvement vers le haut.\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"M\u00e9lodie\\xa0: pour une utilisation dans un jeu, indiquant un mouvement vers le bas.\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"M\u00e9lodie : une fanfare pour indiquer un succ\u00e8s d\u00e9bloqu\u00e9.\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"M\u00e9lodie : une fanfare triste pour indiquer un succ\u00e8s manqu\u00e9.\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"D\u00e9finir le tempo approximatif pour la lecture.\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: Le nombre de ticks constituant un battement.\n:param bpm: Un entier d\u00e9terminant le nombre de battements par minute.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"R\u00e9cup\u00e9rer le tempo actuel sous la forme d'un tuple d'entiers : ``(ticks, bpm)``.\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Jouer de la musique.\n\nExample: ``music.play(music.NYAN)``\n\n:param music: musique sp\u00e9cifi\u00e9e dans `une notation sp\u00e9ciale <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: (broche) la broche de sortie \u00e0 utiliser avec un haut-parleur externe (par d\u00e9faut ``pin0``), ``None`` pour aucun son.\n:param wait: Si ``wait`` est d\u00e9fini \u00e0 ``True``, cette fonction est bloquante.\n:param loop: Si ``loop`` est d\u00e9fini \u00e0 ``True``, la m\u00e9lodie se r\u00e9p\u00e8te jusqu'\u00e0 ce que ``stop`` soit appel\u00e9, ou que l'appel bloquant soit interrompu.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Jouer une note. (tangage)\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: (fr\u00e9quence) Une fr\u00e9quence enti\u00e8re\n:param duration: Une dur\u00e9e en milliseconde. Si la valeur est n\u00e9gative alors le son sera continu jusqu'au prochain appel, ou jusqu'\u00e0 un appel \u00e0 ``stop``.\n:param pin: (broche) Broche de sortie optionnelle (par d\u00e9faut ``pin0``).\n:param wait: Si ``wait`` est d\u00e9fini \u00e0 ``True``, cette fonction est bloquante.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Met fin \u00e0 toute lecture de musique sur le haut-parleur int\u00e9gr\u00e9 et \u00e0 tout son en sortie sur la broche.\n\nExample: ``music.stop()``\n\n:param pin: (broche) Un argument optionnel peut \u00eatre sp\u00e9cifi\u00e9 pour indiquer une broche, par exemple ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"R\u00e9initialiser les ticks, bpm, dur\u00e9e et octave \u00e0 leurs valeurs par d\u00e9faut.\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Bandes LED RGB et RGBW individuellement adressables.\"\"\"\nfrom .microbit import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"Initialiser une nouvelle bande de LEDs neopixel contr\u00f4l\u00e9e via une broche.\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: (broche) La broche qui contr\u00f4le la bande neopixel.\n:param n: Le nombre de neopixels sur la bande.\n:param bpp: Octets par pixel. Pour le support du neopixel RGBW, passez 4 plut\u00f4t que la valeur par d\u00e9faut 3 pour RGB et GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Effacer tous les pixels.\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"Afficher les pixels.\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Afficher les pixels (micro:bit V2 uniquement).\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Colorer tous les pixels d'une valeur RGB/RGBW donn\u00e9e (micro:bit V2 uniquement).\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: Un tuple de la m\u00eame longueur que le nombre d'octets par pixel (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"D\u00e9finit une couleur de pixel.\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: Le num\u00e9ro du pixel\n:param value: La couleur.\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"R\u00e9cup\u00e8re la couleur d'un pixel\n\nExample: ``r, g, b = np[0]``\n\n:param key: Le num\u00e9ro du pixel\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"R\u00e9cup\u00e8re la longueur de cette bande de pixels.\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "\"\"\"Acc\u00e9der au syst\u00e8me de fichiers.\"\"\"\nfrom typing import Tuple\nfrom typing import List\n\ndef listdir() -> List[str]:\n    \"\"\"Lister les fichiers.\n\nExample: ``os.listdir()``\n\n:return: A list of the names of all the files contained within the local\npersistent on-device file system.\"\"\"\n    ...\n\ndef remove(filename: str) -> None:\n    \"\"\"Supprimer (effacer) un fichier.\n\nExample: ``os.remove('data.txt')``\n\n:param filename: Le fichier \u00e0 effacer.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n    ...\n\ndef size(filename: str) -> int:\n    \"\"\"Retourne la taille d'un fichier.\n\nExample: ``os.size('data.txt')``\n\n:param filename: Le fichier\n:return: The size in bytes.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n\nclass uname_result(Tuple[str, str, str, str, str]):\n    \"\"\"R\u00e9sultat de ``os.uname()``\"\"\"\n    sysname: str\n    \"\"\"Nom du syst\u00e8me d'exploitation.\"\"\"\n    nodename: str\n    \"\"\"Nom de la machine sur le r\u00e9seau (selon impl\u00e9mentation).\"\"\"\n    release: str\n    \"\"\"La release du syst\u00e8me d'exploitation\"\"\"\n    version: str\n    \"\"\"Version du syst\u00e8me d'exploitation\"\"\"\n    machine: str\n    \"\"\"Identifiant mat\u00e9riel.\"\"\"\n\ndef uname() -> uname_result:\n    \"\"\"Retourne les informations identifiant le syst\u00e8me d'exploitation actuel.\n\nExample: ``os.uname()``\n\nThe return value is an object with five attributes:\n\n- ``sysname`` - operating system name\n- ``nodename`` - name of machine on network (implementation-defined)\n- ``release`` - operating system release\n- ``version`` - operating system version\n- ``machine`` - hardware identifier\n\nThere is no underlying operating system in MicroPython. As a result the\ninformation returned by the ``uname`` function is mostly useful for\nversioning details.\"\"\"\n    ...",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "\"\"\"Communiquer entre micro:bits avec la radio int\u00e9gr\u00e9e.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom typing import Optional, Tuple\nRATE_1MBIT: int\n\"\"\"Constante utilis\u00e9e pour indiquer un d\u00e9bit de 1 MBit par seconde.\"\"\"\nRATE_2MBIT: int\n\"\"\"Constante utilis\u00e9e pour indiquer un d\u00e9bit de 2 MBit par seconde.\"\"\"\n\ndef on() -> None:\n    \"\"\"Allume la radio.\n\nExample: ``radio.on()``\n\nThis needs to be explicitly called since the radio draws power and takes\nup memory that you may otherwise need.\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"D\u00e9sactive la radio, \u00e9conomisant ainsi de l'\u00e9nergie et de la m\u00e9moire.\n\nExample: ``radio.off()``\"\"\"\n    ...\n\ndef config(length: int=32, queue: int=3, channel: int=7, power: int=6, address: int=1969383796, group: int=0, data_rate: int=RATE_1MBIT) -> None:\n    \"\"\"Configure la radio.\n\nExample: ``radio.config(group=42)``\n\nThe default configuration is suitable for most use.\n\n:param length: (par d\u00e9faut=32) d\u00e9finit la longueur maximale en octets d'un message envoy\u00e9 via la radio.\nIl peut faire jusqu'\u00e0 251 octets de long (254 - 3 octets pour S0, LENGTH et pr\u00e9ambule S1).\n:param queue: (par d\u00e9faut=3) sp\u00e9cifie le nombre de messages qui peuvent \u00eatre stock\u00e9s dans la file d'attente des messages entrants.\nS'il n'y a plus de place dans la file d'attente des messages entrants, alors le message entrant est abandonn\u00e9.\n:param channel: (par d\u00e9faut=7) une valeur enti\u00e8re comprise entre 0 et 83 (y compris) qui d\u00e9finit un \u00ab canal \u00bb arbitraire sur lequel la radio est r\u00e9gl\u00e9e.\nLes messages seront envoy\u00e9s via ce canal et seuls les messages re\u00e7us via ce canal seront plac\u00e9s dans la file d'attente des messages entrants. Chaque incr\u00e9ment est de 1 MHz de largeur, bas\u00e9 \u00e0 2400 MHz.\n:param power: (par d\u00e9faut=6) est une valeur enti\u00e8re comprise entre 0 et 7 (y compris) pour indiquer la force du signal utilis\u00e9 lors de la diffusion d'un message.\nPlus la valeur est \u00e9lev\u00e9e, plus le signal est fort, mais plus les besoins en alimentation sont \u00e9lev\u00e9s. La num\u00e9rotation se traduit par des positions dans la liste suivante de valeurs en dBm (d\u00e9cibel milliwatt) : -30, -20, -16, -12, -8, -4, 0, 4.\n:param address: (par d\u00e9faut=0x75626974) un nom arbitraire, exprim\u00e9 sous la forme d'une adresse 32-bit, utilis\u00e9 pour filtrer au niveau mat\u00e9riel les paquet entrants, seuls les paquets correspondant \u00e0 l'adresse d\u00e9finie seront conserv\u00e9s.\nLa valeur par d\u00e9faut utilis\u00e9e par d'autres plateformes li\u00e9es au micro:bit est celle indiqu\u00e9e ici.\n:param group: (par d\u00e9faut=0) une valeur de 8 bits (0-255) utilis\u00e9e avec ``address`` lors du filtrage des messages.\nConceptuellement, \"adress\" est comme l'adresse d'une maison ou d'un bureau, et \"group\" est comme la personne \u00e0 laquelle vous voulez envoyer votre message.\n:param data_rate: (par d\u00e9faut=``radio.RATE_1MBIT``) indique la vitesse \u00e0 laquelle le d\u00e9bit de donn\u00e9es a lieu.\nPeut \u00eatre une des constantes suivantes d\u00e9finies dans le module ``radio``\\xa0: ``RATE_250KBIT``, ``RATE_1MBIT`` ou ``RATE_2MBIT``.\n\nIf ``config`` is not called then the defaults described above are assumed.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"R\u00e9initialiser les param\u00e8tres \u00e0 leurs valeurs par d\u00e9faut.\n\nExample: ``radio.reset()``\n\nThe defaults as as per the ``config`` function above.\"\"\"\n    ...\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Envoie un message contenant des octets.\n\nExample: ``radio.send_bytes(b'hello')``\n\n:param message: Les octets \u00e0 envoyer.\"\"\"\n    ...\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Recevoir le message entrant suivant dans la file d'attente des messages.\n\nExample: ``radio.receive_bytes()``\n\n:return: The message bytes if any, otherwise ``None``.\"\"\"\n    ...\n\ndef receive_bytes_into(buffer: WriteableBuffer) -> Optional[int]:\n    \"\"\"Copier le message entrant suivant de la file d'attente des messages vers un buffer.\n\nExample: ``radio.receive_bytes_info(buffer)``\n\n:param buffer: Le buffer cible. Le message est tronqu\u00e9 s'il est plus grand que le buffer.\n:return: ``None`` if there are no pending messages, otherwise it returns the length of the message (which might be more than the length of the buffer).\"\"\"\n    ...\n\ndef send(message: str) -> None:\n    \"\"\"Envoie un message avec une cha\u00eene de caract\u00e8res.\n\nExample: ``radio.send('hello')``\n\nThis is the equivalent of ``radio.send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\nprepended to the front (to make it compatible with other platforms that target the micro:bit).\n\n:param message: Le texte \u00e0 envoyer.\"\"\"\n    ...\n\ndef receive() -> Optional[str]:\n    \"\"\"Fonctionne exactement de la m\u00eame mani\u00e8re que ``receive_bytes`` mais retourne ce qui a \u00e9t\u00e9 envoy\u00e9.\n\nExample: ``radio.receive()``\n\nEquivalent to ``str(receive_bytes(), 'utf8')`` but with a check that the the first\nthree bytes are ``b'\\x01\\x00\\x01'`` (to make it compatible with other platforms that\nmay target the micro:bit).\n\n:return: The message with the prepended bytes stripped and converted to a string.\n\nA ``ValueError`` exception is raised if conversion to string fails.\"\"\"\n    ...\n\ndef receive_full() -> Optional[Tuple[bytes, int, int]]:\n    \"\"\"Retourne un tuple contenant trois valeurs qui repr\u00e9sentent le prochain message entrant dans la file d'attente.\n\nExample: ``radio.receive_full()``\n\nIf there are no pending messages then ``None`` is returned.\n\nThe three values in the tuple represent:\n\n- the next incoming message on the message queue as bytes.\n- the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n- a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\nFor example::\n\n    details = radio.receive_full()\n    if details:\n        msg, rssi, timestamp = details\n\nThis function is useful for providing information needed for triangulation\nand/or trilateration with other micro:bit devices.\n\n:return: ``None`` if there is no message, otherwise a tuple of length three with the bytes, strength and timestamp values.\"\"\"\n    ...",
    "/typeshed/stdlib/random.pyi": "\"\"\"G\u00e9n\u00e9rer des nombres al\u00e9atoires.\"\"\"\nfrom typing import TypeVar, Sequence, Union, overload\n\ndef getrandbits(n: int) -> int:\n    \"\"\"G\u00e9n\u00e9rer un entier avec ``n`` bits al\u00e9atoires.\n\nExample: ``random.getrandbits(1)``\n\n:param n: Une valeur comprise entre 1-30 (inclus).\"\"\"\n    ...\n\ndef seed(n: int) -> None:\n    \"\"\"Initialiser le g\u00e9n\u00e9rateur de nombres al\u00e9atoires.\n\nExample: ``random.seed(0)``\n\n:param n: La graine al\u00e9atoire\n\nThis will give you reproducibly deterministic randomness from a given starting\nstate (``n``).\"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int:\n    \"\"\"Choisir un entier al\u00e9atoire entre ``a`` et ``b`` inclus.\n\nExample: ``random.randint(0, 9)``\n\n:param a: Valeur de d\u00e9part pour l'intervalle (inclus)\n:param b: Valeur de fin pour l'intervalle (inclus)\n\nAlias for ``randrange(a, b + 1)``.\"\"\"\n    ...\n\n@overload\ndef randrange(stop: int) -> int:\n    \"\"\"Choisir un entier al\u00e9atoirement entre z\u00e9ro et ``stop`` (mais sans inclure ce dernier).\n\nExample: ``random.randrange(10)``\n\n:param stop: Valeur de fin pour l'intervalle (exclusif)\"\"\"\n    ...\n\n@overload\ndef randrange(start: int, stop: int, step: int=1) -> int:\n    \"\"\"Choisir un \u00e9l\u00e9ment s\u00e9lectionn\u00e9 al\u00e9atoirement dans ``range(start, stop, step)``.\n\nExample: ``random.randrange(0, 10)``\n\n:param start: Le d\u00e9but de la plage (inclus)\n:param stop: La fin de l'intervalle (exclusif)\n:param step: L'incr\u00e9ment.\"\"\"\n    ...\n_T = TypeVar('_T')\n\ndef choice(seq: Sequence[_T]) -> _T:\n    \"\"\"Choisir un \u00e9l\u00e9ment al\u00e9atoire dans la s\u00e9quence non vide ``seq``.\n\nExample: ``random.choice([Image.HAPPY, Image.SAD])``\n\n:param seq: Une s\u00e9quence.\n\nIf ``seq`` is  empty, raises ``IndexError``.\"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"G\u00e9n\u00e9rer un nombre al\u00e9atoire \u00e0 virgule flottante [0.0, 1.0).\n\nExample: ``random.random()``\n\n:return: The random floating point number\"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float:\n    \"\"\"Renvoie un nombre al\u00e9atoire \u00e0 virgule flottante entre ``a`` et ``b`` inclus.\n\nExample: ``random.uniform(0, 9)``\n\n:param a: Valeur de d\u00e9part pour l'intervalle (inclus)\n:param b: Valeur de fin pour l'intervalle (inclus)\"\"\"\n    ...",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Faites parler ou chanter le micro:bit, ainsi que d'autres sons li\u00e9s \u00e0 la parole.\"\"\"\nfrom typing import Optional\nfrom .microbit import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Traduire les mots anglais en phon\u00e8mes.\n\nExample: ``speech.translate('hello world')``\n\n:param words: Une cha\u00eene de caract\u00e8res de mots anglais.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Prononcer les phon\u00e8mes.\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: La cha\u00eene de phon\u00e8mes \u00e0 prononcer\n:param pitch: (tangage) Un nombre repr\u00e9sentant le ton de la voix\n:param speed: Un nombre repr\u00e9sentant la vitesse de la voix\n:param mouth: Un nombre repr\u00e9sentant la bouche de la voix\n:param throat: Un nombre repr\u00e9sentant la gorge de la voix\n:param pin: (broche) Argument optionnel pour sp\u00e9cifier la broche de sortie. Peut \u00eatre utilis\u00e9 pour remplacer la valeur par d\u00e9faut de ``pin0``.\nPour emp\u00eacher l'\u00e9mission d'un son via les broches, il est possible d'utiliser ``pin=None``. micro:bit V2 seulement.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Dire des mots anglais.\n\nExample: ``speech.say('hello world')``\n\n:param words: La cha\u00eene de mots \u00e0 dire.\n:param pitch: (tangage) Un nombre repr\u00e9sentant le ton de la voix\n:param speed: Un nombre repr\u00e9sentant la vitesse de la voix\n:param mouth: Un nombre repr\u00e9sentant la bouche de la voix\n:param throat: Un nombre repr\u00e9sentant la gorge de la voix\n:param pin: (broche) Argument optionnel pour sp\u00e9cifier la broche de sortie. Peut \u00eatre utilis\u00e9 pour remplacer la valeur par d\u00e9faut de ``pin0``.\nPour emp\u00eacher l'\u00e9mission d'un son via les broches, il est possible d'utiliser ``pin=None``. micro:bit V2 seulement.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Chanter des phon\u00e8mes.\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: La cha\u00eene de mots \u00e0 chanter.\n:param pitch: (tangage) Un nombre repr\u00e9sentant le ton de la voix\n:param speed: Un nombre repr\u00e9sentant la vitesse de la voix\n:param mouth: Un nombre repr\u00e9sentant la bouche de la voix\n:param throat: Un nombre repr\u00e9sentant la gorge de la voix\n:param pin: (broche) Argument optionnel pour sp\u00e9cifier la broche de sortie. Peut \u00eatre utilis\u00e9 pour remplacer la valeur par d\u00e9faut de ``pin0``.\nPour emp\u00eacher l'\u00e9mission d'un son via les broches, il est possible d'utiliser ``pin=None``. micro:bit V2 seulement.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "\"\"\"Rassembler et d\u00e9sassembler des types de donn\u00e9es primitives.\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom typing import Any, Tuple, Union\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"R\u00e9cup\u00e8re le nombre d'octets n\u00e9cessaires pour stocker le ``fmt`` donn\u00e9.\n\nExample: ``struct.calcsize('hf')``\n\n:param fmt: Une cha\u00eene de mise en forme.\n:return The number of bytes needed to store such a value.\"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"Rassembler les valeurs selon une cha\u00eene de mise en forme.\n\nExample: ``struct.pack('hf', 1, 3.1415)``\n\n:param fmt: La cha\u00eene de mise en forme.\n:param v1: La premi\u00e8re valeur.\n:param *vn: Les valeurs restantes.\n:return A bytes object encoding the values.\"\"\"\n    ...\n\ndef pack_into(fmt: str, buffer: WriteableBuffer, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"Rassembler les valeurs selon une cha\u00eene de format. (Rassembler dans)\n\nExample: ``struct.pack_info('hf', buffer, 1, 3.1415)``\n\n:param fmt: La cha\u00eene de format.\n:param buffer: Le tampon cible dans lequel \u00e9crire.\n:param offset: Le d\u00e9calage dans le tampon. Peut \u00eatre n\u00e9gatif pour compter \u00e0 partir de la fin du tampon.\n:param v1: La premi\u00e8re valeur.\n:param *vn: Les valeurs restantes.\"\"\"\n    ...\n\ndef unpack(fmt: str, data: ReadableBuffer) -> Tuple[Any, ...]:\n    \"\"\"D\u00e9compacter les donn\u00e9es selon une cha\u00eene de format.\n\nExample: ``v1, v2 = struct.unpack('hf', buffer)``\n\n:param fmt: La cha\u00eene de format.\n:param data: Les donn\u00e9es.\n:return: A tuple of the unpacked values.\"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: ReadableBuffer, offset: int=0) -> Tuple:\n    \"\"\"D\u00e9compacter les donn\u00e9es d'un tampon selon une cha\u00eene de format.\n\nExample: ``v1, v2 = struct.unpack_from('hf', buffer)``\n\n:param fmt: La cha\u00eene de format.\n:param buffer: Le tampon source \u00e0 partir duquel lire.\n:param offset: Le d\u00e9calage dans le tampon. Peut \u00eatre n\u00e9gatif pour compter \u00e0 partir de la fin du tampon.\n:return: A tuple of the unpacked values.\"\"\"\n    ...",
    "/typeshed/stdlib/sys.pyi": "\"\"\"Fonctions sp\u00e9cifiques au syst\u00e8me\"\"\"\nfrom typing import Any, Dict, List, NoReturn, TextIO, Tuple\n\ndef exit(retval: object=...) -> NoReturn:\n    \"\"\"Terminer le programme en cours avec un code de sortie donn\u00e9.\n\nExample: ``sys.exit(1)``\n\nThis function raises a ``SystemExit`` exception. If an argument is given, its\nvalue given as an argument to ``SystemExit``.\n\n:param retval: Le code de sortie ou le message.\"\"\"\n    ...\n\ndef print_exception(exc: Exception) -> None:\n    \"\"\"Imprime une exception avec une pile d'appels.\n\nExample: ``sys.print_exception(e)``\n\n:param exc: L'exception \u00e0 imprimer\n\nThis is simplified version of a function which appears in the\n``traceback`` module in CPython.\"\"\"\nargv: List[str]\n\"\"\"Une liste mutable d'arguments avec lesquels le programme courant a \u00e9t\u00e9 d\u00e9marr\u00e9.\"\"\"\nbyteorder: str\n\"\"\"L'ordre des octets du syst\u00e8me (``\"little\"`` ou ``\"big\"``).\"\"\"\n\nclass _implementation:\n    name: str\n    version: Tuple[int, int, int]\nimplementation: _implementation\n\"\"\"Objet avec des informations sur l'impl\u00e9mentation actuelle de Python.\n\nFor MicroPython, it has following attributes:\n\n- ``name`` - string \"micropython\"\n- ``version`` - tuple (major, minor, micro), e.g. (1, 7, 0)\n\nThis object is the recommended way to distinguish MicroPython from other\nPython implementations (note that it still may not exist in the very\nminimal ports).\n\nCPython mandates more attributes for this object, but the actual useful\nbare minimum is implemented in MicroPython.\n\"\"\"\nmaxsize: int\n\"\"\"\nValeur maximale qu'un entier natif peut stocker sur la plate-forme courante,\nou valeur maximale repr\u00e9sentable par le type entier de MicroPython, si elle est plus petite\nque la valeur maximale de la plate-forme (c'est le cas pour les portages MicroPython sans support\ndes entiers long).\n\nThis attribute is useful for detecting \"bitness\" of a platform (32-bit vs\n64-bit, etc.). It's recommended to not compare this attribute to some\nvalue directly, but instead count number of bits in it::\n\n    bits = 0\n    v = sys.maxsize\n    while v:\n        bits += 1\n        v >>= 1\n    if bits > 32:\n        # 64-bit (or more) platform\n        ...\n    else:\n        # 32-bit (or less) platform\n        # Note that on 32-bit platform, value of bits may be less than 32\n        # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n        # \"> 32\", \"> 64\" style of comparisons.\n\"\"\"\nmodules: Dict[str, Any]\n\"\"\"Dictionnaire des modules charg\u00e9s. \n\nOn some ports, it may not include builtin modules.\"\"\"\npath: List[str]\n\"\"\"Une liste mutable de r\u00e9pertoires dans lesquels rechercher des modules import\u00e9s.\"\"\"\nplatform: str\n\"\"\"La plate-forme sur laquelle MicroPython s'ex\u00e9cute. \n\nFor OS/RTOS ports, this is usually an identifier of the OS, e.g. ``\"linux\"``.\nFor baremetal ports it is an identifier of a board, e.g. ``\"pyboard\"`` for \nthe original MicroPython reference board. It thus can be used to\ndistinguish one board from another.\n\nIf you need to check whether your program runs on MicroPython (vs other\nPython implementation), use ``sys.implementation`` instead.\n\"\"\"\nversion: str\n\"\"\"Version du langage Python \u00e0 laquelle cette impl\u00e9mentation correspond, sous la forme d'une cha\u00eene de caract\u00e8res .\"\"\"\nversion_info: Tuple[int, int, int]\n\"\"\"Version du langage Python \u00e0 laquelle cette impl\u00e9mentation correspond, sous forme d'un tuple d'entiers.\n\nOnly the first three version numbers (major, minor, micro) are supported and\nthey can be referenced only by index, not by name.\n\"\"\"",
    "/typeshed/stdlib/this.pyi": "def authors() -> str: ...\n",
    "/typeshed/stdlib/time.pyi": "\"\"\"Mesurer le temps et ajouter des retards aux programmes.\"\"\"\nfrom typing import Union\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"Temporiser d'un certain nombre de secondes.\n\nExample: ``time.sleep(1)``\n\n:param seconds: Le nombre de secondes pendant lesquelles dormir.\nUtiliser un nombre \u00e0 virgule flottante pour dormir pendant un nombre fractionnaire de secondes.\"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"Temporiser pour un nombre donn\u00e9 de millisecondes.\n\nExample: ``time.sleep_ms(1_000_000)``\n\n:param ms: Le nombre de millisecondes \u00e0 attendre (>= 0).\"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"Temporiser pour un nombre donn\u00e9 de microsecondes.\n\nExample: ``time.sleep_us(1000)``\n\n:param us: Le nombre de microsecondes \u00e0 attendre (>= 0).\"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"Obtenir un compteur croissant en millisecondes avec un point de r\u00e9f\u00e9rence arbitraire.\nLe compteur revient \u00e0 z\u00e9ro apr\u00e8s une certaine valeur.\n\nExample: ``time.ticks_ms()``\n\n:return: The counter value in milliseconds.\"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"Obtenir un compteur croissant en microsecondes avec un point de r\u00e9f\u00e9rence arbitraire.\nLe compteur revient \u00e0 z\u00e9ro apr\u00e8s une certaine valeur.\n\nExample: ``time.ticks_us()``\n\n:return: The counter value in microseconds.\"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"D\u00e9caler les ticks par un nombre donn\u00e9, positif ou n\u00e9gatif.\n\nExample: ``time.ticks_add(time.ticks_ms(), 200)``\n\nGiven a ticks value, this function allows to calculate ticks\nvalue delta ticks before or after it, following modular-arithmetic\ndefinition of tick values.\n\n:param ticks: Une valeur de ticks\n:param delta: Un entier repr\u00e9sentant le d\u00e9calage\n\nExample::\n\n    # Find out what ticks value there was 100ms ago\n    print(ticks_add(time.ticks_ms(), -100))\n\n    # Calculate deadline for operation and test for it\n    deadline = ticks_add(time.ticks_ms(), 200)\n    while ticks_diff(deadline, time.ticks_ms()) > 0:\n        do_a_little_of_something()\n\n    # Find out TICKS_MAX used by this port\n    print(ticks_add(0, -1))\"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"Mesurer la diff\u00e9rence des ticks entre les valeurs retourn\u00e9es par\n``time.ticks_ms()`` ou ``ticks_us()``, sous la forme d'une valeur sign\u00e9e\nqui peut passer plusieurs fois par z\u00e9ro.\n\nExample: ``time.ticks_diff(scheduled_time, now)``\n\n:param ticks1: La valeur \u00e0 partir de laquelle soustraire\n:param ticks2: La valeur \u00e0 soustraire\n\nThe argument order is the same as for subtraction operator,\n``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n``ticks_diff()`` is designed to accommodate various usage\npatterns, among them:\n\nPolling with timeout. In this case, the order of events is known, and you\nwill deal only with positive results of :func:`time.ticks_diff()`::\n\n    # Wait for GPIO pin to be asserted, but at most 500us\n    start = time.ticks_us()\n    while pin.value() == 0:\n        if time.ticks_diff(time.ticks_us(), start) > 500:\n            raise TimeoutError\n\n\nScheduling events. In this case, :func:`time.ticks_diff()` result may be\nnegative if an event is overdue::\n\n    # This code snippet is not optimized\n    now = time.ticks_ms()\n    scheduled_time = task.scheduled_time()\n    if ticks_diff(scheduled_time, now) > 0:\n        print(\"Too early, let's nap\")\n        sleep_ms(ticks_diff(scheduled_time, now))\n        task.run()\n    elif ticks_diff(scheduled_time, now) == 0:\n        print(\"Right at time!\")\n        task.run()\n    elif ticks_diff(scheduled_time, now) < 0:\n        print(\"Oops, running late, tell task to run faster!\")\n        task.run(run_faster=True)\"\"\"\n    ...",
    "/typeshed/stdlib/types.pyi": "import sys\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    __hash__: None  # type: ignore\n    cell_contents: Any\n\n@final\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    __globals__: dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: None  # type: ignore\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: dict[str, Any]\n    __package__: str | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: GeneratorType[_T_co, _T_contra, Any] | None\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Awaitable[Any] | None\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\n@final\nclass CoroutineType:\n    cr_await: Any | None\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: object | None, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    __closure__: Tuple[_Cell, ...] | None  # inherited from the added function\n    __defaults__: Tuple[Any, ...] | None  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    __self__: object | ModuleType\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    @final\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    @final\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\n@final\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(\n            self,\n            tb_next: TracebackType | None,\n            tb_frame: FrameType,\n            tb_lasti: int,\n            tb_lineno: int,\n        ) -> None: ...\n        tb_next: TracebackType | None\n    else:\n        @property\n        def tb_next(self) -> TracebackType | None: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    f_back: FrameType | None\n    f_builtins: dict[str, Any]\n    f_code: CodeType\n    f_globals: dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: dict[str, Any]\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: dict[str, Any] | None = ...\n) -> Tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    @final\n    class UnionType:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> UnionType: ...\n        def __ror__(self, obj: Any) -> UnionType: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = ...,\n    localns: dict[str, Any] | None = ...,\n    include_extras: bool = ...,\n) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Type[Any] | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: None | Type[Any] | str = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "from array import *\n",
    "/typeshed/stdlib/ucollections.pyi": "from collections import *\n",
    "/typeshed/stdlib/uerrno.pyi": "from errno import *\n",
    "/typeshed/stdlib/urandom.pyi": "from random import *\n",
    "/typeshed/stdlib/ustruct.pyi": "from struct import *\n",
    "/typeshed/stdlib/usys.pyi": "from sys import *\n",
    "/typeshed/stdlib/utime.pyi": "from time import *\n",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any]]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any]]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"Broches, images, sons, temp\u00e9rature et volume\"\"\"\nfrom typing import Any, Callable, List, Optional, Tuple, Union, overload\nfrom _typeshed import ReadableBuffer\nfrom . import accelerometer as accelerometer\nfrom . import audio as audio\nfrom . import compass as compass\nfrom . import display as display\nfrom . import i2c as i2c\nfrom . import microphone as microphone\nfrom . import speaker as speaker\nfrom . import spi as spi\nfrom . import uart as uart\n\ndef run_every(callback: Optional[Callable[[], None]]=None, days: int=0, h: int=0, min: int=0, s: int=0, ms: int=0) -> Callable[[Callable[[], None]], Callable[[], None]]:\n    \"\"\"Planifie l'ex\u00e9cution d'une fonction \u00e0 l'intervalle sp\u00e9cifi\u00e9 par les arguments temporels **V2 uniquement**.\n\nExample: ``run_every(my_logging, min=5)``\n\n``run_every`` can be used in two ways:\n\nAs a Decorator - placed on top of the function to schedule. For example::\n\n    @run_every(h=1, min=20, s=30, ms=50)\n    def my_function():\n        # Do something here\n\nAs a Function - passing the callback as a positional argument. For example::\n\n    def my_function():\n        # Do something here\n    run_every(my_function, s=30)\n\nEach argument corresponds to a different time unit and they are additive.\nSo ``run_every(min=1, s=30)`` schedules the callback every minute and a half.\n\nWhen an exception is thrown inside the callback function it deschedules the\nfunction. To avoid this you can catch exceptions with ``try/except``.\n\n:param callback: Fonction \u00e0 appeler \u00e0 l'intervalle fourni. \u00c0 omettre en cas d'utilisation comme d\u00e9corateur.\n:param days: D\u00e9finit la marque du jour pour la programmation.\n:param h: D\u00e9finit la marque d'heure pour la programmation.\n:param min: D\u00e9finit la marque de minute pour la programmation.\n:param s: D\u00e9finit la marque de seconde pour la programmation.\n:param ms: D\u00e9finit la marque de milliseconde pour la programmation.\"\"\"\n\ndef panic(n: int) -> None:\n    \"\"\"Passer en mode panique.\n\nExample: ``panic(127)``\n\n:param n: Un nombre entier arbitraire <= 255 pour indiquer un \u00e9tat.\n\nRequires restart.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Red\u00e9marrer la carte.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[int, int]) -> int:\n    \"\"\"Convertit une valeur dans l'intervalle donn\u00e9 vers son \u00e9quivalent dans un autre intervalle d'entiers.\n\nExample: ``volume = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))``\n\nFor example, to convert an accelerometer X value to a speaker volume.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\n\n    temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))\n\n:param value: Un nombre \u00e0 convertir.\n:param from_: Un tuple qui d\u00e9finit l'intervalle de d\u00e9part.\n:param to: Un tuple qui d\u00e9finit l'intervalle d'arriv\u00e9e.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[float, float]) -> float:\n    \"\"\"Convertit une valeur dans l'intervalle donn\u00e9 vers son \u00e9quivalent dans un autre intervalle de nombres \u00e0 virgule flottante.\n\nExample: ``temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))``\n\nFor example, to convert temperature from a Celsius scale to Fahrenheit.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\nIf they are both integers (i.e ``10``), it will return an integer::\n\n    returns_int = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))\n\n:param value: Un nombre \u00e0 convertir.\n:param from_: Un tuple qui d\u00e9finit l'intervalle de d\u00e9part.\n:param to: Un tuple qui d\u00e9finit l'intervalle d'arriv\u00e9e.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\ndef sleep(n: float) -> None:\n    \"\"\"Attendre ``n`` millisecondes.\n\nExample: ``sleep(1000)``\n\n:param n: Le nombre de millisecondes \u00e0 attendre\n\nOne second is 1000 milliseconds, so::\n\n    microbit.sleep(1000)\n\nwill pause the execution for one second.\"\"\"\n\ndef running_time() -> int:\n    \"\"\"Obtenir le temps de fonctionnement de la carte.\n\n:return: The number of milliseconds since the board was switched on or restarted.\"\"\"\n\ndef temperature() -> int:\n    \"\"\"Obtenir la temp\u00e9rature du micro:bit en degr\u00e9s Celsius.\"\"\"\n\ndef set_volume(v: int) -> None:\n    \"\"\"D\u00e9finit le volume.\n\nExample: ``set_volume(127)``\n\n:param v: Une valeur entre 0 (bas) et 255 (haut).\n\nOut of range values will be clamped to 0 or 255.\n\n**V2** only.\"\"\"\n    ...\n\nclass Button:\n    \"\"\"La classe pour les boutons ``button_a`` et ``button_b``.\"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"V\u00e9rifier si le bouton est appuy\u00e9.\n\n:return: ``True`` if the specified button ``button`` is pressed, and ``False`` otherwise.\"\"\"\n        ...\n\n    def was_pressed(self) -> bool:\n        \"\"\"V\u00e9rifie si le bouton a \u00e9t\u00e9 press\u00e9 depuis que l'appareil a \u00e9t\u00e9 d\u00e9marr\u00e9 ou depuis la derni\u00e8re fois o\u00f9 cette m\u00e9thode a \u00e9t\u00e9 appel\u00e9e.\n\nCalling this method will clear the press state so\nthat the button must be pressed again before this method will return\n``True`` again.\n\n:return: ``True`` if the specified button ``button`` was pressed, and ``False`` otherwise\"\"\"\n        ...\n\n    def get_presses(self) -> int:\n        \"\"\"Obtenir le nombre total d'occurrences o\u00f9 le bouton a \u00e9t\u00e9 appuy\u00e9, et r\u00e9initialise ce total avant de retourner.\n\n:return: The number of presses since the device started or the last time this method was called\"\"\"\n        ...\nbutton_a: Button\n\"\"\"L'objet bouton ``Button`` gauche.\"\"\"\nbutton_b: Button\n\"\"\"L'objet bouton ``Button`` droit.\"\"\"\n\nclass MicroBitDigitalPin:\n    \"\"\"Une broche num\u00e9rique.\n\nSome pins support analog and touch features using the ``MicroBitAnalogDigitalPin`` and ``MicroBitTouchPin`` subclasses.\"\"\"\n    NO_PULL: int\n    PULL_UP: int\n    PULL_DOWN: int\n\n    def read_digital(self) -> int:\n        \"\"\"R\u00e9cup\u00e8re la valeur num\u00e9rique de la broche\n\nExample: ``value = pin0.read_digital()``\n\n:return: 1 if the pin is high, and 0 if it's low.\"\"\"\n        ...\n\n    def write_digital(self, value: int) -> None:\n        \"\"\"D\u00e9finit la valeur num\u00e9rique de la broche\n\nExample: ``pin0.write_digital(1)``\n\n:param value: 1 pour d\u00e9finir la broche \u00e0 un niveau haut ou 0 pour d\u00e9finir la broche \u00e0 un niveau bas\"\"\"\n        ...\n\n    def set_pull(self, value: int) -> None:\n        \"\"\"D\u00e9finissez l'\u00e9tat de tirage sur l'une des trois valeurs possibles\\xa0: ``PULL_UP``, ``PULL_DOWN`` ou ``NO_PULL``.\n\nExample: ``pin0.set_pull(pin0.PULL_UP)``\n\n:param value: L'\u00e9tat de tirage sur la broche correspondante, par exemple ``pin0.PULL_UP``.\"\"\"\n        ...\n\n    def get_pull(self) -> int:\n        \"\"\"Obtenir l'\u00e9tat de tirage sur une broche.\n\nExample: ``pin0.get_pull()``\n\n:return: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``\n\nThese are set using the ``set_pull()`` method or automatically configured\nwhen a pin mode requires it.\"\"\"\n        ...\n\n    def get_mode(self) -> str:\n        \"\"\"Renvoie le mode de la broche\n\nExample: ``pin0.get_mode()``\n\nWhen a pin is used for a specific function, like\nwriting a digital value, or reading an analog value, the pin mode\nchanges.\n\n:return: ``\"unused\"``, ``\"analog\"``, ``\"read_digital\"``, ``\"write_digital\"``, ``\"display\"``, ``\"button\"``, ``\"music\"``, ``\"audio\"``, ``\"touch\"``, ``\"i2c\"``, or ``\"spi\"``\"\"\"\n        ...\n\n    def write_analog(self, value: int) -> None:\n        \"\"\"Sortie d'un signal PWM sur la broche, avec un rapport cyclique proportionnel \u00e0 ``value``.\n\nExample: ``pin0.write_analog(254)``\n\n:param value: Un entier ou un nombre \u00e0 virgule flottante entre 0 (rapport cyclique \u00e0 0%) et 1023 (rapport cyclique \u00e0 100%).\"\"\"\n\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"D\u00e9finit la p\u00e9riode de sortie du signal PWM \u00e0 ``period`` en millisecondes.\n\nExample: ``pin0.set_analog_period(10)``\n\n:param period: La p\u00e9riode en millisecondes avec une valeur minimale valide de 1 ms.\"\"\"\n\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"D\u00e9finit la p\u00e9riode de sortie du signal PWM \u00e0 ``period`` en millisecondes.\n\nExample: ``pin0.set_analog_period_microseconds(512)``\n\n:param period: La p\u00e9riode en microsecondes avec une valeur minimale valide de 256\u00b5s.\"\"\"\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    \"\"\"Une broche avec des fonctions analogiques et num\u00e9riques.\"\"\"\n\n    def read_analog(self) -> int:\n        \"\"\"Lit la tension appliqu\u00e9e \u00e0 la broche.\n\nExample: ``pin0.read_analog()``\n\n:return: An integer between 0 (meaning 0V) and 1023 (meaning 3.3V).\"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    \"\"\"Une broche avec des fonctions analogiques, num\u00e9riques et tactiles.\"\"\"\n    CAPACITIVE: int\n    RESISTIVE: int\n\n    def is_touched(self) -> bool:\n        \"\"\"V\u00e9rifie si la broche est touch\u00e9e.\n\nExample: ``pin0.is_touched()``\n\nThe default touch mode for the pins on the edge connector is ``resistive``.\nThe default for the logo pin **V2** is ``capacitive``.\n\n**Resistive touch**\nThis test is done by measuring how much resistance there is between the\npin and ground.  A low resistance gives a reading of ``True``.  To get\na reliable reading using a finger you may need to touch the ground pin\nwith another part of your body, for example your other hand.\n\n**Capacitive touch**\nThis test is done by interacting with the electric field of a capacitor\nusing a finger as a conductor. `Capacitive touch\n<https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_\ndoes not require you to make a ground connection as part of a circuit.\n\n:return: ``True`` if the pin is being touched with a finger, otherwise return ``False``.\"\"\"\n        ...\n\n    def set_touch_mode(self, value: int) -> None:\n        \"\"\"D\u00e9finit le mode tactile pour la broche.\n\nExample: ``pin0.set_touch_mode(pin0.CAPACITIVE)``\n\nThe default touch mode for the pins on the edge connector is\n``resistive``. The default for the logo pin **V2** is ``capacitive``.\n\n:param value: ``CAPACITIVE`` ou ``RESISTIVE`` pour la broche correspondante.\"\"\"\n        ...\npin0: MicroBitTouchPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques, analogiques, et tactiles.\"\"\"\npin1: MicroBitTouchPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques, analogiques, et tactiles.\"\"\"\npin2: MicroBitTouchPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques, analogiques, et tactiles.\"\"\"\npin3: MicroBitAnalogDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques et analogiques.\"\"\"\npin4: MicroBitAnalogDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques et analogiques.\"\"\"\npin5: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin6: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin7: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin8: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin9: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin10: MicroBitAnalogDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques et analogiques.\"\"\"\npin11: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin12: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin13: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin14: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin15: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin16: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin19: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin20: MicroBitDigitalPin\n\"\"\"Broche avec des fonctionnalit\u00e9s num\u00e9riques\"\"\"\npin_logo: MicroBitTouchPin\n\"\"\"Une broche logo sensible au toucher sur l'avant du micro:bit, qui est d\u00e9finie par d\u00e9faut en mode tactile capacitif.\"\"\"\npin_speaker: MicroBitAnalogDigitalPin\n\"\"\"Une broche pour adresser le haut-parleur micro:bit.\n\nThis API is intended only for use in Pulse-Width Modulation pin operations e.g. pin_speaker.write_analog(128).\n\"\"\"\n\nclass Image:\n    \"\"\"Une image \u00e0 afficher sur l'\u00e9cran LED du micro:bit.\n\nGiven an image object it's possible to display it via the ``display`` API::\n\n    display.show(Image.HAPPY)\"\"\"\n    HEART: Image\n    \"\"\"Image d'un c\u0153ur.\"\"\"\n    HEART_SMALL: Image\n    \"\"\"Petite image d'un c\u0153ur\"\"\"\n    HAPPY: Image\n    \"\"\"Image de visage heureux.\"\"\"\n    SMILE: Image\n    \"\"\"Image de visage souriant.\"\"\"\n    SAD: Image\n    \"\"\"Image de visage triste.\"\"\"\n    CONFUSED: Image\n    \"\"\"Image d'un visage perplexe.\"\"\"\n    ANGRY: Image\n    \"\"\"Image de visage en col\u00e8re.\"\"\"\n    ASLEEP: Image\n    \"\"\"Image de visage endormi\"\"\"\n    SURPRISED: Image\n    \"\"\"Image de visage surpris.\"\"\"\n    SILLY: Image\n    \"\"\"Image de visage absurde.\"\"\"\n    FABULOUS: Image\n    \"\"\"Image de visage avec lunettes de soleil.\"\"\"\n    MEH: Image\n    \"\"\"Image de visage pas impressionn\u00e9\"\"\"\n    YES: Image\n    \"\"\"Image d'une coche.\"\"\"\n    NO: Image\n    \"\"\"Image d'une croix.\"\"\"\n    CLOCK12: Image\n    \"\"\"Image avec une ligne indiquant vers 12 heures.\"\"\"\n    CLOCK11: Image\n    \"\"\"Image avec une ligne indiquant vers 11 heures.\"\"\"\n    CLOCK10: Image\n    \"\"\"Image avec une ligne indiquant vers 10 heures.\"\"\"\n    CLOCK9: Image\n    \"\"\"Image avec une ligne indiquant vers 9 heures.\"\"\"\n    CLOCK8: Image\n    \"\"\"Image avec une ligne indiquant vers 8 heures.\"\"\"\n    CLOCK7: Image\n    \"\"\"Image avec une ligne indiquant vers 7 heures.\"\"\"\n    CLOCK6: Image\n    \"\"\"Image avec une ligne indiquant vers 6 heures.\"\"\"\n    CLOCK5: Image\n    \"\"\"Image avec une ligne indiquant vers 5 heures.\"\"\"\n    CLOCK4: Image\n    \"\"\"Image avec une ligne indiquant vers 4 heures.\"\"\"\n    CLOCK3: Image\n    \"\"\"Image avec une ligne indiquant vers 3 heures.\"\"\"\n    CLOCK2: Image\n    \"\"\"Image avec une ligne indiquant vers 2 heures.\"\"\"\n    CLOCK1: Image\n    \"\"\"Image avec une ligne indiquant vers 1 heure.\"\"\"\n    ARROW_N: Image\n    \"\"\"Image de fl\u00e8che pointant vers le nord.\"\"\"\n    ARROW_NE: Image\n    \"\"\"Image de fl\u00e8che pointant vers le nord est.\"\"\"\n    ARROW_E: Image\n    \"\"\"Image de fl\u00e8che pointant vers l'est.\"\"\"\n    ARROW_SE: Image\n    \"\"\"Image de fl\u00e8che pointant vers le sud-est.\"\"\"\n    ARROW_S: Image\n    \"\"\"Image de fl\u00e8che pointant vers le sud.\"\"\"\n    ARROW_SW: Image\n    \"\"\"Image de fl\u00e8che pointant vers le sud-ouest.\"\"\"\n    ARROW_W: Image\n    \"\"\"Image de fl\u00e8che pointant vers l'ouest.\"\"\"\n    ARROW_NW: Image\n    \"\"\"Image de fl\u00e8che pointant vers le nord ouest.\"\"\"\n    TRIANGLE: Image\n    \"\"\"Image d'un triangle pointant vers le haut.\"\"\"\n    TRIANGLE_LEFT: Image\n    \"\"\"Image d'un triangle dans le coin gauche.\"\"\"\n    CHESSBOARD: Image\n    \"\"\"\u00c9clairage alternatif des LEDs dans un motif d'\u00e9chiquier.\"\"\"\n    DIAMOND: Image\n    \"\"\"Image de diamant.\"\"\"\n    DIAMOND_SMALL: Image\n    \"\"\"Petite image de diamant.\"\"\"\n    SQUARE: Image\n    \"\"\"Image de carr\u00e9.\"\"\"\n    SQUARE_SMALL: Image\n    \"\"\"Petite image de carr\u00e9.\"\"\"\n    RABBIT: Image\n    \"\"\"Image de lapin.\"\"\"\n    COW: Image\n    \"\"\"Image de vache.\"\"\"\n    MUSIC_CROTCHET: Image\n    \"\"\"Image d'une note.\"\"\"\n    MUSIC_QUAVER: Image\n    \"\"\"Image d'une croche.\"\"\"\n    MUSIC_QUAVERS: Image\n    \"\"\"Image d'une paire de croche.\"\"\"\n    PITCHFORK: Image\n    \"\"\"Image d'une fourche.\"\"\"\n    XMAS: Image\n    \"\"\"Image d'un arbre de No\u00ebl.\"\"\"\n    PACMAN: Image\n    \"\"\"Image du personnage d'arcade Pac-Man.\"\"\"\n    TARGET: Image\n    \"\"\"Image d'une cible.\"\"\"\n    TSHIRT: Image\n    \"\"\"Image de t-shirt.\"\"\"\n    ROLLERSKATE: Image\n    \"\"\"Image de patin \u00e0 roulette.\"\"\"\n    DUCK: Image\n    \"\"\"Image de canard.\"\"\"\n    HOUSE: Image\n    \"\"\"Image d'une maison.\"\"\"\n    TORTOISE: Image\n    \"\"\"Image d'une tortue.\"\"\"\n    BUTTERFLY: Image\n    \"\"\"Image d'un papillon.\"\"\"\n    STICKFIGURE: Image\n    \"\"\"Image d'un personnage.\"\"\"\n    GHOST: Image\n    \"\"\"Image de fant\u00f4me.\"\"\"\n    SWORD: Image\n    \"\"\"Image d'une \u00e9p\u00e9e.\"\"\"\n    GIRAFFE: Image\n    \"\"\"Image d'une girafe.\"\"\"\n    SKULL: Image\n    \"\"\"Image d'un cr\u00e2ne.\"\"\"\n    UMBRELLA: Image\n    \"\"\"Image d'un parapluie.\"\"\"\n    SNAKE: Image\n    \"\"\"Image de serpent.\"\"\"\n    SCISSORS: Image\n    \"\"\"Image de ciseaux.\"\"\"\n    ALL_CLOCKS: List[Image]\n    \"\"\"Une liste contenant toutes les images CLOCK_ en s\u00e9quence.\"\"\"\n    ALL_ARROWS: List[Image]\n    \"\"\"Une liste contenant toutes les images ARROW_ en s\u00e9quence.\"\"\"\n\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"Cr\u00e9er une image \u00e0 partir d'une cha\u00eene de caract\u00e8res d\u00e9crivant quelles LED sont allum\u00e9es.\n\n``string`` has to consist of digits 0-9 arranged into lines,\ndescribing the image, for example::\n\n    image = Image(\"90009:\"\n                  \"09090:\"\n                  \"00900:\"\n                  \"09090:\"\n                  \"90009\")\n\nwill create a 5\u00d75 image of an X. The end of a line is indicated by a\ncolon. It's also possible to use newlines (\\\\n) insead of the colons.\n\n:param string: La cha\u00eene de caract\u00e8res d\u00e9crivant l'image.\"\"\"\n        ...\n\n    @overload\n    def __init__(self, width: int=5, height: int=5, buffer: ReadableBuffer=None) -> None:\n        \"\"\"Cr\u00e9er une image vide avec ``width`` colonnes et ``height`` lignes.\n\n:param width: Largeur optionnelle de l'image\n:param height: Hauteur optionnelle de l'image\n:param buffer: Tableau optionnel ou octets de ``width``\u00d7``height`` entiers dans la plage 0-9 pour initialiser l'image\n\nExamples::\n\n    Image(2, 2, b'\\x08\\x08\\x08\\x08')\n    Image(2, 2, bytearray([9,9,9,9]))\n\nThese create 2 x 2 pixel images at full brightness.\"\"\"\n        ...\n\n    def width(self) -> int:\n        \"\"\"R\u00e9cup\u00e8re le nombre de colonnes.\n\n:return: The number of columns in the image\"\"\"\n        ...\n\n    def height(self) -> int:\n        \"\"\"R\u00e9cup\u00e8re le nombre de lignes.\n\n:return: The number of rows in the image\"\"\"\n        ...\n\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"D\u00e9finit la luminosit\u00e9 d'un pixel.\n\nExample: ``my_image.set_pixel(0, 0, 9)``\n\n:param x: Le num\u00e9ro de colonne\n:param y: Le num\u00e9ro de ligne\n:param value: La luminosit\u00e9 sous la forme d'un entier compris entre 0 (sombre) et 9 (lumineux)\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"R\u00e9cup\u00e8re la luminosit\u00e9 d'un pixel.\n\nExample: ``my_image.get_pixel(0, 0)``\n\n:param x: Le num\u00e9ro de colonne\n:param y: Le num\u00e9ro de ligne\n:return: The brightness as an integer between 0 and 9.\"\"\"\n        ...\n\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Cr\u00e9er une nouvelle image en d\u00e9pla\u00e7ant l'image \u00e0 gauche.\n\nExample: ``Image.HEART_SMALL.shift_left(1)``\n\n:param n: Le nombre de colonnes par lequel d\u00e9placer\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Cr\u00e9er une nouvelle image en d\u00e9pla\u00e7ant l'image \u00e0 droite.\n\nExample: ``Image.HEART_SMALL.shift_right(1)``\n\n:param n: Le nombre de colonnes par lequel d\u00e9placer\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Cr\u00e9er une nouvelle image en d\u00e9pla\u00e7ant l'image vers le haut.\n\nExample: ``Image.HEART_SMALL.shift_up(1)``\n\n:param n: Le nombre de lignes par lequel d\u00e9placer\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Cr\u00e9er une nouvelle image en d\u00e9pla\u00e7ant l'image vers le bas.\n\nExample: ``Image.HEART_SMALL.shift_down(1)``\n\n:param n: Le nombre de lignes par lequel d\u00e9placer\n:return: The shifted image\"\"\"\n        ...\n\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Cr\u00e9er une nouvelle image en recadrant l'image.\n\nExample: ``Image.HEART.crop(1, 1, 3, 3)``\n\n:param x: Le nombre de colonnes duquel d\u00e9caler le recadrage\n:param y: Le nombre de lignes duquel d\u00e9caler le recadrage\n:param w: La largeur du recadrage\n:param h: La hauteur du recadrage\n:return: The new image\"\"\"\n        ...\n\n    def copy(self) -> Image:\n        \"\"\"Cr\u00e9er une copie exacte de l'image.\n\nExample: ``Image.HEART.copy()``\n\n:return: The new image\"\"\"\n        ...\n\n    def invert(self) -> Image:\n        \"\"\"Cr\u00e9er une nouvelle image en inversant la luminosit\u00e9 des pixels de l'image source.\n\nExample: ``Image.SMALL_HEART.invert()``\n\n:return: The new image.\"\"\"\n        ...\n\n    def fill(self, value: int) -> None:\n        \"\"\"D\u00e9finit la luminosit\u00e9 de tous les pixels de l'image.\n\nExample: ``my_image.fill(5)``\n\n:param value: La nouvelle luminosit\u00e9 sous la forme d'un nombre compris entre 0 (sombre) et 9 (lumineux).\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def blit(self, src: Image, x: int, y: int, w: int, h: int, xdest: int=0, ydest: int=0) -> None:\n        \"\"\"Copier la zone d'une autre image vers cette image.\n\nExample: ``my_image.blit(Image.HEART, 1, 1, 3, 3, 1, 1)``\n\n:param src: L'image source\n:param x: Le d\u00e9calage de la colonne de d\u00e9part dans l'image source\n:param y: D\u00e9calage de la ligne de d\u00e9part dans l'image source\n:param w: Le nombre de colonnes \u00e0 copier\n:param h: Le nombre de lignes \u00e0 copier\n:param xdest: Le d\u00e9calage de la colonne \u00e0 modifier dans cette image\n:param ydest: Le d\u00e9calage de la ligne \u00e0 modifier dans cette image\n\nPixels outside the source image are treated as having a brightness of 0.\n\n``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\nand ``crop()`` can are all implemented by using ``blit()``.\n\nFor example, img.crop(x, y, w, h) can be implemented as::\n\n    def crop(self, x, y, w, h):\n        res = Image(w, h)\n        res.blit(self, x, y, w, h)\n        return res\"\"\"\n        ...\n\n    def __repr__(self) -> str:\n        \"\"\"R\u00e9cup\u00e8re une repr\u00e9sentation de l'image sous forme de texte compact.\"\"\"\n        ...\n\n    def __str__(self) -> str:\n        \"\"\"R\u00e9cup\u00e8re une cha\u00eene de caract\u00e8res lisible de l'image.\"\"\"\n        ...\n\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Cr\u00e9e une nouvelle image en additionnant les valeurs de luminosit\u00e9 des deux images\npour chaque pixel.\n\nExample: ``Image.HEART + Image.HAPPY``\n\n:param other: L'image \u00e0 ajouter.\"\"\"\n        ...\n\n    def __sub__(self, other: Image) -> Image:\n        \"\"\"Cr\u00e9e une nouvelle image en soustrayant de cette image les valeurs de luminosit\u00e9 de\nl'autre image.\n\nExample: ``Image.HEART - Image.HEART_SMALL``\n\n:param other: L'image \u00e0 soustraire.\"\"\"\n        ...\n\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Cr\u00e9e une nouvelle image en multipliant la luminosit\u00e9 de chaque pixel par\n``n``.\n\nExample: ``Image.HEART * 0.5``\n\n:param n: La valeur par laquelle multiplier.\"\"\"\n        ...\n\n    def __truediv__(self, n: float) -> Image:\n        \"\"\"Cr\u00e9e une nouvelle image en divisant la luminosit\u00e9 de chaque pixel par\n``n``.\n\nExample: ``Image.HEART / 2``\n\n:param n: La valeur par laquelle diviser.\"\"\"\n        ...\n\nclass SoundEvent:\n    LOUD: SoundEvent\n    \"\"\"Repr\u00e9sente la transition d'\u00e9v\u00e9nements sonores, de ``quiet`` \u00e0 ``loud`` comme un clap dans les mains ou un cri.\"\"\"\n    QUIET: SoundEvent\n    \"\"\"Repr\u00e9sente la transition d'\u00e9v\u00e9nements sonores de ``loud`` \u00e0 ``quiet`` comme parler ou \u00e9couter de la musique de fond.\"\"\"\n\nclass Sound:\n    \"\"\"Les sons int\u00e9gr\u00e9s peuvent \u00eatre appel\u00e9s en utilisant ``audio.play(Sound.NAME)``.\"\"\"\n    GIGGLE: Sound\n    \"\"\"Bruit de gloussement.\"\"\"\n    HAPPY: Sound\n    \"\"\"Son joyeux.\"\"\"\n    HELLO: Sound\n    \"\"\"Son de salutation.\"\"\"\n    MYSTERIOUS: Sound\n    \"\"\"Son myst\u00e9rieux.\"\"\"\n    SAD: Sound\n    \"\"\"Son triste.\"\"\"\n    SLIDE: Sound\n    \"\"\"Bruit de glissade.\"\"\"\n    SOARING: Sound\n    \"\"\"Bruit d'envol\u00e9e.\"\"\"\n    SPRING: Sound\n    \"\"\"Son d'un ressort.\"\"\"\n    TWINKLE: Sound\n    \"\"\"Son de scintillement.\"\"\"\n    YAWN: Sound\n    \"\"\"Son de b\u00e2illement.\"\"\"",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"Mesurer l'acc\u00e9l\u00e9ration du micro:bit et reconnaitre des mouvements.\"\"\"\nfrom typing import Tuple\n\ndef get_x() -> int:\n    \"\"\"R\u00e9cup\u00e9rer la mesure de l'acc\u00e9l\u00e9ration dans l'axe ``x`` en milli-g.\n\nExample: ``accelerometer.get_x()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"R\u00e9cup\u00e9rer la mesure de l'acc\u00e9l\u00e9ration dans l'axe ``y`` en milli-g.\n\nExample: ``accelerometer.get_y()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"R\u00e9cup\u00e9rer la mesure de l'acc\u00e9l\u00e9ration dans l'axe ``z`` en milli-g.\n\nExample: ``accelerometer.get_z()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"R\u00e9cup\u00e9rer en une fois les mesures d'acc\u00e9l\u00e9ration dans tous les axes sous forme d'un tuple.\n\nExample: ``x, y, z = accelerometer.get_values()``\n\n:return: a three-element tuple of integers ordered as X, Y, Z, each value a positive or negative integer depending on direction in the range +/- 2000mg\"\"\"\n    ...\n\ndef get_strength() -> int:\n    \"\"\"Obtenir la mesure de l'acc\u00e9l\u00e9ration de tous les axes combin\u00e9s, sous la forme d'un nombre entier positif. C'est la somme pythagoricienne des axes X, Y et Z.\n\nExample: ``accelerometer.get_strength()``\n\n:return: The combined acceleration strength of all the axes, in milli-g.\"\"\"\n    ...\n\ndef current_gesture() -> str:\n    \"\"\"R\u00e9cup\u00e9rer le nom du geste actuel.\n\nExample: ``accelerometer.current_gesture()``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:return: The current gesture\"\"\"\n    ...\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"V\u00e9rifier si le geste nomm\u00e9 est actif en ce moment.\n\nExample: ``accelerometer.is_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: Le nom du geste.\n:return: ``True`` if the gesture is active, ``False`` otherwise.\"\"\"\n    ...\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"V\u00e9rifier si le geste nomm\u00e9 a \u00e9t\u00e9 actif depuis le dernier appel.\n\nExample: ``accelerometer.was_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: Le nom du geste.\n:return: ``True`` if the gesture was active since the last call, ``False`` otherwise.\"\"\"\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Renvoyer un tuple de l'historique des gestes.\n\nExample: ``accelerometer.get_gestures()``\n\nClears the gesture history before returning.\n\nGestures are not updated in the background so there needs to be constant\ncalls to some accelerometer method to do the gesture detection. Usually\ngestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n\n:return: The history as a tuple, most recent last.\"\"\"\n    ...\n\ndef set_range(value: int) -> None:\n    \"\"\"D\u00e9finir la plage de sensibilit\u00e9 de l'acc\u00e9l\u00e9rom\u00e8tre, en g (gravit\u00e9 standard), \u00e0 la valeur la plus proche support\u00e9e par le mat\u00e9riel, l'arrondi se fait soit \u00e0 ``2``, ``4``, ou ``8`` g.\n\nExample: ``accelerometer.set_range(8)``\n\n:param value: Nouvelle plage pour l'acc\u00e9l\u00e9rom\u00e8tre, un entier en ``g``.\"\"\"",
    "/typeshed/stdlib/microbit/audio.pyi": "\"\"\"Jouer des sons en utilisant le micro:bit (importer ``audio`` pour compatibilit\u00e9 V1).\"\"\"\nfrom ..microbit import MicroBitDigitalPin, Sound, pin0\nfrom typing import ClassVar, Iterable, Union\n\ndef play(source: Union[Iterable[AudioFrame], Sound, SoundEffect], wait: bool=True, pin: MicroBitDigitalPin=pin0, return_pin: Union[MicroBitDigitalPin, None]=None) -> None:\n    \"\"\"Jouer un son int\u00e9gr\u00e9, un effet sonore ou des frames audio personnalis\u00e9es.\n\nExample: ``audio.play(Sound.GIGGLE)``\n\n:param source: Un ``Sound`` int\u00e9gr\u00e9 tel que ``Sound.GIGGLE``, un ``SoundEffect`` ou un \u00e9chantillon de donn\u00e9es sous la forme d'un it\u00e9rable d'objets ``AudioFrame``.\n:param wait: Si ``wait`` est ``True``, cette fonction bloquera jusqu'\u00e0 ce que le son soit termin\u00e9.\n:param pin: (broche) Un argument optionnel pour sp\u00e9cifier la broche de sortie, peut \u00eatre utilis\u00e9 pour remplacer la valeur par d\u00e9faut ``pin0``. Si nous ne voulons pas que le son soit jou\u00e9, il est possible d'utiliser ``pin=None``.\n:param return_pin: Sp\u00e9cifie une broche de connecteur de bord diff\u00e9rentiel \u00e0 connecter \u00e0 un haut-parleur externe au lieu de la masse. Ceci est ignor\u00e9 dans la r\u00e9vision **V2**.\"\"\"\n\ndef is_playing() -> bool:\n    \"\"\"V\u00e9rifier si un son est en train d'\u00eatre jou\u00e9.\n\nExample: ``audio.is_playing()``\n\n:return: ``True`` if audio is playing, otherwise ``False``.\"\"\"\n    ...\n\ndef stop() -> None:\n    \"\"\"Arr\u00eater toute lecture audio.\n\nExample: ``audio.stop()``\"\"\"\n    ...\n\nclass SoundEffect:\n    \"\"\"Un effet sonore, compos\u00e9 d'un ensemble de param\u00e8tres configur\u00e9s via le constructeur ou les attributs.\"\"\"\n    WAVEFORM_SINE: ClassVar[int]\n    \"\"\"Option d'onde sinuso\u00efdale utilis\u00e9e pour le param\u00e8tre ``waveform``.\"\"\"\n    WAVEFORM_SAWTOOTH: ClassVar[int]\n    \"\"\"Optionde forme d'onde en dent de scie utilis\u00e9e pour le param\u00e8tre ``waveform``.\"\"\"\n    WAVEFORM_TRIANGLE: ClassVar[int]\n    \"\"\"Option d'onde triangulaire utilis\u00e9e pour le param\u00e8tre ``waveform``.\"\"\"\n    WAVEFORM_SQUARE: ClassVar[int]\n    \"\"\"Option d'onde carr\u00e9e utilis\u00e9e pour le param\u00e8tre ``waveform``.\"\"\"\n    WAVEFORM_NOISE: ClassVar[int]\n    \"\"\"Option d'onde de bruit utilis\u00e9e pour le param\u00e8tre ``waveform``.\"\"\"\n    SHAPE_LINEAR: ClassVar[int]\n    \"\"\"Option d'interpolation lin\u00e9aire utilis\u00e9e pour le param\u00e8tre ``shape``.\"\"\"\n    SHAPE_CURVE: ClassVar[int]\n    \"\"\"Option d'interpolation courbe utilis\u00e9e pour le param\u00e8tre ``shape``.\"\"\"\n    SHAPE_LOG: ClassVar[int]\n    \"\"\"Option d'interpolation logarithmique utilis\u00e9e pour le param\u00e8tre ``shape``.\"\"\"\n    FX_NONE: ClassVar[int]\n    \"\"\"Option sans effet utilis\u00e9e pour le param\u00e8tre ``fx``.\"\"\"\n    FX_TREMOLO: ClassVar[int]\n    \"\"\"Option d'effet tremolo utilis\u00e9e pour le param\u00e8tre ``fx``.\"\"\"\n    FX_VIBRATO: ClassVar[int]\n    \"\"\"Option d'effet vibrato utilis\u00e9e pour le param\u00e8tre ``fx``.\"\"\"\n    FX_WARBLE: ClassVar[int]\n    \"\"\"Option d'effet de Warble utilis\u00e9e pour le param\u00e8tre ``fx``.\"\"\"\n    freq_start: int\n    \"\"\"Fr\u00e9quence de d\u00e9part en Hertz (Hz), un nombre compris entre ``0`` et ``9999``\"\"\"\n    freq_end: int\n    \"\"\"Fr\u00e9quence de fin en Hertz (Hz), un nombre compris entre ``0`` et ``9999``\"\"\"\n    duration: int\n    \"\"\"Dur\u00e9e du son en millisecondes, un nombre compris entre ``0`` et ``9999``\"\"\"\n    vol_start: int\n    \"\"\"Valeur du volume de d\u00e9part, un nombre compris entre ``0`` et ``255``\"\"\"\n    vol_end: int\n    \"\"\"Valeur du volume \u00e0 la fin, un nombre compris entre ``0`` et ``255``\"\"\"\n    waveform: int\n    \"\"\"Type de forme d'onde, une de ces valeurs : ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (bruit g\u00e9n\u00e9r\u00e9 al\u00e9atoirement)\"\"\"\n    fx: int\n    \"\"\"Effet \u00e0 ajouter au son, l'une des valeurs suivantes : ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``, ou ``FX_NONE``\"\"\"\n    shape: int\n    \"\"\"Le type de la courbe d'interpolation entre les fr\u00e9quences de d\u00e9but et de fin, les diff\u00e9rentes formes d'onde ont des taux de variation de fr\u00e9quence diff\u00e9rents. L'une des valeurs suivantes : ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``\"\"\"\n\n    def __init__(self, freq_start: int=500, freq_end: int=2500, duration: int=500, vol_start: int=255, vol_end: int=0, waveform: int=WAVEFORM_SQUARE, fx: int=FX_NONE, shape: int=SHAPE_LOG):\n        \"\"\"Cr\u00e9er un nouvel effet sonore.\n\nExample: ``my_effect = SoundEffect(duration=1000)``\n\nAll the parameters are optional, with default values as shown above, and\nthey can all be modified via attributes of the same name. For example, we\ncan first create an effect ``my_effect = SoundEffect(duration=1000)``,\nand then change its attributes ``my_effect.duration = 500``.\n\n:param freq_start: Fr\u00e9quence de d\u00e9part en Hertz (Hz), un nombre compris entre ``0`` et ``9999``.\n:param freq_end: Fr\u00e9quence de fin en Hertz (Hz), un nombre compris entre ``0`` et ``9999``.\n:param duration: Dur\u00e9e du son en millisecondes, un nombre compris entre ``0`` et ``9999``.\n:param vol_start: Valeur du volume de d\u00e9part, un nombre compris entre ``0`` et ``255``.\n:param vol_end: Valeur du volume \u00e0 la fin, un nombre compris entre ``0`` et ``255``.\n:param waveform: Type de forme d'onde, une de ces valeurs : ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (bruit g\u00e9n\u00e9r\u00e9 al\u00e9atoirement).\n:param fx: Effet \u00e0 ajouter au son, l'une des valeurs suivantes : ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``, ou ``FX_NONE``.\n:param shape: Le type de la courbe d'interpolation entre les fr\u00e9quences de d\u00e9but et de fin, les diff\u00e9rentes formes d'onde ont des taux de variation de fr\u00e9quence diff\u00e9rents. L'une des valeurs suivantes : ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``.\"\"\"\n\n    def copy(self) -> SoundEffect:\n        \"\"\"Cr\u00e9er une copie de ce ``SoundEffect``.\n\nExample: ``sound_2 = sound_1.copy()``\n\n:return: A copy of the SoundEffect.\"\"\"\n\nclass AudioFrame:\n    \"\"\"Un objet ``AudioFrame`` est une liste de 32 \u00e9chantillons, chacun d'eux \u00e9tant un octet non sign\u00e9\n(nombre entier entre 0 et 255).\n\nIt takes just over 4 ms to play a single frame.\n\nExample::\n\n    frame = AudioFrame()\n    for i in range(len(frame)):\n        frame[i] = 252 - i * 8\"\"\"\n\n    def copyfrom(self, other: AudioFrame) -> None:\n        \"\"\"\u00c9craser les donn\u00e9es de ce ``AudioFrame`` avec les donn\u00e9es d'une autre instance ``AudioFrame``.\n\nExample: ``my_frame.copyfrom(source_frame)``\n\n:param other: Instance ``AudioFrame`` \u00e0 partir de laquelle copier les donn\u00e9es.\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __setitem__(self, key: int, value: int) -> None:\n        ...\n\n    def __getitem__(self, key: int) -> int:\n        ...",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"Utiliser la boussole int\u00e9gr\u00e9e.\"\"\"\n\ndef calibrate() -> None:\n    \"\"\"D\u00e9marrer le processus d'\u00e9talonnage.\n\nExample: ``compass.calibrate()``\n\nAn instructive message will be scrolled to the user after which they will need\nto rotate the device in order to draw a circle on the LED display.\"\"\"\n    ...\n\ndef is_calibrated() -> bool:\n    \"\"\"V\u00e9rifier si la boussole est \u00e9talonn\u00e9e.\n\nExample: ``compass.is_calibrated()``\n\n:return: ``True`` if the compass has been successfully calibrated, ``False`` otherwise.\"\"\"\n    ...\n\ndef clear_calibration() -> None:\n    \"\"\"Annule l'\u00e9talonnage, la boussole est ainsi \u00e0 nouveau non-\u00e9talonn\u00e9e.\n\nExample: ``compass.clear_calibration()``\"\"\"\n    ...\n\ndef get_x() -> int:\n    \"\"\"Obtenir la force du champ magn\u00e9tique sur l'axe ``x``.\n\nExample: ``compass.get_x()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Obtenir la force du champ magn\u00e9tique sur l'axe ``y``.\n\nExample: ``compass.get_y()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Obtenir la force du champ magn\u00e9tique sur l'axe ``z``.\n\nExample: ``compass.get_z()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef heading() -> int:\n    \"\"\"Obtenir le cap de la boussole.\n\nExample: ``compass.heading()``\n\n:return: An integer in the range from 0 to 360, representing the angle in degrees, clockwise, with north as 0.\"\"\"\n    ...\n\ndef get_field_strength() -> int:\n    \"\"\"R\u00e9cup\u00e8re la magnitude du champ magn\u00e9tique autour de l'appareil.\n\nExample: ``compass.get_field_strength()``\n\n:return: An integer indication of the magnitude of the magnetic field in nano tesla.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"Afficher du texte, des images et des animations sur l'\u00e9cran LED 5\u00d75.\"\"\"\nfrom ..microbit import Image\nfrom typing import Union, overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"R\u00e9cup\u00e8re la luminosit\u00e9 de la LED \u00e0 la colonne ``x`` et \u00e0 la ligne ``y``.\n\nExample: ``display.get_pixel(0, 0)``\n\n:param x: La colonne d'affichage (0..4)\n:param y: La ligne d'affichage (0..4)\n:return: A number between 0 (off) and 9 (bright)\"\"\"\n    ...\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"D\u00e9finit la luminosit\u00e9 de la LED \u00e0 la colonne ``x`` et \u00e0 la ligne ``y``.\n\nExample: ``display.set_pixel(0, 0, 9)``\n\n:param x: La colonne d'affichage (0..4)\n:param y: La ligne d'affichage (0..4)\n:param value: La luminosit\u00e9 entre 0 (\u00e9teint) et 9 (lumineux)\"\"\"\n    ...\n\ndef clear() -> None:\n    \"\"\"R\u00e9gler la luminosit\u00e9 de toutes les LED \u00e0 0 (\u00e9teintes).\n\nExample: ``display.clear()``\"\"\"\n    ...\n\ndef show(image: Union[str, float, int, Image, Iterable[Image]], delay: int=400, wait: bool=True, loop: bool=False, clear: bool=False) -> None:\n    \"\"\"Afficher des images, des lettres ou des chiffres sur l'affichage LED.\n\nExample: ``display.show(Image.HEART)``\n\nWhen ``image`` is an image or a list of images then each image is displayed in turn.\nIf ``image`` is a string or number, each letter or digit is displayed in turn.\n\n:param image: Une cha\u00eene de caract\u00e8res, un nombre, une image ou une liste d'images \u00e0 afficher.\n:param delay: Chaque lettre, chiffre ou image est s\u00e9par\u00e9 par un d\u00e9lai de ``delay`` millisecondes.\n:param wait: Si ``wait`` est ``True`` cette fonction bloquera jusqu'\u00e0 la fin de l'animation, sinon l'animation s'effectuera en arri\u00e8re-plan.\n:param loop: Si ``loop`` est ``True``, l'animation se r\u00e9p\u00e9tera ind\u00e9finiment.\n:param clear: Si ``clear`` est ``True``, l'affichage sera effac\u00e9 une fois la s\u00e9quence termin\u00e9e.\n\nThe ``wait``, ``loop`` and ``clear`` arguments must be specified using their keyword.\"\"\"\n    ...\n\ndef scroll(text: Union[str, float, int], delay: int=150, wait: bool=True, loop: bool=False, monospace: bool=False) -> None:\n    \"\"\"Faire d\u00e9filer un nombre ou un texte sur l'affichage LED.\n\nExample: ``display.scroll('micro:bit')``\n\n:param text: La cha\u00eene de caract\u00e8res \u00e0 faire d\u00e9filer. Si ``text`` est un entier ou un nombre d\u00e9cimal, il sera converti en une cha\u00eene avec ``str()``.\n:param delay: Le param\u00e8tre ``delay`` contr\u00f4le la vitesse de d\u00e9filement du texte.\n:param wait: Si ``wait`` est ``True`` cette fonction bloquera jusqu'\u00e0 la fin de l'animation, sinon l'animation s'effectuera en arri\u00e8re-plan.\n:param loop: Si ``loop`` est ``True``, l'animation se r\u00e9p\u00e9tera ind\u00e9finiment.\n:param monospace: Si ``monospace`` est ``True``, tous les caract\u00e8res utiliseront 5 pixels en largeur, sinon, exactement 1 colonne de pixel vide sera ins\u00e9r\u00e9e entre chaque caract\u00e8re lors du d\u00e9filement.\n\nThe ``wait``, ``loop`` and ``monospace`` arguments must be specified\nusing their keyword.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Allumer l'\u00e9cran LED.\n\nExample: ``display.on()``\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Eteindre l'\u00e9cran LED (d\u00e9sactiver l'affichage vous permet de r\u00e9utiliser les broches GPIO \u00e0 d'autres fins).\n\nExample: ``display.off()``\"\"\"\n    ...\n\ndef is_on() -> bool:\n    \"\"\"V\u00e9rifier si l'affichage LED est activ\u00e9.\n\nExample: ``display.is_on()``\n\n:return: ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n    ...\n\ndef read_light_level() -> int:\n    \"\"\"Lit le niveau de lumi\u00e8re.\n\nExample: ``display.read_light_level()``\n\nUses the display's LEDs in reverse-bias mode to sense the amount of light\nfalling on the display.\n\n:return: An integer between 0 and 255 representing the light level, with larger meaning more light.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"Communiquer avec les p\u00e9riph\u00e9riques en utilisant le protocole de bus I\u00b2C.\"\"\"\nfrom _typeshed import ReadableBuffer\nfrom ..microbit import MicroBitDigitalPin, pin19, pin20\nfrom typing import List\n\ndef init(freq: int=100000, sda: MicroBitDigitalPin=pin20, scl: MicroBitDigitalPin=pin19) -> None:\n    \"\"\"R\u00e9initialiser un p\u00e9riph\u00e9rique.\n\nExample: ``i2c.init()``\n\n:param freq: fr\u00e9quence d'horloge\n:param sda: Broche ``sda`` (19 par d\u00e9faut)\n:param scl: Broche ``scl`` (19 par d\u00e9faut)\n\nOn a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\nthe accelerometer and compass stop working, as they are connected\ninternally to those pins. This warning does not apply to the **V2**\nrevision of the micro:bit as this has `separate I\u00b2C lines <https://tech.microbit.org/hardware/i2c/>`_\nfor the motion sensors and the edge connector.\"\"\"\n    ...\n\ndef scan() -> List[int]:\n    \"\"\"Scanner le bus pour d\u00e9tecter des p\u00e9riph\u00e9riques.\n\nExample: ``i2c.scan()``\n\n:return: A list of 7-bit addresses corresponding to those devices that responded to the scan.\"\"\"\n    ...\n\ndef read(addr: int, n: int, repeat: bool=False) -> bytes:\n    \"\"\"Lire des octets depuis un p\u00e9riph\u00e9rique.\n\nExample: ``i2c.read(0x50, 64)``\n\n:param addr: L'adresse 7-bit du p\u00e9riph\u00e9rique\n:param n: Le nombre d'octets \u00e0 lire\n:param repeat: Si ``True``, aucun bit d'arr\u00eat ne sera envoy\u00e9\n:return: The bytes read\"\"\"\n    ...\n\ndef write(addr: int, buf: ReadableBuffer, repeat: bool=False) -> None:\n    \"\"\"\u00c9crire des octets sur un p\u00e9riph\u00e9rique.\n\nExample: ``i2c.write(0x50, bytes([1, 2, 3]))``\n\n:param addr: L'adresse 7-bit du p\u00e9riph\u00e9rique\n:param buf: Un buffer contenant les octets \u00e0 \u00e9crire\n:param repeat: Si ``True``, aucun bit d'arr\u00eat ne sera envoy\u00e9\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/microphone.pyi": "\"\"\"R\u00e9agir \u00e0 du son en utilisant le microphone int\u00e9gr\u00e9 (V2 uniquement).\"\"\"\nfrom typing import Optional, Tuple\nfrom ..microbit import SoundEvent\n\ndef current_event() -> Optional[SoundEvent]:\n    \"\"\"R\u00e9cup\u00e9rer le dernier \u00e9v\u00e9nement sonore enregistr\u00e9\n\nExample: ``microphone.current_event()``\n\n:return: The event, ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.\"\"\"\n    ...\n\ndef was_event(event: SoundEvent) -> bool:\n    \"\"\"V\u00e9rifier si un son a \u00e9t\u00e9 entendu au moins une fois depuis le dernier appel.\n\nExample: ``microphone.was_event(SoundEvent.LOUD)``\n\nThis call clears the sound history before returning.\n\n:param event: L'\u00e9v\u00e9nement \u00e0 v\u00e9rifier, tel que ``SoundEvent.LOUD`` ou ``SoundEvent.QUIET``\n:return: ``True`` if sound was heard at least once since the last call, otherwise ``False``.\"\"\"\n    ...\n\ndef is_event(event: SoundEvent) -> bool:\n    \"\"\"V\u00e9rifier l'\u00e9v\u00e9nement sonore le plus r\u00e9cent d\u00e9tect\u00e9.\n\nExample: ``microphone.is_event(SoundEvent.LOUD)``\n\nThis call does not clear the sound event history.\n\n:param event: L'\u00e9v\u00e9nement \u00e0 v\u00e9rifier, tel que ``SoundEvent.LOUD`` ou ``SoundEvent.QUIET``\n:return: ``True`` if sound was the most recent heard, ``False`` otherwise.\"\"\"\n    ...\n\ndef get_events() -> Tuple[SoundEvent, ...]:\n    \"\"\"R\u00e9cup\u00e9rer l'historique des \u00e9v\u00e9nements sonores en tant que tuple.\n\nExample: ``microphone.get_events()``\n\nThis call clears the sound history before returning.\n\n:return: A tuple of the event history with the most recent event last.\"\"\"\n    ...\n\ndef set_threshold(event: SoundEvent, value: int) -> None:\n    \"\"\"D\u00e9finir le seuil pour un \u00e9v\u00e9nement sonore.\n\nExample: ``microphone.set_threshold(SoundEvent.LOUD, 250)``\n\nA high threshold means the event will only trigger if the sound is very loud (>= 250 in the example).\n\n:param event: Un \u00e9v\u00e9nement sonore, tel que ``SoundEvent.LOUD`` ou ``SoundEvent.QUIET``.\n:param value: Le niveau du seuil dans la plage 0-255.\"\"\"\n    ...\n\ndef sound_level() -> int:\n    \"\"\"Obtenir le niveau de pression acoustique.\n\nExample: ``microphone.sound_level()``\n\n:return: A representation of the sound pressure level in the range 0 to 255.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/speaker.pyi": "\"\"\"Contr\u00f4ler le haut-parleur int\u00e9gr\u00e9 (V2 uniquement).\"\"\"\n\ndef off() -> None:\n    \"\"\"\u00c9teindre le haut-parleur.\n\nExample: ``speaker.off()``\n\nThis does not disable sound output to an edge connector pin.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Activer le haut-parleur.\n\nExample: ``speaker.on()``\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"Communiquer avec les p\u00e9riph\u00e9riques \u00e0 l'aide du bus SPI (Serial Peripheral Interface).\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom ..microbit import pin13, pin14, pin15, MicroBitDigitalPin\n\ndef init(baudrate: int=1000000, bits: int=8, mode: int=0, sclk: MicroBitDigitalPin=pin13, mosi: MicroBitDigitalPin=pin15, miso: MicroBitDigitalPin=pin14) -> None:\n    \"\"\"Initialiser la communication SPI.\n\nExample: ``spi.init()``\n\nFor correct communication, the parameters have to be the same on both communicating devices.\n\n:param baudrate: La vitesse de communication.\n:param bits: La largeur en bits de chaque transfert. Actuellement, seul ``bits=8`` est pris en charge. Cependant, cela peut \u00e9voluer \u00e0 l'avenir.\n:param mode: D\u00e9termine la combinaison de la polarit\u00e9 et de la phase de l'horloge. - `voir le tableau en ligne <https://microbit-micropython.readthedocs.io/en/v2-docs/spi.html#microbit.spi.init>`_.\n:param sclk: Broche sclk (13 par d\u00e9faut)\n:param mosi: Broche mosi (15 par d\u00e9faut)\n:param miso: Broche miso (14 par d\u00e9faut)\"\"\"\n    ...\n\ndef read(nbytes: int) -> bytes:\n    \"\"\"Lire des octets.\n\nExample: ``spi.read(64)``\n\n:param nbytes: Nombre maximal d'octets \u00e0 lire.\n:return: The bytes read.\"\"\"\n    ...\n\ndef write(buffer: ReadableBuffer) -> None:\n    \"\"\"\u00c9crire des octets sur le bus.\n\nExample: ``spi.write(bytes([1, 2, 3]))``\n\n:param buffer: Un buffer \u00e0 partir duquel lire les donn\u00e9es.\"\"\"\n    ...\n\ndef write_readinto(out: WriteableBuffer, in_: ReadableBuffer) -> None:\n    \"\"\"Ecrire le buffer ``out`` sur le bus et lire toute r\u00e9ponse dans le buffer ``in_``.\n\nExample: ``spi.write_readinto(out_buffer, in_buffer)``\n\nThe length of the buffers should be the same. The buffers can be the same object.\n\n:param out: Le buffer vers lequel \u00e9crire une r\u00e9ponse.\n:param in_: Le buffer depuis lequel lire les donn\u00e9es.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"Communiquer avec un p\u00e9riph\u00e9rique \u00e0 l'aide d'une interface s\u00e9rie.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom ..microbit import MicroBitDigitalPin\nfrom typing import Optional, Union\nODD: int\n\"\"\"Parit\u00e9 impaire\"\"\"\nEVEN: int\n\"\"\"Parit\u00e9 paire\"\"\"\n\ndef init(baudrate: int=9600, bits: int=8, parity: Optional[int]=None, stop: int=1, tx: Optional[MicroBitDigitalPin]=None, rx: Optional[MicroBitDigitalPin]=None) -> None:\n    \"\"\"Initialiser la communication s\u00e9rie.\n\nExample: ``uart.init(115200, tx=pin0, rx=pin1)``\n\n:param baudrate: La vitesse de communication.\n:param bits: La taille des octets transmis. micro:bit ne prend en charge que 8.\n:param parity: Comment la parit\u00e9 est v\u00e9rifi\u00e9e, ``None``, ``uart.ODD`` ou ``uart.EVEN``.\n:param stop: Le nombre de bits d'arr\u00eat, doit \u00eatre 1 pour micro:bit.\n:param tx: Broche de transmission.\n:param rx: Broche de r\u00e9ception.\n\nInitializing the UART on external pins will cause the Python console on\nUSB to become unaccessible, as it uses the same hardware. To bring the\nconsole back you must reinitialize the UART without passing anything for\n``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\nthat calling ``uart.init(115200)`` is enough to restore the Python console.\n\nFor more details see `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/uart.html>`_.\"\"\"\n    ...\n\ndef any() -> bool:\n    \"\"\"V\u00e9rifier s'il y a des donn\u00e9es en attente.\n\nExample: ``uart.any()``\n\n:return: ``True`` if any data is waiting, else ``False``.\"\"\"\n    ...\n\ndef read(nbytes: Optional[int]=None) -> Optional[bytes]:\n    \"\"\"Lire des octets.\n\nExample: ``uart.read()``\n\n:param nbytes: Si ``nbytes`` est sp\u00e9cifi\u00e9, alors lire au maximum cette quantit\u00e9 d'octets, sinon lire autant d'octets que possible\n:return: A bytes object or ``None`` on timeout\"\"\"\n    ...\n\ndef readinto(buf: WriteableBuffer, nbytes: Optional[int]=None) -> Optional[int]:\n    \"\"\"Lire les octets dans le ``buf``.\n\nExample: ``uart.readinto(input_buffer)``\n\n:param buf: Le buffer dans lequel \u00e9crire.\n:param nbytes: Si ``nbytes`` est sp\u00e9cifi\u00e9, alors lire au maximum cette quantit\u00e9 d'octets, sinon lire ``len(buf)`` octets.\n:return: number of bytes read and stored into ``buf`` or ``None`` on timeout.\"\"\"\n    ...\n\ndef readline() -> Optional[bytes]:\n    \"\"\"Lire une ligne termin\u00e9e par un caract\u00e8re de nouvelle ligne.\n\nExample: ``uart.readline()``\n\n:return: The line read or ``None`` on timeout. The newline character is included in the returned bytes.\"\"\"\n    ...\n\ndef write(buf: Union[bytes, str]) -> Optional[int]:\n    \"\"\"\u00c9crire un buffer sur un bus\n\nExample: ``uart.write('hello world')``\n\n:param buf: Un objet d'octets ou une cha\u00eene de caract\u00e8res.\n:return: The number of bytes written, or ``None`` on timeout.\n\nExamples::\n\n    uart.write('hello world')\n    uart.write(b'hello world')\n    uart.write(bytes([1, 2, 3]))\"\"\"\n    ...",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Optional,\n    Reversible,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n)\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}