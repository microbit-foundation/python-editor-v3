{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]\n    ) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "",
    "/typeshed/stdlib/array.pyi": "from typing import Generic, Iterable, MutableSequence, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode]\n\n_T = TypeVar(\"_T\", int, float)\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(\n        self: array[int],\n        typecode: _IntTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[float],\n        typecode: _FloatTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...\n    ) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n\nArrayType = array\n",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __slots__: str | Iterable[str]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls: Type[_T]) -> _T: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> str | Tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __name__: str\n    __qualname__: str\n    __text_signature__: str | None\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], dict: dict[str, Any], **kwds: Any\n    ) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: Type[_TT],\n        name: str,\n        bases: Tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwds: Any,\n    ) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> list[_TT]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(\n        metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any\n    ) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.UnionType: ...\n        def __ror__(self, t: Any) -> types.UnionType: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(\n        cls: Type[_T],\n        x: str | bytes | SupportsInt | SupportsIndex | _SupportsTrunc = ...,\n    ) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], x: str | bytes | bytearray, base: SupportsIndex\n    ) -> _T: ...\n    def to_bytes(\n        self,\n        length: SupportsIndex,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls,\n        bytes: Iterable[SupportsIndex] | SupportsBytes,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n    @overload\n    def __pow__(\n        self, __x: int, __modulo: int | None = ...\n    ) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(\n        cls: Type[_T], x: SupportsFloat | SupportsIndex | str | bytes | bytearray = ...\n    ) -> _T: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], real: str | SupportsComplex | SupportsIndex | complex\n    ) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...\n    ) -> _T: ...\n    def count(\n        self,\n        x: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self,\n        __suffix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def index(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: str | None = ...) -> str: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    def rfind(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def rstrip(self, __chars: str | None = ...) -> str: ...\n    def split(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def startswith(\n        self,\n        __prefix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __chars: str | None = ...) -> str: ...\n    def upper(self) -> str: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: int | slice) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ByteString | memoryview]) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytes: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray:\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[_T_co | _T, ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(\n        self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n\n# Can we remove this?\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: dict[str, Any]\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls: type[Self]) -> Self: ...\n    @overload\n    def __new__(cls: type[Self], __iterable: Iterable[_T_co]) -> Self: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(\n        self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(\n        self: list[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n    ) -> None: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, x: list[_T]) -> list[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: list[_T]) -> bool: ...\n    def __ge__(self, x: list[_T]) -> bool: ...\n    def __lt__(self, x: list[_T]) -> bool: ...\n    def __le__(self, x: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(\n        self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(\n        cls, __iterable: Iterable[_T], __value: None = ...\n    ) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(\n        self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> _T | _VT: ...\n\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exec(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(\n        self, __function: Callable[[_T], Any], __iterable: Iterable[_T]\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\n@overload\ndef getattr(__o: object, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: object, name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n    def issubclass(\n        __cls: type,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n\nelse:\n    def isinstance(\n        __obj: object, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef max(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef max(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef min(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef min(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIO: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes) -> int: ...\ndef print(\n    *values: object,\n    sep: str | None = ...,\n    end: str | None = ...,\n    file: SupportsWrite[str] | None = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(\n        base: int, exp: int, mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n) -> list[SupportsLessThanT]: ...\n@overload\ndef sorted(\n    __iterable: Iterable[_T],\n    *,\n    key: Callable[[_T], SupportsLessThan],\n    reverse: bool = ...,\n) -> list[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> _T | _S: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> _T | _S: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]\n    ) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Mapping[str, Any] | None = ...,\n    locals: Mapping[str, Any] | None = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(\n        self, *args: object, name: str | None = ..., path: str | None = ...\n    ) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass NotImplementedError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\n",
    "/typeshed/stdlib/errno.pyi": "from typing import Mapping\n\nerrorcode: Mapping[int, str]\n\nEACCES: int\nEADDRINUSE: int\nEAGAIN: int\nEALREADY: int\nEBADF: int\nECONNABORTED: int\nECONNREFUSED: int\nECONNRESET: int\nEEXIST: int\nEHOSTUNREACH: int\nEINPROGRESS: int\nEINVAL: int\nEIO: int\nEISDIR: int\nENOBUFS: int\nENODEV: int\nENOENT: int\nENOMEM: int\nENOTCONN: int\nEOPNOTSUPP: int\nEPERM: int\nETIMEDOUT: int\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Controlar el recolector de basura (rb)\"\"\"\nfrom typing import overload\n\ndef enable() -> None:\n    \"\"\"Activar la recolecci\u00f3n autom\u00e1tica de basura. (habilitado)\"\"\"\n    ...\n\ndef disable() -> None:\n    \"\"\"Desactiva la recolecci\u00f3n autom\u00e1tica de basura. (deshabilitar)\n\nHeap memory can still be allocated,\nand garbage collection can still be initiated manually using ``gc.collect``.\"\"\"\n\ndef collect() -> None:\n    \"\"\"Ejecuta una recolecci\u00f3n de basura. (recoger)\"\"\"\n    ...\n\ndef mem_alloc() -> int:\n    \"\"\"Obtiene el n\u00famero de bytes asignados a la RAM din\u00e1mica. (memoria asignada)\n\n:return: The number of bytes allocated.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\ndef mem_free() -> int:\n    \"\"\"Obtiene el n\u00famero de bytes de la RAM din\u00e1mica disponible o -1 si se desconoce esta cantidad. (memoria libre)\n\n:return: The number of bytes free.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\n@overload\ndef threshold() -> int:\n    \"\"\"Consulta el umbral de asignaci\u00f3n de GC (recolector de basura) adicional. (l\u00edmite)\n\n:return: The GC allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\"\"\"\n    ...\n\n@overload\ndef threshold(amount: int) -> None:\n    \"\"\"Establece el umbral de asignaci\u00f3n de GC (recolector de basura) adicional. (l\u00edmite)\n\nNormally, a collection is triggered only when a new allocation\ncannot be satisfied, i.e. on an  out-of-memory (OOM) condition.\nIf this function is called, in addition to OOM, a collection\nwill be triggered each time after ``amount`` bytes have been\nallocated (in total, since the previous time such an amount of bytes\nhave been allocated). ``amount`` is usually specified as less than the\nfull heap size, with the intention to trigger a collection earlier than when the\nheap becomes exhausted, and in the hope that an early collection will prevent\nexcessive memory fragmentation. This is a heuristic measure, the effect\nof which will vary from application to application, as well as\nthe optimal value of the ``amount`` parameter.\n\nA value of -1 means a disabled allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\n\n:param amount: (cantidad) N\u00famero de bytes despu\u00e9s de los cuales se debe activar una recolecci\u00f3n de basura.\"\"\"\n    ...",
    "/typeshed/stdlib/log.pyi": "\"\"\"Registra datos en el micro:bit V2. (registrar)\"\"\"\nfrom typing import Literal, Mapping, Optional, Union, overload\nMILLISECONDS = 1\n\"\"\"Formato de marca temporal en milisegundos. (milisegundos)\"\"\"\nSECONDS = 10\n\"\"\"Formato de marca temporal en segundos. (segundos)\"\"\"\nMINUTES = 600\n\"\"\"Formato de marca temporal en minutos. (minutos)\"\"\"\nHOURS = 36000\n\"\"\"Formato de marca temporal en horas. (horas)\"\"\"\nDAYS = 864000\n\"\"\"Formato de marca temporal en d\u00edas. (d\u00edas)\"\"\"\n\ndef set_labels(*labels: str, timestamp: Optional[Literal[1, 10, 36000, 864000]]=SECONDS) -> None:\n    \"\"\"Configura la cabecera del archivo de registro. (configurar etiquetas)\n\nExample: ``log.set_labels('X', 'Y', 'Z', timestamp=log.MINUTES)``\n\nIdeally this function should be called a single time, before any data is\nlogged, to configure the data table header once.\n\nIf a log file already exists when the program starts, or if this function\nis called multiple times, it will check the labels already defined in the\nlog file. If this function call contains any new labels not already\npresent, it will generate a new header row with the additional columns.\n\nBy default the first column contains a timestamp for each row. The time\nunit can be selected via the timestamp argument.\n\n:param *labels: (*Etiquetas) Cualquier n\u00famero de argumentos posicionales, cada uno correspondiente a una entrada en el encabezado del registro.\n:param timestamp: (marca de tiempo) Selecciona la unidad de marca de tiempo que se a\u00f1adir\u00e1 autom\u00e1ticamente como la primera columna de cada fila. Los valores de la marca de tiempo pueden ser ``log.MILLISECONDS``, ``log.SECONDS``, ``log.MINUTES``, ``log.HOURS``, ``log.DAYS`` o ``None`` para desactivar la marca de tiempo. El valor por defecto es ``log.SECONDS``.\"\"\"\n    ...\n\n@overload\ndef add(data_dictionary: Optional[Mapping[str, Union[str, int, float]]]) -> None:\n    \"\"\"A\u00f1ade una fila de datos al registro pasando un diccionario de cabeceras y valores. (a\u00f1adir)\n\nExample: ``log.add({ 'temp': temperature() })``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\n\n:param data_dictionary: (diccionario de datos) Los datos que se registrar\u00e1n como un diccionario con una clave para cada cabecera.\"\"\"\n    ...\n\n@overload\ndef add(**kwargs: Union[str, int, float]) -> None:\n    \"\"\"A\u00f1ade una fila de datos al registro usando argumentos de palabra clave. (a\u00f1adir)\n\nExample: ``log.add(temp=temperature())``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\"\"\"\n    ...\n\ndef delete(full=False):\n    \"\"\"Elimina el contenido del registro, incluyendo las cabeceras. (eliminar)\n\nExample: ``log.delete()``\n\nTo add the log headers again the ``set_labels`` function should to be called after this function.\n\nThere are two erase modes; \u201cfull\u201d completely removes the data from the physical storage,\nand \u201cfast\u201d invalidates the data without removing it.\n\n:param full: (completo) ``True`` selecciona un borrador \u201ccompleto\u201d y ``False`` selecciona el m\u00e9todo de borrado \u201cr\u00e1pido\u201d.\"\"\"\n    ...\n\ndef set_mirroring(serial: bool):\n    \"\"\"Configura la duplicaci\u00f3n de la actividad de registro de datos en la salida serie. (configurar replicaci\u00f3n)\n\nExample: ``log.set_mirroring(True)``\n\nSerial mirroring is disabled by default. When enabled, it will print to serial each row logged into the log file.\n\n:param serial: (serie) ``True`` habilita la reproducci\u00f3n de datos en la salida de serie.\"\"\"\n    ...",
    "/typeshed/stdlib/love.pyi": "def badaboom() -> None: ...\n",
    "/typeshed/stdlib/machine.pyi": "\"\"\"Utilidades de bajo nivel. (m\u00e1quina)\"\"\"\nfrom typing import Any\nfrom .microbit import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Obtiene una cadena de bytes con un identificador \u00fanico de una placa. (id \u00fanico)\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Restablece el dispositivo de una forma similar a pulsar el bot\u00f3n externo RESET. (restablecer)\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Obtiene la frecuencia de la CPU en hercios. (frec)\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"Desactiva las solicitudes de interrupci\u00f3n. (desactivar irq)\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"Reactiva las solicitudes de interrupci\u00f3n. (activar irq)\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: (estado) Valor devuelto por la llamada m\u00e1s reciente a la funci\u00f3n ``disable_irq``.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Cronometra el estado de un pin. (cronometrar estado us)\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: Pin a usar\n:param pulse_level: (nivel de estado) 0 para cronometrar un estado bajo o 1 para un estado alto\n:param timeout_us: (tiempo de espera us) Tiempo de espera en microsegundos\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"Clase para las vistas de memoria ``mem8``, ``mem16`` y ``mem32``.\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Accede a un valor de la memoria. (obtener elemento)\n\n:param address: (direcci\u00f3n) La direcci\u00f3n de memoria.\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"Establece un valor en la direcci\u00f3n dada. (configurar elemento)\n\n:param address: (direcci\u00f3n) La direcci\u00f3n de memoria.\n:param value: (valor) El valor entero a establecer.\"\"\"\n        ...\nmem8: mem\n\"\"\"Vista de memoria de 8 bits (byte).\"\"\"\nmem16: mem\n\"\"\"Vista de memoria de 16 bits.\"\"\"\nmem32: mem\n\"\"\"Vista de memoria de 32 bits.\"\"\"",
    "/typeshed/stdlib/math.pyi": "\"\"\"Funciones matem\u00e1ticas. (matem\u00e1ticas)\"\"\"\nfrom typing import Tuple\n\ndef acos(x: float) -> float:\n    \"\"\"Calcula el inverso del coseno.\n\nExample: ``math.acos(1)``\n\n:param x: Un n\u00famero\n:return: The inverse cosine of ``x``\"\"\"\n    ...\n\ndef asin(x: float) -> float:\n    \"\"\"Calcula el inverso del seno. (asen)\n\nExample: ``math.asin(0)``\n\n:param x: Un n\u00famero\n:return: The inverse sine of ``x``\"\"\"\n    ...\n\ndef atan(x: float) -> float:\n    \"\"\"Calcula el inverso de la tangente.\n\nExample: ``math.atan(0)``\n\n:param x: Un n\u00famero\n:return: The inverse tangent of ``x``\"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float:\n    \"\"\"Calcula el valor principal del inverso de la tangente de ``y/x``.\n\nExample: ``math.atan2(0, -1)``\n\n:param y: Un n\u00famero\n:param x: Un n\u00famero\n:return: The principal value of the inverse tangent of ``y/x``\"\"\"\n    ...\n\ndef ceil(x: float) -> float:\n    \"\"\"Redondea un n\u00famero hacia el infinito positivo. (hacia arriba)\n\nExample: ``math.ceil(0.1)``\n\n:param x: Un n\u00famero\n:return: ``x`` rounded towards positive infinity.\"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float:\n    \"\"\"Calcula ``x`` con el signo de ``y``.\n\nExample: ``math.copysign(1, -1)``\n\n:param x: Un n\u00famero\n:param y: Procedencia del signo para el valor que devuelve\n:return: ``x`` with the sign of ``y``\"\"\"\n    ...\n\ndef cos(x: float) -> float:\n    \"\"\"Calcula el coseno de ``x``.\n\nExample: ``math.cos(0)``\n\n:param x: Un n\u00famero\n:return: The cosine of ``x``\"\"\"\n    ...\n\ndef degrees(x: float) -> float:\n    \"\"\"Convierte radianes a grados. (grados)\n\nExample: ``math.degrees(2 * math.pi)``\n\n:param x: Un valor en radianes\n:return: The value converted to degrees\"\"\"\n    ...\n\ndef exp(x: float) -> float:\n    \"\"\"Calcular el exponencial de ``x``.\n\nExample: ``math.exp(1)``\n\n:param x: Un n\u00famero\n:return: The exponential of ``x``.\"\"\"\n    ...\n\ndef fabs(x: float) -> float:\n    \"\"\"Devuelve el valor absoluto de ``x``.\n\nExample: ``math.fabs(-0.1)``\n\n:param x: Un n\u00famero\n:return: The absolute value of ``x``\"\"\"\n    ...\n\ndef floor(x: float) -> int:\n    \"\"\"Redondea un n\u00famero hacia el infinito negativo. (hacia abajo)\n\nExample: ``math.floor(0.9)``\n\n:param x: Un n\u00famero\n:return: ``x`` rounded towards negative infinity.\"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float:\n    \"\"\"Calcula el resto de ``x/y``.\n\nExample: ``math.fmod(10, 3)``\n\n:param x: El numerador\n:param y: El denominador\"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]:\n    \"\"\"Descompone un n\u00famero de coma flotante en su mantisa y exponente.\n\nExample: ``mantissa, exponent = math.frexp(2)``\n\nThe returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\nexactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\nthe relation ``0.5 <= abs(m) < 1`` holds.\n\n:param x: Un n\u00famero de coma flotante\n:return: A tuple of length two containing its mantissa then exponent\"\"\"\n    ...\n\ndef isfinite(x: float) -> bool:\n    \"\"\"Comprueba si un valor es finito. (esfinito)\n\nExample: ``math.isfinite(float('inf'))``\n\n:param x: Un n\u00famero.\n:return: ``True`` if ``x`` is finite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isinf(x: float) -> bool:\n    \"\"\"Compruebe si un valor es infinito. (esinf)\n\nExample: ``math.isinf(float('-inf'))``\n\n:param x: Un n\u00famero.\n:return: ``True`` if ``x`` is infinite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isnan(x: float) -> bool:\n    \"\"\"Comprueba si un valor no es un n\u00famero (NaN, not-a-number en ingl\u00e9s). (esnan)\n\nExample: ``math.isnan(float('nan'))``\n\n:param x: Un n\u00famero\n:return: ``True`` if ``x`` is not-a-number (NaN), ``False`` otherwise.\"\"\"\n    ...\n\ndef ldexp(x: float, exp: int) -> float:\n    \"\"\"Calcula ``x * (2**exp)``.\n\nExample: ``math.ldexp(0.5, 2)``\n\n:param x: Un n\u00famero\n:param exp: Exponente entero\n:return: ``x * (2**exp)``\"\"\"\n    ...\n\ndef log(x: float, base: float=e) -> float:\n    \"\"\"Calcula el logaritmo de ``x`` en la base dada (por defecto, el logaritmo natural). (registrar)\n\nExample: ``math.log(math.e)``\n\nWith one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as ``log(x)/log(base)``.\n\n:param x: Un n\u00famero\n:param base: La base a usar\n:return: The natural logarithm of ``x``\"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]:\n    \"\"\"Calcula la parte fraccionaria y entera de ``x``.\n\nExample: ``fractional, integral = math.modf(1.5)``\n\n:param x: Un n\u00famero\n:return: A tuple of two floats representing the fractional then integral parts of ``x``.\n\nBoth the fractional and integral values have the same sign as ``x``.\"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float:\n    \"\"\"Devuelve ``x`` elevado a ``y``.\n\nExample: ``math.pow(4, 0.5)``\n\n:param x: Un n\u00famero\n:param y: El exponente\n:return: ``x`` to the power of ``y``\"\"\"\n    ...\n\ndef radians(x: float) -> float:\n    \"\"\"Convierte grados a radianes. (radianes)\n\nExample: ``math.radians(360)``\n\n:param x: Un valor en grados\n:return: The value converted to radians\"\"\"\n    ...\n\ndef sin(x: float) -> float:\n    \"\"\"Calcula el seno de ``x``. (sen)\n\nExample: ``math.sin(math.pi/2)``\n\n:param x: Un n\u00famero\n:return: The sine of ``x``\"\"\"\n    ...\n\ndef sqrt(x: float) -> float:\n    \"\"\"Calcula la ra\u00edz cuadrada de ``x``.\n\nExample: ``math.sqrt(4)``\n\n:param x: Un n\u00famero\n:return: The square root of ``x``\"\"\"\n    ...\n\ndef tan(x: float) -> float:\n    \"\"\"Calcula la tangente de ``x``.\n\nExample: ``math.tan(0)``\n\n:param x: Un n\u00famero\n:return: The tangent of ``x``.\"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\"Redondea un n\u00famero hacia 0.\n\nExample: ``math.trunc(-0.9)``\n\n:param x: Un n\u00famero\n:return: ``x`` rounded towards zero.\"\"\"\n    ...\ne: float\n\"\"\"Base del logaritmo natural\"\"\"\npi: float\n\"\"\"La relaci\u00f3n entre la longitud de una circunferencia y su di\u00e1metro\"\"\"",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"Componentes internos de MicroPython.\"\"\"\nfrom typing import Any, TypeVar, overload\n_T = TypeVar('_T')\n\ndef const(expr: _T) -> _T:\n    \"\"\"Se usa para declarar que la expresi\u00f3n es una constante para que el compilador pueda\noptimizarla.\n\nThe use of this function should be as follows::\n\n    from micropython import const\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\nConstants declared this way are still accessible as global variables from\noutside the module they are declared in. On the other hand, if a constant\nbegins with an underscore then it is hidden, it is not available as a\nglobal variable, and does not take up any memory during execution.\n\n:param expr: Una expresi\u00f3n constante.\"\"\"\n    ...\n\n@overload\ndef opt_level() -> int:\n    \"\"\"Obtiene el nivel actual de optimizaci\u00f3n para la compilaci\u00f3n de scripts. (nivel de opt)\n\nExample: ``micropython.opt_level()``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\n:return: An integer representing the current level.\"\"\"\n    ...\n\n@overload\ndef opt_level(level: int) -> None:\n    \"\"\"Establece el nivel de optimizaci\u00f3n para la posterior compilaci\u00f3n de scripts. (nivel de opt)\n\nExample: ``micropython.opt_level(1)``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\nThe default optimisation level is usually level 0.\n\n:param level: (nivel) Un entero que representa el nivel de optimizaci\u00f3n.\"\"\"\n    ...\n\ndef mem_info(verbose: Any=None) -> None:\n    \"\"\"Imprime informaci\u00f3n sobre la memoria usada en este momento. (info de mem)\n\nExample: ``micropython.mem_info()``\n\n:param verbose: Si se pasa el argumento ``verbose``, se imprime informaci\u00f3n adicional.\"\"\"\n    ...\n\ndef qstr_info(verbose: Any=None) -> None:\n    \"\"\"Imprime informaci\u00f3n sobre las cadenas internadas en este momento. (info de cad actual)\n\nExample: ``micropython.qstr_info()``\n\n:param verbose: Si se pasa el argumento ``verbose``, se imprime informaci\u00f3n adicional.\n\nThe information that is printed is implementation dependent, but currently\nincludes the number of interned strings and the amount of RAM they use.  In\nverbose mode it prints out the names of all RAM-interned strings.\"\"\"\n    ...\n\ndef stack_use() -> int:\n    \"\"\"Devuelve un entero que representa la cantidad de pila que se est\u00e1 usando en este momento. (pila usada)\n\nExample: ``micropython.stack_use()``\n\nThe absolute value of this is not particularly useful, rather it\nshould be used to compute differences in stack usage at different points.\n\n:return: An integer representing current stack use.\"\"\"\n    ...\n\ndef heap_lock() -> None:\n    \"\"\"Bloquea el mont\u00f3n. (bloquear mont\u00f3n)\n\nExample: ``micropython.heap_lock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef heap_unlock() -> None:\n    \"\"\"Desbloquea el mont\u00f3n. (desbloquear el mont\u00f3n)\n\nExample: ``micropython.heap_unlock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"Establece qu\u00e9 car\u00e1cter lanzar\u00e1 una excepci\u00f3n ``KeyboardInterrupt``. (intr tecl)\n\nExample: ``micropython.kbd_intr(-1)``\n\n:param chr: (car) C\u00f3digo de car\u00e1cter que lanzar\u00e1 la interrupci\u00f3n o -1 para desactivar la captura de Ctrl + C.\n\nBy default this is set to 3 during script execution, corresponding to Ctrl-C.\nPassing -1 to this function will disable capture of Ctrl-C, and passing 3\nwill restore it.\n\nThis function can be used to prevent the capturing of Ctrl-C on the\nincoming stream of characters that is usually used for the REPL, in case\nthat stream is used for other purposes.\"\"\"\n    ...",
    "/typeshed/stdlib/music.pyi": "\"\"\"Crear y reproducir melod\u00edas. (m\u00fasica)\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .microbit import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"Melod\u00eda: apertura de la \"Sinfon\u00eda n.\u00ba 5 en do menor\" de Beethoven.\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"Melod\u00eda: fragmento inicial del cl\u00e1sico Ragtime de Scott Joplin \u201cThe Entertainer\u201d.\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"Melod\u00eda: apertura del primer \"Preludio en do mayor\" de los 48 Preludios y Fugas de J. S. Bach. (preludio)\"\"\"\nODE: Tuple[str, ...]\n\"\"\"Melod\u00eda: tema \u201cOda a la alegr\u00eda\u201d de la \"Sinfon\u00eda n.\u00ba 9 en re menor\" de Beethoven. (oda)\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"Melod\u00eda: el tema de Nyan Cat (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"Melod\u00eda: algo que suena como un tono de llamada de un tel\u00e9fono m\u00f3vil. (tono de llamada)\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"Melod\u00eda: una l\u00ednea de bajo funky para agentes secretos y maestros criminales.\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"Melod\u00eda: \"walking bass\" con un blues boogie-woogie de 12 compases.\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"Melod\u00eda: \u201cCumplea\u00f1os feliz\u201d (cumplea\u00f1os)\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"Melod\u00eda: coro nupcial de la \u00f3pera de Wagner \"Lohengrin\". (boda)\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"Melod\u00eda: \u201cMarcha f\u00fanebre\u201d, conocida tambi\u00e9n como \"Sonata para piano n.\u00ba 2 en si bemol menor, Op. 35\" de Fr\u00e9d\u00e9ric Chopin.\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"Melod\u00eda: un fragmento divertido que representa que se ha hecho un chiste. (remate)\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"Melod\u00eda: la marcha de John Philip Sousa \u201cLiberty Bell\u201d, tambi\u00e9n conocida por ser el tema del \u201cMonty Python Flying Circus\u201d (de donde obtiene su nombre el lenguaje de programaci\u00f3n Python).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"Melod\u00eda: entrada de un malote en la \u00e9poca del cine mudo. (malote)\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"Melod\u00eda: escena de persecuci\u00f3n en la \u00e9poca del cine mudo. (persecuci\u00f3n)\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"Melod\u00eda: una se\u00f1al corta para indicar que algo ha pasado.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"Melod\u00eda: un tromb\u00f3n muy triste.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"Melod\u00eda: para usar en un juego, indicando un movimiento ascendente. (saltar arriba)\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"Melod\u00eda: para usar en un juego, indicando un movimiento descendente. (saltar abajo)\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"Melod\u00eda: una fanfarria para indicar un logro desbloqueado. (subida de potencia)\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"Melod\u00eda: una fanfarria triste para indicar un logro perdido. (bajada de potencia)\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"Establece el ritmo aproximado de la reproducci\u00f3n. (configurar tempo)\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: (tics) El n\u00famero de tics que constituyen un ritmo.\n:param bpm: Un entero que determina el n\u00famero de compases por minuto.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"Obtiene el ritmo actual como una tupla de enteros: ``(ticks, bpm)``. (obtener tempo)\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Reproduce m\u00fasica. (reproducir)\n\nExample: ``music.play(music.NYAN)``\n\n:param music: (m\u00fasica) m\u00fasica especificada en `una notaci\u00f3n especial <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: pin de salida para usar con un altavoz externo (por defecto ``pin0``), ``None`` para que no haya sonido.\n:param wait: (esperar) Si ``wait`` se configura como ``True`` (verdadero), esta funci\u00f3n estar\u00e1 bloqueando.\n:param loop: (bucle) Si ``loop`` se configura como ``True`` (verdadero), la melod\u00eda se repite hasta que se llama a ``stop`` o se interrumpe la llamada de bloqueo.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Reproduce una nota. (tono)\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: (frecuencia) Una frecuencia entera\n:param duration: (duraci\u00f3n) La duraci\u00f3n en milisegundos. Si es negativa, el sonido continuar\u00e1 hasta la siguiente llamada o una llamada a ``stop``.\n:param pin: Pin de salida opcional (por defecto, ``pin0``).\n:param wait: (esperar) Si ``wait`` se configura como ``True`` (verdadero), esta funci\u00f3n estar\u00e1 bloqueando.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Detiene la reproducci\u00f3n de toda la m\u00fasica en el altavoz integrado y en cualquier pin que est\u00e9 emitiendo sonido. (detener)\n\nExample: ``music.stop()``\n\n:param pin: Se puede proporcionar un argumento opcional para especificar un pin; por ejemplo, ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Restablece los valores de \"ticks\", \"bpm\", \"duration\" y \"octave\" a sus valores por defecto. (restablecer)\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Tiras de LED RGB y RGBW accesibles individualmente.\"\"\"\nfrom .microbit import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"Inicializa una nueva tira de LED NeoPixel controlada a trav\u00e9s de un pin.\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: El pin que controla la tira NeoPixel.\n:param n: El n\u00famero de LED NeoPixel de la tira.\n:param bpp: Bytes por p\u00edxel. Para compatibilidad de neop\u00edxeles RGBW, pasa 4 en lugar del valor predeterminado de 3 para RGB y GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Borrar todos los p\u00edxeles. (borrar)\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"Muestra los p\u00edxeles. (mostrar)\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Muestra los p\u00edxeles (solo micro:bit V2). (escribir)\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Colorea todos los p\u00edxeles con un valor RGB/RGBW dado (solo micro:bit V2). (llenar)\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: (color) Una tupla de la misma longitud que el n\u00famero de bytes por p\u00edxel (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"Establece el color de un p\u00edxel. (configurar elemento)\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: (clave) El n\u00famero de p\u00edxel.\n:param value: (valor) El color.\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"Obtiene el color de un p\u00edxel. (obtener elemento)\n\nExample: ``r, g, b = np[0]``\n\n:param key: (clave) El n\u00famero de p\u00edxel.\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"Obtiene la longitud de esta tira de p\u00edxeles. (lon)\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "\"\"\"Acceder al sistema de archivos. (so)\"\"\"\nfrom typing import Tuple\nfrom typing import List\n\ndef listdir() -> List[str]:\n    \"\"\"Lista los archivos.\n\nExample: ``os.listdir()``\n\n:return: A list of the names of all the files contained within the local\npersistent on-device file system.\"\"\"\n    ...\n\ndef remove(filename: str) -> None:\n    \"\"\"Elimina un archivo. (eliminar)\n\nExample: ``os.remove('data.txt')``\n\n:param filename: (nombre del archivo) El archivo a eliminar.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n    ...\n\ndef size(filename: str) -> int:\n    \"\"\"Devuelve el tama\u00f1o de un archivo. (tama\u00f1o)\n\nExample: ``os.size('data.txt')``\n\n:param filename: (nombre del archivo) El archivo\n:return: The size in bytes.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n\nclass uname_result(Tuple[str, str, str, str, str]):\n    \"\"\"Resultado de ``os.uname()`` (resultado de nombreu)\"\"\"\n    sysname: str\n    \"\"\"Nombre del sistema operativo. (nombre del sistema)\"\"\"\n    nodename: str\n    \"\"\"Nombre de la m\u00e1quina en la red (definida por la implementaci\u00f3n). (nombre del nodo)\"\"\"\n    release: str\n    \"\"\"Versi\u00f3n de lanzamiento del sistema operativo. (lanzamiento)\"\"\"\n    version: str\n    \"\"\"Versi\u00f3n del sistema operativo. (versi\u00f3n)\"\"\"\n    machine: str\n    \"\"\"Identificador de hardware. (m\u00e1quina)\"\"\"\n\ndef uname() -> uname_result:\n    \"\"\"Devuelve informaci\u00f3n que identifica el sistema operativo actual. (nombreu)\n\nExample: ``os.uname()``\n\nThe return value is an object with five attributes:\n\n- ``sysname`` - operating system name\n- ``nodename`` - name of machine on network (implementation-defined)\n- ``release`` - operating system release\n- ``version`` - operating system version\n- ``machine`` - hardware identifier\n\nThere is no underlying operating system in MicroPython. As a result the\ninformation returned by the ``uname`` function is mostly useful for\nversioning details.\"\"\"\n    ...",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "\"\"\"Comunicarse entre micro:bits con la radio incorporada.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom typing import Optional, Tuple\nRATE_1MBIT: int\n\"\"\"Constante utilizada para indicar un rendimiento de 1 Mb por segundo. (tasa de 1 mbit)\"\"\"\nRATE_2MBIT: int\n\"\"\"Constante utilizada para indicar un rendimiento de 2 Mb por segundo. (tasa de 2 mbit)\"\"\"\n\ndef on() -> None:\n    \"\"\"Enciende la radio. (encender)\n\nExample: ``radio.on()``\n\nThis needs to be explicitly called since the radio draws power and takes\nup memory that you may otherwise need.\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Apaga la radio, ahorrando energ\u00eda y memoria. (apagado)\n\nExample: ``radio.off()``\"\"\"\n    ...\n\ndef config(length: int=32, queue: int=3, channel: int=7, power: int=6, address: int=1969383796, group: int=0, data_rate: int=RATE_1MBIT) -> None:\n    \"\"\"Configura la radio.\n\nExample: ``radio.config(group=42)``\n\nThe default configuration is suitable for most use.\n\n:param length: (longitud) (valor predeterminado = 32) define la longitud m\u00e1xima, en bytes, de un mensaje enviado a trav\u00e9s de la radio.\nPuede tener hasta 251 bytes de largo (254 - 3 bytes para pre\u00e1mbulos S0, LENGTH y S1).\n:param queue: (cola) (valor predeterminado = 3) especifica el n\u00famero de mensajes que pueden almacenarse en la cola de mensajes entrantes.\nSi no quedan espacios en la cola para los mensajes entrantes, el mensaje entrante ser\u00e1 eliminado.\n:param channel: (canal) (valor predeterminado = 7) un valor entero de 0 a 83 (inclusive) que define un \"canal\" arbitrario en el cual la radio est\u00e1 sintonizada.\nLos mensajes se enviar\u00e1n a trav\u00e9s de este canal y solo los mensajes recibidos a trav\u00e9s de este canal se pondr\u00e1n en la cola de mensajes entrantes. Cada paso es de 1 MHz de ancho, basado en 2400 MHz.\n:param power: (potencia) (valor predeterminado = 6) es un valor entero de 0 a 7 (inclusive) para indicar la fuerza de la se\u00f1al usada al transmitir un mensaje.\nCuanto m\u00e1s alto sea el valor, m\u00e1s fuerte es la se\u00f1al, pero m\u00e1s energ\u00eda consume el dispositivo. La numeraci\u00f3n se traduce a posiciones en la siguiente lista de valores de dBm (decibelio-milivatio): -30, -20, -16, -12, -8, -4, 0, 4.\n:param address: (direcci\u00f3n) (valor predeterminado = 0x75626974) un nombre arbitrario, expresado como una direcci\u00f3n de 32 bits, que se usa para filtrar los paquetes entrantes a nivel de hardware, manteniendo solo aquellos que coincidan con la direcci\u00f3n que has establecido.\nEl valor predeterminado utilizado por otras plataformas relacionadas con el micro:bit es la configuraci\u00f3n predeterminada utilizada aqu\u00ed.\n:param group: (grupo) (valor predeterminado = 0) un valor de 8 bits (0 - 255) usado con el valor de ``address`` al filtrar mensajes.\nConceptualmente, \"address\" (direcci\u00f3n) es como una direcci\u00f3n de casa u oficina y \"group\" (grupo) es la persona que est\u00e1 en esa direcci\u00f3n y a la que quieres enviar un mensaje.\n:param data_rate: (tasa de datos) (valor predeterminado = ``radio.RATE_1MBIT``) indica la velocidad a la que se lleva a cabo el procesamiento de datos.\nPuede ser una de las siguientes constantes definidas en el m\u00f3dulo ``radio``: ``RATE_250KBIT``, ``RATE_1MBIT`` o ``RATE_2MBIT``.\n\nIf ``config`` is not called then the defaults described above are assumed.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Restablece la configuraci\u00f3n a sus valores predeterminados. (restablecer)\n\nExample: ``radio.reset()``\n\nThe defaults as as per the ``config`` function above.\"\"\"\n    ...\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Env\u00eda un mensaje que contiene bytes. (enviar bytes)\n\nExample: ``radio.send_bytes(b'hello')``\n\n:param message: (mensaje) Los bytes a enviar.\"\"\"\n    ...\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Recibe el siguiente mensaje entrante en la cola de mensajes. (recibir bytes)\n\nExample: ``radio.receive_bytes()``\n\n:return: The message bytes if any, otherwise ``None``.\"\"\"\n    ...\n\ndef receive_bytes_into(buffer: WriteableBuffer) -> Optional[int]:\n    \"\"\"Copia el siguiente mensaje entrante de la cola de mensajes en un b\u00fafer. (recibir bytes en)\n\nExample: ``radio.receive_bytes_info(buffer)``\n\n:param buffer: (b\u00fafer) El b\u00fafer de destino. El mensaje se trunca si es m\u00e1s grande que el b\u00fafer.\n:return: ``None`` if there are no pending messages, otherwise it returns the length of the message (which might be more than the length of the buffer).\"\"\"\n    ...\n\ndef send(message: str) -> None:\n    \"\"\"Env\u00eda una cadena de mensaje. (enviar)\n\nExample: ``radio.send('hello')``\n\nThis is the equivalent of ``radio.send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\nprepended to the front (to make it compatible with other platforms that target the micro:bit).\n\n:param message: (mensaje) La cadena a enviar.\"\"\"\n    ...\n\ndef receive() -> Optional[str]:\n    \"\"\"Funciona exactamente del mismo modo que ``receive_bytes``, pero devuelve lo que se envi\u00f3. (recibir)\n\nExample: ``radio.receive()``\n\nEquivalent to ``str(receive_bytes(), 'utf8')`` but with a check that the the first\nthree bytes are ``b'\\x01\\x00\\x01'`` (to make it compatible with other platforms that\nmay target the micro:bit).\n\n:return: The message with the prepended bytes stripped and converted to a string.\n\nA ``ValueError`` exception is raised if conversion to string fails.\"\"\"\n    ...\n\ndef receive_full() -> Optional[Tuple[bytes, int, int]]:\n    \"\"\"Devuelve una tupla de tres valores que representan el siguiente mensaje entrante de la cola de mensajes. (recibir completo)\n\nExample: ``radio.receive_full()``\n\nIf there are no pending messages then ``None`` is returned.\n\nThe three values in the tuple represent:\n\n- the next incoming message on the message queue as bytes.\n- the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n- a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\nFor example::\n\n    details = radio.receive_full()\n    if details:\n        msg, rssi, timestamp = details\n\nThis function is useful for providing information needed for triangulation\nand/or trilateration with other micro:bit devices.\n\n:return: ``None`` if there is no message, otherwise a tuple of length three with the bytes, strength and timestamp values.\"\"\"\n    ...",
    "/typeshed/stdlib/random.pyi": "\"\"\"Generar n\u00fameros aleatorios. (aleatorio)\"\"\"\nfrom typing import TypeVar, Sequence, Union, overload\n\ndef getrandbits(n: int) -> int:\n    \"\"\"Genera un entero con ``n`` bits aleatorios.\n\nExample: ``random.getrandbits(1)``\n\n:param n: Un valor entre 1 - 30 (inclusive).\"\"\"\n    ...\n\ndef seed(n: int) -> None:\n    \"\"\"Inicializa el generador de n\u00fameros aleatorios. (semilla)\n\nExample: ``random.seed(0)``\n\n:param n: La semilla como un n\u00famero entero\n\nThis will give you reproducibly deterministic randomness from a given starting\nstate (``n``).\"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int:\n    \"\"\"Elige un entero aleatorio entre ``a`` y ``b`` inclusive. (entero aleatorio)\n\nExample: ``random.randint(0, 9)``\n\n:param a: Valor inicial para el rango (inclusive)\n:param b: Valor final para el rango (inclusive)\n\nAlias for ``randrange(a, b + 1)``.\"\"\"\n    ...\n\n@overload\ndef randrange(stop: int) -> int:\n    \"\"\"Elige un entero seleccionado aleatoriamente desde cero hasta (pero sin incluir) ``stop``. (rango aleatorio)\n\nExample: ``random.randrange(10)``\n\n:param stop: (detener) Valor final para el rango (exclusivo)\"\"\"\n    ...\n\n@overload\ndef randrange(start: int, stop: int, step: int=1) -> int:\n    \"\"\"Elige un elemento seleccionado aleatoriamente de ``range(start, stop, step)``. (rango aleatorio)\n\nExample: ``random.randrange(0, 10)``\n\n:param start: (comenzar) El inicio del rango (inclusive)\n:param stop: (detener) El final del rango (exclusivo)\n:param step: (paso) El paso.\"\"\"\n    ...\n_T = TypeVar('_T')\n\ndef choice(seq: Sequence[_T]) -> _T:\n    \"\"\"Elige un elemento aleatorio de la secuencia no vac\u00eda ``seq``. (elecci\u00f3n)\n\nExample: ``random.choice([Image.HAPPY, Image.SAD])``\n\n:param seq: (sec) Una secuencia.\n\nIf ``seq`` is  empty, raises ``IndexError``.\"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"Genera un n\u00famero de coma flotante aleatorio en el rango [0.0, 1.0). (aleatorio)\n\nExample: ``random.random()``\n\n:return: The random floating point number\"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float:\n    \"\"\"Devuelve un n\u00famero de coma flotante aleatorio entre ``a`` y ``b`` inclusive. (uniforme)\n\nExample: ``random.uniform(0, 9)``\n\n:param a: Valor inicial para el rango (inclusive)\n:param b: Valor final para el rango (inclusive)\"\"\"\n    ...",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Hacer que el micro:bit hable, cante y haga otros sonidos parecidos a la voz. (habla)\"\"\"\nfrom typing import Optional\nfrom .microbit import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Traducir palabras en ingl\u00e9s a fonemas. (traducir)\n\nExample: ``speech.translate('hello world')``\n\n:param words: (palabras) Una cadena de palabras en ingl\u00e9s.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Pronunciar fonemas. (pronunciar)\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemas) La cadena de fonemas a pronunciar\n:param pitch: (tono) Un n\u00famero que representa el tono de la voz\n:param speed: (velocidad) Un n\u00famero que representa la velocidad de la voz\n:param mouth: (boca) Un n\u00famero que representa la boca de la voz\n:param throat: (garganta) Un n\u00famero que representa la garganta de la voz\n:param pin: Se puede usar un argumento opcional para especificar el pin de salida, reemplazando el valor predeterminado de ``pin0``.\nSi no queremos que se reproduzca ning\u00fan sonido, podemos usar ``pin=None``. Solo para el micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Dice palabras en ingl\u00e9s. (decir)\n\nExample: ``speech.say('hello world')``\n\n:param words: (palabras) La cadena de palabras a decir.\n:param pitch: (tono) Un n\u00famero que representa el tono de la voz\n:param speed: (velocidad) Un n\u00famero que representa la velocidad de la voz\n:param mouth: (boca) Un n\u00famero que representa la boca de la voz\n:param throat: (garganta) Un n\u00famero que representa la garganta de la voz\n:param pin: Se puede usar un argumento opcional para especificar el pin de salida, reemplazando el valor predeterminado de ``pin0``.\nSi no queremos que se reproduzca ning\u00fan sonido, podemos usar ``pin=None``. Solo para el micro:bit V2.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Canta fonemas. (cantar)\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemas) La cadena de palabras a cantar.\n:param pitch: (tono) Un n\u00famero que representa el tono de la voz\n:param speed: (velocidad) Un n\u00famero que representa la velocidad de la voz\n:param mouth: (boca) Un n\u00famero que representa la boca de la voz\n:param throat: (garganta) Un n\u00famero que representa la garganta de la voz\n:param pin: Se puede usar un argumento opcional para especificar el pin de salida, reemplazando el valor predeterminado de ``pin0``.\nSi no queremos que se reproduzca ning\u00fan sonido, podemos usar ``pin=None``. Solo para el micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "\"\"\"Empaquetar y desempaquetar tipos de dato primitivos. (estruc)\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom typing import Any, Tuple, Union\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"Obtiene el n\u00famero de bytes necesarios para almacenar el ``fmt`` dado. (calctama\u00f1o)\n\nExample: ``struct.calcsize('hf')``\n\n:param fmt: Una cadena de formato.\n:return The number of bytes needed to store such a value.\"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"Empaqueta valores seg\u00fan una cadena de formato. (empaquetar)\n\nExample: ``struct.pack('hf', 1, 3.1415)``\n\n:param fmt: La cadena de formato.\n:param v1: El primer valor.\n:param *vn: Los valores restantes.\n:return A bytes object encoding the values.\"\"\"\n    ...\n\ndef pack_into(fmt: str, buffer: WriteableBuffer, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"Empaqueta valores seg\u00fan una cadena de formato. (empaquetar en)\n\nExample: ``struct.pack_info('hf', buffer, 1, 3.1415)``\n\n:param fmt: La cadena de formato.\n:param buffer: (b\u00fafer) El b\u00fafer de destino en el que se va a escribir.\n:param offset: (desplazamiento) El desplazamiento en el b\u00fafer. Puede ser negativo para contar desde el final del b\u00fafer.\n:param v1: El primer valor.\n:param *vn: Los valores restantes.\"\"\"\n    ...\n\ndef unpack(fmt: str, data: ReadableBuffer) -> Tuple[Any, ...]:\n    \"\"\"Desempaqueta datos seg\u00fan una cadena de formato. (desempaquetar)\n\nExample: ``v1, v2 = struct.unpack('hf', buffer)``\n\n:param fmt: La cadena de formato.\n:param data: (datos) Los datos.\n:return: A tuple of the unpacked values.\"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: ReadableBuffer, offset: int=0) -> Tuple:\n    \"\"\"Desempaqueta datos de un b\u00fafer seg\u00fan una cadena de formato. (desempaquetar de)\n\nExample: ``v1, v2 = struct.unpack_from('hf', buffer)``\n\n:param fmt: La cadena de formato.\n:param buffer: (b\u00fafer) El b\u00fafer de origen del que leer.\n:param offset: (desplazamiento) El desplazamiento en el b\u00fafer. Puede ser negativo para contar desde el final del b\u00fafer.\n:return: A tuple of the unpacked values.\"\"\"\n    ...",
    "/typeshed/stdlib/sys.pyi": "\"\"\"Funciones espec\u00edficas del sistema\"\"\"\nfrom typing import Any, Dict, List, NoReturn, TextIO, Tuple\n\ndef exit(retval: object=...) -> NoReturn:\n    \"\"\"Termina el programa actual con un c\u00f3digo de salida determinado. (salir)\n\nExample: ``sys.exit(1)``\n\nThis function raises a ``SystemExit`` exception. If an argument is given, its\nvalue given as an argument to ``SystemExit``.\n\n:param retval: El mensaje o c\u00f3digo de salida.\"\"\"\n    ...\n\ndef print_exception(exc: Exception) -> None:\n    \"\"\"Imprime una excepci\u00f3n con un seguimiento. (imprimir excepci\u00f3n)\n\nExample: ``sys.print_exception(e)``\n\n:param exc: La excepci\u00f3n a imprimir\n\nThis is simplified version of a function which appears in the\n``traceback`` module in CPython.\"\"\"\nargv: List[str]\n\"\"\"Una lista mutable de argumentos con los que se inici\u00f3 el programa actual.\"\"\"\nbyteorder: str\n\"\"\"El orden de bytes del sistema (``\"little\"`` o ``\"big\"``). (ordenbytes)\"\"\"\n\nclass _implementation:\n    name: str\n    version: Tuple[int, int, int]\nimplementation: _implementation\n\"\"\"Objeto con informaci\u00f3n sobre la implementaci\u00f3n actual de Python. (implementaci\u00f3n)\n\nFor MicroPython, it has following attributes:\n\n- ``name`` - string \"micropython\"\n- ``version`` - tuple (major, minor, micro), e.g. (1, 7, 0)\n\nThis object is the recommended way to distinguish MicroPython from other\nPython implementations (note that it still may not exist in the very\nminimal ports).\n\nCPython mandates more attributes for this object, but the actual useful\nbare minimum is implemented in MicroPython.\n\"\"\"\nmaxsize: int\n\"\"\"\nValor m\u00e1ximo que un tipo entero nativo puede contener en la plataforma actual\no valor m\u00e1ximo representable por el tipo entero de MicroPython, en el caso de que sea m\u00e1s peque\u00f1o\nque el valor m\u00e1ximo de la plataforma (que es el caso de los puertos de MicroPython incompatibles con el\ntipo entero largo). (tama\u00f1om\u00e1x)\n\nThis attribute is useful for detecting \"bitness\" of a platform (32-bit vs\n64-bit, etc.). It's recommended to not compare this attribute to some\nvalue directly, but instead count number of bits in it::\n\n    bits = 0\n    v = sys.maxsize\n    while v:\n        bits += 1\n        v >>= 1\n    if bits > 32:\n        # 64-bit (or more) platform\n        ...\n    else:\n        # 32-bit (or less) platform\n        # Note that on 32-bit platform, value of bits may be less than 32\n        # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n        # \"> 32\", \"> 64\" style of comparisons.\n\"\"\"\nmodules: Dict[str, Any]\n\"\"\"Diccionario de m\u00f3dulos cargados. (m\u00f3dulos) \n\nOn some ports, it may not include builtin modules.\"\"\"\npath: List[str]\n\"\"\"Una lista mutable de directorios para buscar m\u00f3dulos importados. (ruta)\"\"\"\nplatform: str\n\"\"\"La plataforma en la que se est\u00e1 ejecutando MicroPython. (plataforma) \n\nFor OS/RTOS ports, this is usually an identifier of the OS, e.g. ``\"linux\"``.\nFor baremetal ports it is an identifier of a board, e.g. ``\"pyboard\"`` for \nthe original MicroPython reference board. It thus can be used to\ndistinguish one board from another.\n\nIf you need to check whether your program runs on MicroPython (vs other\nPython implementation), use ``sys.implementation`` instead.\n\"\"\"\nversion: str\n\"\"\"Versi\u00f3n del lenguaje Python a la que se ajusta esta implementaci\u00f3n, en forma de cadena. (versi\u00f3n)\"\"\"\nversion_info: Tuple[int, int, int]\n\"\"\"Versi\u00f3n del lenguaje Python a la que se ajusta esta implementaci\u00f3n, en forma de tupla de enteros. (info de versi\u00f3n)\n\nOnly the first three version numbers (major, minor, micro) are supported and\nthey can be referenced only by index, not by name.\n\"\"\"",
    "/typeshed/stdlib/this.pyi": "def authors() -> str: ...\n",
    "/typeshed/stdlib/time.pyi": "\"\"\"Mide el tiempo y a\u00f1ade retardos a los programas. (tiempo)\"\"\"\nfrom typing import Union\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"Retarda varios segundos. (dormir)\n\nExample: ``time.sleep(1)``\n\n:param seconds: (segundos) El n\u00famero de segundos de retardo.\nUsa un n\u00famero de coma flotante para generar un retardo durante un n\u00famero fraccional de segundos.\"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"Genera un retardo para el n\u00famero dado de milisegundos. (dormir ms)\n\nExample: ``time.sleep_ms(1_000_000)``\n\n:param ms: El n\u00famero de milisegundos de retardo (>= 0).\"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"Genera un retardo para el n\u00famero dado de microsegundos. (dormir us)\n\nExample: ``time.sleep_us(1000)``\n\n:param us: El n\u00famero de microsegundos de retardo (>= 0).\"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"Obtiene un contador en milisegundos creciente con un punto de referencia arbitrario que se reinicia despu\u00e9s de alg\u00fan valor. (tics ms)\n\nExample: ``time.ticks_ms()``\n\n:return: The counter value in milliseconds.\"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"Obtiene un contador en microsegundos creciente con un punto de referencia arbitrario que se reinicia despu\u00e9s de alg\u00fan valor. (tics us)\n\nExample: ``time.ticks_us()``\n\n:return: The counter value in microseconds.\"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"Valor de desplazamiento de tics por un n\u00famero determinado, el cual puede ser positivo o\nnegativo. (a\u00f1adir tics)\n\nExample: ``time.ticks_add(time.ticks_ms(), 200)``\n\nGiven a ticks value, this function allows to calculate ticks\nvalue delta ticks before or after it, following modular-arithmetic\ndefinition of tick values.\n\n:param ticks: (tics) Un valor de tics\n:param delta: Un desplazamiento entero\n\nExample::\n\n    # Find out what ticks value there was 100ms ago\n    print(ticks_add(time.ticks_ms(), -100))\n\n    # Calculate deadline for operation and test for it\n    deadline = ticks_add(time.ticks_ms(), 200)\n    while ticks_diff(deadline, time.ticks_ms()) > 0:\n        do_a_little_of_something()\n\n    # Find out TICKS_MAX used by this port\n    print(ticks_add(0, -1))\"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"Mide la diferencia de tics entre los valores devueltos por ``time.ticks_ms()`` o ``ticks_us()`` como un valor con signo que se puede reiniciar. (diferencia de tics)\n\nExample: ``time.ticks_diff(scheduled_time, now)``\n\n:param ticks1: (tics1) El valor del que restar\n:param ticks2: (tics2) El valor a restar\n\nThe argument order is the same as for subtraction operator,\n``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n``ticks_diff()`` is designed to accommodate various usage\npatterns, among them:\n\nPolling with timeout. In this case, the order of events is known, and you\nwill deal only with positive results of :func:`time.ticks_diff()`::\n\n    # Wait for GPIO pin to be asserted, but at most 500us\n    start = time.ticks_us()\n    while pin.value() == 0:\n        if time.ticks_diff(time.ticks_us(), start) > 500:\n            raise TimeoutError\n\n\nScheduling events. In this case, :func:`time.ticks_diff()` result may be\nnegative if an event is overdue::\n\n    # This code snippet is not optimized\n    now = time.ticks_ms()\n    scheduled_time = task.scheduled_time()\n    if ticks_diff(scheduled_time, now) > 0:\n        print(\"Too early, let's nap\")\n        sleep_ms(ticks_diff(scheduled_time, now))\n        task.run()\n    elif ticks_diff(scheduled_time, now) == 0:\n        print(\"Right at time!\")\n        task.run()\n    elif ticks_diff(scheduled_time, now) < 0:\n        print(\"Oops, running late, tell task to run faster!\")\n        task.run(run_faster=True)\"\"\"\n    ...",
    "/typeshed/stdlib/types.pyi": "import sys\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    __hash__: None  # type: ignore\n    cell_contents: Any\n\n@final\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    __globals__: dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: None  # type: ignore\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: dict[str, Any]\n    __package__: str | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: GeneratorType[_T_co, _T_contra, Any] | None\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Awaitable[Any] | None\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\n@final\nclass CoroutineType:\n    cr_await: Any | None\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: object | None, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    __closure__: Tuple[_Cell, ...] | None  # inherited from the added function\n    __defaults__: Tuple[Any, ...] | None  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    __self__: object | ModuleType\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    @final\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    @final\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\n@final\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(\n            self,\n            tb_next: TracebackType | None,\n            tb_frame: FrameType,\n            tb_lasti: int,\n            tb_lineno: int,\n        ) -> None: ...\n        tb_next: TracebackType | None\n    else:\n        @property\n        def tb_next(self) -> TracebackType | None: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    f_back: FrameType | None\n    f_builtins: dict[str, Any]\n    f_code: CodeType\n    f_globals: dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: dict[str, Any]\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: dict[str, Any] | None = ...\n) -> Tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    @final\n    class UnionType:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> UnionType: ...\n        def __ror__(self, obj: Any) -> UnionType: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = ...,\n    localns: dict[str, Any] | None = ...,\n    include_extras: bool = ...,\n) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Type[Any] | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: None | Type[Any] | str = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "from array import *\n",
    "/typeshed/stdlib/ucollections.pyi": "from collections import *\n",
    "/typeshed/stdlib/uerrno.pyi": "from errno import *\n",
    "/typeshed/stdlib/urandom.pyi": "from random import *\n",
    "/typeshed/stdlib/ustruct.pyi": "from struct import *\n",
    "/typeshed/stdlib/usys.pyi": "from sys import *\n",
    "/typeshed/stdlib/utime.pyi": "from time import *\n",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any]]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any]]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"Pines, im\u00e1genes, sonidos, temperatura y volumen.\"\"\"\nfrom typing import Any, Callable, List, Optional, Tuple, Union, overload\nfrom _typeshed import ReadableBuffer\nfrom . import accelerometer as accelerometer\nfrom . import audio as audio\nfrom . import compass as compass\nfrom . import display as display\nfrom . import i2c as i2c\nfrom . import microphone as microphone\nfrom . import speaker as speaker\nfrom . import spi as spi\nfrom . import uart as uart\n\ndef run_every(callback: Optional[Callable[[], None]]=None, days: int=0, h: int=0, min: int=0, s: int=0, ms: int=0) -> Callable[[Callable[[], None]], Callable[[], None]]:\n    \"\"\"Programa la ejecuci\u00f3n de una funci\u00f3n en el intervalo especificado por los argumentos de tiempo **S\u00f3lo V2**. (ejecutar cada)\n\nExample: ``run_every(my_logging, min=5)``\n\n``run_every`` can be used in two ways:\n\nAs a Decorator - placed on top of the function to schedule. For example::\n\n    @run_every(h=1, min=20, s=30, ms=50)\n    def my_function():\n        # Do something here\n\nAs a Function - passing the callback as a positional argument. For example::\n\n    def my_function():\n        # Do something here\n    run_every(my_function, s=30)\n\nEach argument corresponds to a different time unit and they are additive.\nSo ``run_every(min=1, s=30)`` schedules the callback every minute and a half.\n\nWhen an exception is thrown inside the callback function it deschedules the\nfunction. To avoid this you can catch exceptions with ``try/except``.\n\n:param callback: Funci\u00f3n a llamar en el intervalo proporcionado. Omitir cuando se utiliza como un decorador.\n:param days: (d\u00edas) Configura la marca del d\u00eda para la programaci\u00f3n.\n:param h: Configura la marca de la hora para la programaci\u00f3n.\n:param min: Configura la marca de los minutos para la programaci\u00f3n.\n:param s: Configura la segunda marca para la programaci\u00f3n.\n:param ms: Configura la marca de los milisegundos para la programaci\u00f3n.\"\"\"\n\ndef panic(n: int) -> None:\n    \"\"\"Entra en modo p\u00e1nico (p\u00e1nico)\n\nExample: ``panic(127)``\n\n:param n: Un entero arbitrario <= 255 para indicar un estado.\n\nRequires restart.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Reiniciar la placa. (restablecer)\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[int, int]) -> int:\n    \"\"\"Convierte un valor de un rango a un rango de n\u00fameros enteros. (escala)\n\nExample: ``volume = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))``\n\nFor example, to convert an accelerometer X value to a speaker volume.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\n\n    temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))\n\n:param value: (valor) Un n\u00famero a convertir.\n:param from_: (de) Una tupla para definir el rango desde el que convertir.\n:param to: (a) Una tupla para definir el rango al que convertir.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[float, float]) -> float:\n    \"\"\"Convierte un valor de un rango a un rango de punto flotante. (escala)\n\nExample: ``temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))``\n\nFor example, to convert temperature from a Celsius scale to Fahrenheit.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\nIf they are both integers (i.e ``10``), it will return an integer::\n\n    returns_int = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))\n\n:param value: (valor) Un n\u00famero a convertir.\n:param from_: (de) Una tupla para definir el rango desde el que convertir.\n:param to: (a) Una tupla para definir el rango al que convertir.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\ndef sleep(n: float) -> None:\n    \"\"\"Espera ``n`` milisegundos. (dormir)\n\nExample: ``sleep(1000)``\n\n:param n: El n\u00famero de milisegundos a esperar\n\nOne second is 1000 milliseconds, so::\n\n    microbit.sleep(1000)\n\nwill pause the execution for one second.\"\"\"\n\ndef running_time() -> int:\n    \"\"\"Obtiene el tiempo de funcionamiento de la placa. (tiempo de ejecuci\u00f3n)\n\n:return: The number of milliseconds since the board was switched on or restarted.\"\"\"\n\ndef temperature() -> int:\n    \"\"\"Obtiene la temperatura del micro:bit en grados Celsius. (temperatura)\"\"\"\n\ndef set_volume(v: int) -> None:\n    \"\"\"Establece el volumen. (configurar volumen)\n\nExample: ``set_volume(127)``\n\n:param v: un valor entre 0 (bajo) y 255 (alto).\n\nOut of range values will be clamped to 0 or 255.\n\n**V2** only.\"\"\"\n    ...\n\nclass Button:\n    \"\"\"La clase para los botones ``button_a`` y ``button_b``. (bot\u00f3n)\"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"Comprueba si el bot\u00f3n est\u00e1 pulsado. (est\u00e1 pulsado)\n\n:return: ``True`` if the specified button ``button`` is pressed, and ``False`` otherwise.\"\"\"\n        ...\n\n    def was_pressed(self) -> bool:\n        \"\"\"Comprueba si el bot\u00f3n ha sido pulsado desde que se inci\u00f3 el dispositivo o desde la \u00faltima vez que se llam\u00f3 a este m\u00e9todo. (ha sido pulsado)\n\nCalling this method will clear the press state so\nthat the button must be pressed again before this method will return\n``True`` again.\n\n:return: ``True`` if the specified button ``button`` was pressed, and ``False`` otherwise\"\"\"\n        ...\n\n    def get_presses(self) -> int:\n        \"\"\"Obtiene el total de pulsaciones sucesivas de un bot\u00f3n y restablece este total\na cero. (total de pulsaciones)\n\n:return: The number of presses since the device started or the last time this method was called\"\"\"\n        ...\nbutton_a: Button\n\"\"\"Objeto ``Button`` para el bot\u00f3n izquierdo. (bot\u00f3n a)\"\"\"\nbutton_b: Button\n\"\"\"Objeto ``Button`` para el bot\u00f3n derecho. (bot\u00f3n b)\"\"\"\n\nclass MicroBitDigitalPin:\n    \"\"\"Un pin digital. (pin digital microbit)\n\nSome pins support analog and touch features using the ``MicroBitAnalogDigitalPin`` and ``MicroBitTouchPin`` subclasses.\"\"\"\n    NO_PULL: int\n    PULL_UP: int\n    PULL_DOWN: int\n\n    def read_digital(self) -> int:\n        \"\"\"Obtiene el valor digital del pin. (lectura digital)\n\nExample: ``value = pin0.read_digital()``\n\n:return: 1 if the pin is high, and 0 if it's low.\"\"\"\n        ...\n\n    def write_digital(self, value: int) -> None:\n        \"\"\"Establece el valor digital del pin. (escritura digital)\n\nExample: ``pin0.write_digital(1)``\n\n:param value: (valor) 1 para establecer valor alto en el pin o 0 para valor bajo\"\"\"\n        ...\n\n    def set_pull(self, value: int) -> None:\n        \"\"\"Configura el estado \"pull\" con uno de los tres valores posibles: ``PULL_UP``, ``PULL_DOWN`` o ``NO_PULL``. (configurar pull)\n\nExample: ``pin0.set_pull(pin0.PULL_UP)``\n\n:param value: (valor) El estado \"pull\" del pin correspondiente, p. ej., ``pin0.PULL_UP``.\"\"\"\n        ...\n\n    def get_pull(self) -> int:\n        \"\"\"Obtiene el estado \"pull\" de un pin. (obtener pull)\n\nExample: ``pin0.get_pull()``\n\n:return: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``\n\nThese are set using the ``set_pull()`` method or automatically configured\nwhen a pin mode requires it.\"\"\"\n        ...\n\n    def get_mode(self) -> str:\n        \"\"\"Devuelve el modo del pin. (obtener modo)\n\nExample: ``pin0.get_mode()``\n\nWhen a pin is used for a specific function, like\nwriting a digital value, or reading an analog value, the pin mode\nchanges.\n\n:return: ``\"unused\"``, ``\"analog\"``, ``\"read_digital\"``, ``\"write_digital\"``, ``\"display\"``, ``\"button\"``, ``\"music\"``, ``\"audio\"``, ``\"touch\"``, ``\"i2c\"``, or ``\"spi\"``\"\"\"\n        ...\n\n    def write_analog(self, value: int) -> None:\n        \"\"\"Env\u00eda una se\u00f1al PWM al pin, con el ciclo de trabajo proporcional a ``value``. (escritura anal\u00f3gica)\n\nExample: ``pin0.write_analog(254)``\n\n:param value: (valor) Un n\u00famero entero o de coma flotante entre 0 (ciclo de trabajo de 0 %) y 1023 (100 %).\"\"\"\n\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"Establece el per\u00edodo de la se\u00f1al PWM enviada a ``period`` milisegundos. (configurar periodo anal\u00f3gico)\n\nExample: ``pin0.set_analog_period(10)``\n\n:param period: (per\u00edodo) El per\u00edodo en milisegundos con un valor m\u00ednimo v\u00e1lido de 1 ms.\"\"\"\n\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"Establece el per\u00edodo de la se\u00f1al PWM enviada a ``period`` microsegundos. (configurar periodo anal\u00f3gico en microsegundos)\n\nExample: ``pin0.set_analog_period_microseconds(512)``\n\n:param period: (per\u00edodo) El per\u00edodo en microsegundos con un valor m\u00ednimo v\u00e1lido de 256 \u03bcs.\"\"\"\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    \"\"\"Un pin con caracter\u00edsticas anal\u00f3gicas y digitales. (pin digital y anal\u00f3gico microbit)\"\"\"\n\n    def read_analog(self) -> int:\n        \"\"\"Lee el voltaje aplicado al pin. (lectura anal\u00f3gica)\n\nExample: ``pin0.read_analog()``\n\n:return: An integer between 0 (meaning 0V) and 1023 (meaning 3.3V).\"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    \"\"\"Un pin con caracter\u00edsticas anal\u00f3gicas, digitales y t\u00e1ctiles. (pin t\u00e1ctil microbit)\"\"\"\n    CAPACITIVE: int\n    RESISTIVE: int\n\n    def is_touched(self) -> bool:\n        \"\"\"Comprueba si se est\u00e1 tocando el pin. (est\u00e1 tocado)\n\nExample: ``pin0.is_touched()``\n\nThe default touch mode for the pins on the edge connector is ``resistive``.\nThe default for the logo pin **V2** is ``capacitive``.\n\n**Resistive touch**\nThis test is done by measuring how much resistance there is between the\npin and ground.  A low resistance gives a reading of ``True``.  To get\na reliable reading using a finger you may need to touch the ground pin\nwith another part of your body, for example your other hand.\n\n**Capacitive touch**\nThis test is done by interacting with the electric field of a capacitor\nusing a finger as a conductor. `Capacitive touch\n<https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_\ndoes not require you to make a ground connection as part of a circuit.\n\n:return: ``True`` if the pin is being touched with a finger, otherwise return ``False``.\"\"\"\n        ...\n\n    def set_touch_mode(self, value: int) -> None:\n        \"\"\"Establece el modo t\u00e1ctil del pin. (configurar modo t\u00e1ctil)\n\nExample: ``pin0.set_touch_mode(pin0.CAPACITIVE)``\n\nThe default touch mode for the pins on the edge connector is\n``resistive``. The default for the logo pin **V2** is ``capacitive``.\n\n:param value: (valor) ``CAPACITIVE`` o ``RESISTIVE`` del pin correspondiente.\"\"\"\n        ...\npin0: MicroBitTouchPin\n\"\"\"Pin con funciones digitales, anal\u00f3gicas y t\u00e1ctiles.\"\"\"\npin1: MicroBitTouchPin\n\"\"\"Pin con funciones digitales, anal\u00f3gicas y t\u00e1ctiles.\"\"\"\npin2: MicroBitTouchPin\n\"\"\"Pin con funciones digitales, anal\u00f3gicas y t\u00e1ctiles.\"\"\"\npin3: MicroBitAnalogDigitalPin\n\"\"\"Pin con funciones digitales y anal\u00f3gicas.\"\"\"\npin4: MicroBitAnalogDigitalPin\n\"\"\"Pin con funciones digitales y anal\u00f3gicas.\"\"\"\npin5: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin6: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin7: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin8: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin9: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin10: MicroBitAnalogDigitalPin\n\"\"\"Pin con funciones digitales y anal\u00f3gicas.\"\"\"\npin11: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin12: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin13: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin14: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin15: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin16: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin19: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin20: MicroBitDigitalPin\n\"\"\"Pin con funciones digitales.\"\"\"\npin_logo: MicroBitTouchPin\n\"\"\"Un pin t\u00e1ctil sensible en la parte frontal del micro:bit que por defecto est\u00e1 configurado en modo t\u00e1ctil capacitivo. (pin de logo)\"\"\"\npin_speaker: MicroBitAnalogDigitalPin\n\"\"\"Un pin para dirigirse al altavoz micro:bit. (pin de altavoz)\n\nThis API is intended only for use in Pulse-Width Modulation pin operations e.g. pin_speaker.write_analog(128).\n\"\"\"\n\nclass Image:\n    \"\"\"Una imagen que se mostrar\u00e1 en la pantalla LED del micro:bit. (imagen)\n\nGiven an image object it's possible to display it via the ``display`` API::\n\n    display.show(Image.HAPPY)\"\"\"\n    HEART: Image\n    \"\"\"Imagen de un coraz\u00f3n. (coraz\u00f3n)\"\"\"\n    HEART_SMALL: Image\n    \"\"\"Imagen de un coraz\u00f3n peque\u00f1o. (coraz\u00f3n peque\u00f1o)\"\"\"\n    HAPPY: Image\n    \"\"\"Imagen de una cara feliz. (feliz)\"\"\"\n    SMILE: Image\n    \"\"\"Imagen de una cara sonriente. (sonrisa)\"\"\"\n    SAD: Image\n    \"\"\"Imagen de una cara triste. (triste)\"\"\"\n    CONFUSED: Image\n    \"\"\"Imagen de una cara confundida. (confundida)\"\"\"\n    ANGRY: Image\n    \"\"\"Imagen de una cara enfadada. (enfadada)\"\"\"\n    ASLEEP: Image\n    \"\"\"Imagen de una cara durmiendo. (dormida)\"\"\"\n    SURPRISED: Image\n    \"\"\"Imagen de una cara sorprendida. (sorprendida)\"\"\"\n    SILLY: Image\n    \"\"\"Imagen de una cara tonta. (tonta)\"\"\"\n    FABULOUS: Image\n    \"\"\"Imagen de una cara con gafas de sol. (fabulosa)\"\"\"\n    MEH: Image\n    \"\"\"Imagen de una cara indiferente. (indiferente)\"\"\"\n    YES: Image\n    \"\"\"Imagen de verificaci\u00f3n. (s\u00ed)\"\"\"\n    NO: Image\n    \"\"\"Imagen de cruz.\"\"\"\n    CLOCK12: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 12:00. (reloj12)\"\"\"\n    CLOCK11: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 11:00. (reloj11)\"\"\"\n    CLOCK10: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 10:00. (reloj10)\"\"\"\n    CLOCK9: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 9:00. (reloj9)\"\"\"\n    CLOCK8: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 8:00. (reloj8)\"\"\"\n    CLOCK7: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 7:00. (reloj7)\"\"\"\n    CLOCK6: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 6:00. (reloj6)\"\"\"\n    CLOCK5: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 5:00. (reloj5)\"\"\"\n    CLOCK4: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 4:00. (reloj4)\"\"\"\n    CLOCK3: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 3:00. (reloj3)\"\"\"\n    CLOCK2: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a las 2:00. (reloj2)\"\"\"\n    CLOCK1: Image\n    \"\"\"Imagen de una l\u00ednea apuntando a la 1:00. (reloj1)\"\"\"\n    ARROW_N: Image\n    \"\"\"Imagen de una flecha apuntando hacia el norte. (flecha n)\"\"\"\n    ARROW_NE: Image\n    \"\"\"Imagen de una flecha apuntando hacia el nordeste. (flecha ne)\"\"\"\n    ARROW_E: Image\n    \"\"\"Imagen de una flecha apuntando hacia el este. (flecha e)\"\"\"\n    ARROW_SE: Image\n    \"\"\"Imagen de una flecha apuntando hacia el sudeste. (flecha se)\"\"\"\n    ARROW_S: Image\n    \"\"\"Imagen de una flecha apuntando hacia el sur. (flecha s)\"\"\"\n    ARROW_SW: Image\n    \"\"\"Imagen de una flecha apuntando hacia el sudoeste. (flecha so)\"\"\"\n    ARROW_W: Image\n    \"\"\"Imagen de una flecha apuntando hacia el oeste. (flecha o)\"\"\"\n    ARROW_NW: Image\n    \"\"\"Imagen de una flecha apuntando hacia el noroeste. (flecha no)\"\"\"\n    TRIANGLE: Image\n    \"\"\"Imagen de un tri\u00e1ngulo apuntando hacia arriba. (tri\u00e1ngulo)\"\"\"\n    TRIANGLE_LEFT: Image\n    \"\"\"Imagen de un tri\u00e1ngulo en la esquina izquierda. (tri\u00e1ngulo izquierda)\"\"\"\n    CHESSBOARD: Image\n    \"\"\"LED iluminados de forma alterna seg\u00fan un patr\u00f3n de tablero de ajedrez. (tablero de ajedrez)\"\"\"\n    DIAMOND: Image\n    \"\"\"Imagen de un diamante. (diamante)\"\"\"\n    DIAMOND_SMALL: Image\n    \"\"\"Imagen de un diamante peque\u00f1o. (diamante peque\u00f1o)\"\"\"\n    SQUARE: Image\n    \"\"\"Imagen de un cuadrado. (cuadrado)\"\"\"\n    SQUARE_SMALL: Image\n    \"\"\"Imagen de un cuadrado peque\u00f1o. (cuadrado peque\u00f1o)\"\"\"\n    RABBIT: Image\n    \"\"\"Imagen de un conejo. (conejo)\"\"\"\n    COW: Image\n    \"\"\"Imagen de una vaca. (vaca)\"\"\"\n    MUSIC_CROTCHET: Image\n    \"\"\"Imagen de una nota negra. (negra musical)\"\"\"\n    MUSIC_QUAVER: Image\n    \"\"\"Imagen de una nota corchea. (corchea musical)\"\"\"\n    MUSIC_QUAVERS: Image\n    \"\"\"Imagen de un par de notas corcheas. (corcheas musicales)\"\"\"\n    PITCHFORK: Image\n    \"\"\"Imagen de una horca. (horca)\"\"\"\n    XMAS: Image\n    \"\"\"Imagen de un \u00e1rbol de Navidad. (navidad)\"\"\"\n    PACMAN: Image\n    \"\"\"Imagen del personaje de videojuegos Pac-Man.\"\"\"\n    TARGET: Image\n    \"\"\"Imagen de un objetivo. (diana)\"\"\"\n    TSHIRT: Image\n    \"\"\"Imagen de una camiseta. (camiseta)\"\"\"\n    ROLLERSKATE: Image\n    \"\"\"Imagen de un pat\u00edn. (pat\u00edn)\"\"\"\n    DUCK: Image\n    \"\"\"Imagen de un pato. (pato)\"\"\"\n    HOUSE: Image\n    \"\"\"Imagen de una casa. (casa)\"\"\"\n    TORTOISE: Image\n    \"\"\"Imagen de una tortuga. (tortuga)\"\"\"\n    BUTTERFLY: Image\n    \"\"\"Imagen de una mariposa. (mariposa)\"\"\"\n    STICKFIGURE: Image\n    \"\"\"Imagen de un monigote. (monigote)\"\"\"\n    GHOST: Image\n    \"\"\"Imagen de un fantasma. (fantasma)\"\"\"\n    SWORD: Image\n    \"\"\"Imagen de una espada. (espada)\"\"\"\n    GIRAFFE: Image\n    \"\"\"Imagen de una jirafa. (girafa)\"\"\"\n    SKULL: Image\n    \"\"\"Imagen de una calavera. (calavera)\"\"\"\n    UMBRELLA: Image\n    \"\"\"Imagen de un paraguas. (paraguas)\"\"\"\n    SNAKE: Image\n    \"\"\"Imagen de una serpiente. (serpiente)\"\"\"\n    SCISSORS: Image\n    \"\"\"Imagen de tijeras. (tijeras)\"\"\"\n    ALL_CLOCKS: List[Image]\n    \"\"\"Una lista que contiene todas las im\u00e1genes CLOCK_ en secuencia. (todos los relojes)\"\"\"\n    ALL_ARROWS: List[Image]\n    \"\"\"Una lista que contiene todas las im\u00e1genes ARROW_ en secuencia. (todas las flechas)\"\"\"\n\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"Crea una imagen a partir de una cadena que describe los LED que est\u00e1n encendidos.\n\n``string`` has to consist of digits 0-9 arranged into lines,\ndescribing the image, for example::\n\n    image = Image(\"90009:\"\n                  \"09090:\"\n                  \"00900:\"\n                  \"09090:\"\n                  \"90009\")\n\nwill create a 5\u00d75 image of an X. The end of a line is indicated by a\ncolon. It's also possible to use newlines (\\\\n) insead of the colons.\n\n:param string: (cadena) La cadena que describe la imagen.\"\"\"\n        ...\n\n    @overload\n    def __init__(self, width: int=5, height: int=5, buffer: ReadableBuffer=None) -> None:\n        \"\"\"Crea una imagen vac\u00eda con ``width`` columnas y ``height`` filas.\n\n:param width: (ancho) Ancho opcional de la imagen\n:param height: (altura) Altura opcional de la imagen\n:param buffer: (b\u00fafer) Matriz opcional de bytes de ``width`` \u00d7 ``height`` enteros en el rango 0 - 9 para inicializar la imagen\n\nExamples::\n\n    Image(2, 2, b'\\x08\\x08\\x08\\x08')\n    Image(2, 2, bytearray([9,9,9,9]))\n\nThese create 2 x 2 pixel images at full brightness.\"\"\"\n        ...\n\n    def width(self) -> int:\n        \"\"\"Obtiene el n\u00famero de columnas. (ancho)\n\n:return: The number of columns in the image\"\"\"\n        ...\n\n    def height(self) -> int:\n        \"\"\"Obtiene el n\u00famero de filas. (altura)\n\n:return: The number of rows in the image\"\"\"\n        ...\n\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"Establece el brillo de un p\u00edxel. (configurar p\u00edxel)\n\nExample: ``my_image.set_pixel(0, 0, 9)``\n\n:param x: El n\u00famero de columna\n:param y: El n\u00famero de fila\n:param value: (valor) El brillo expresado como un entero entre 0 (oscuro) y 9 (brillante)\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"Obtiene el brillo de un p\u00edxel. (obtener p\u00edxel)\n\nExample: ``my_image.get_pixel(0, 0)``\n\n:param x: El n\u00famero de columna\n:param y: El n\u00famero de fila\n:return: The brightness as an integer between 0 and 9.\"\"\"\n        ...\n\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Crea una nueva imagen desplazando la imagen hacia la izquierda. (desplazamiento a la izquierda)\n\nExample: ``Image.HEART_SMALL.shift_left(1)``\n\n:param n: El n\u00famero de columnas a desplazar\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Crea una nueva imagen desplazando la imagen hacia la derecha. (desplazamiento a la derecha)\n\nExample: ``Image.HEART_SMALL.shift_right(1)``\n\n:param n: El n\u00famero de columnas a desplazar\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Crea una nueva imagen desplazando la imagen hacia arriba. (desplazamiento hacia arriba)\n\nExample: ``Image.HEART_SMALL.shift_up(1)``\n\n:param n: El n\u00famero de filas a desplazar\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Crea una nueva imagen desplazando la imagen hacia abajo. (desplazamiento hacia abajo)\n\nExample: ``Image.HEART_SMALL.shift_down(1)``\n\n:param n: El n\u00famero de filas a desplazar\n:return: The shifted image\"\"\"\n        ...\n\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Crear una nueva imagen recortando la imagen. (recortar)\n\nExample: ``Image.HEART.crop(1, 1, 3, 3)``\n\n:param x: La columna de desplazamiento del recorte\n:param y: La fila de desplazamiento del recorte\n:param w: (a) El ancho del recorte\n:param h: La altura del recorte\n:return: The new image\"\"\"\n        ...\n\n    def copy(self) -> Image:\n        \"\"\"Crea una copia exacta de la imagen. (copiar)\n\nExample: ``Image.HEART.copy()``\n\n:return: The new image\"\"\"\n        ...\n\n    def invert(self) -> Image:\n        \"\"\"Crea una nueva imagen invirtiendo el brillo de los p\u00edxeles de la\nimagen de origen. (invertir)\n\nExample: ``Image.SMALL_HEART.invert()``\n\n:return: The new image.\"\"\"\n        ...\n\n    def fill(self, value: int) -> None:\n        \"\"\"Establece el brillo de todos los p\u00edxeles de la imagen. (llenar)\n\nExample: ``my_image.fill(5)``\n\n:param value: (valor) El nuevo brillo expresado como un n\u00famero entre 0 (oscuro) y 9 (brillante).\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def blit(self, src: Image, x: int, y: int, w: int, h: int, xdest: int=0, ydest: int=0) -> None:\n        \"\"\"Copia un \u00e1rea de otra imagen en esta imagen.\n\nExample: ``my_image.blit(Image.HEART, 1, 1, 3, 3, 1, 1)``\n\n:param src: (org) La imagen de origen\n:param x: El desplazamiento de columna inicial en la imagen de origen\n:param y: El desplazamiento de fila inicial en la imagen de origen\n:param w: (a) El n\u00famero de columnas a copiar\n:param h: El n\u00famero de filas a copiar\n:param xdest: El desplazamiento de columna a modificar en esta imagen\n:param ydest: El desplazamiento de fila a modificar en esta imagen\n\nPixels outside the source image are treated as having a brightness of 0.\n\n``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\nand ``crop()`` can are all implemented by using ``blit()``.\n\nFor example, img.crop(x, y, w, h) can be implemented as::\n\n    def crop(self, x, y, w, h):\n        res = Image(w, h)\n        res.blit(self, x, y, w, h)\n        return res\"\"\"\n        ...\n\n    def __repr__(self) -> str:\n        \"\"\"Obtiene una representaci\u00f3n en cadena compacta de la imagen.\"\"\"\n        ...\n\n    def __str__(self) -> str:\n        \"\"\"Obtiene una representaci\u00f3n en cadena legible de la imagen. (cad)\"\"\"\n        ...\n\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Crea una nueva imagen sumando los valores de brillo de las dos im\u00e1genes\npara cada p\u00edxel. (a\u00f1adir)\n\nExample: ``Image.HEART + Image.HAPPY``\n\n:param other: (otro) La imagen a a\u00f1adir.\"\"\"\n        ...\n\n    def __sub__(self, other: Image) -> Image:\n        \"\"\"Crea una nueva imagen restando los valores de brillo de la otra imagen a los de esta imagen. (rest)\n\nExample: ``Image.HEART - Image.HEART_SMALL``\n\n:param other: (otro) La imagen a restar.\"\"\"\n        ...\n\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Crea una nueva imagen multiplicando el brillo de cada p\u00edxel por ``n``.\n\nExample: ``Image.HEART * 0.5``\n\n:param n: El valor por el que multiplicar.\"\"\"\n        ...\n\n    def __truediv__(self, n: float) -> Image:\n        \"\"\"Crea una nueva imagen dividiendo el brillo de cada p\u00edxel entre ``n``.\n\nExample: ``Image.HEART / 2``\n\n:param n: El valor entre el que dividir.\"\"\"\n        ...\n\nclass SoundEvent:\n    LOUD: SoundEvent\n    \"\"\"Representa la transici\u00f3n de eventos de sonido, desde ``quiet`` a ``loud``, como aplaudir o gritar. (alto)\"\"\"\n    QUIET: SoundEvent\n    \"\"\"Representa la transici\u00f3n de eventos de sonido, desde ``loud`` hasta ``quiet``, como hablar o una m\u00fasica de fondo. (silencioso)\"\"\"\n\nclass Sound:\n    \"\"\"Los sonidos predefinidos pueden llamarse usando ``audio.play(Sound.NAME)``. (sonido)\"\"\"\n    GIGGLE: Sound\n    \"\"\"Sonido de risita. (risita)\"\"\"\n    HAPPY: Sound\n    \"\"\"Sonido alegre. (feliz)\"\"\"\n    HELLO: Sound\n    \"\"\"Sonido de saludo. (hola)\"\"\"\n    MYSTERIOUS: Sound\n    \"\"\"Sonido misterioso. (misterioso)\"\"\"\n    SAD: Sound\n    \"\"\"Sonido triste. (triste)\"\"\"\n    SLIDE: Sound\n    \"\"\"Sonido deslizante. (deslizante)\"\"\"\n    SOARING: Sound\n    \"\"\"Sonido creciente. (creciente)\"\"\"\n    SPRING: Sound\n    \"\"\"Sonido de muelle. (muelle)\"\"\"\n    TWINKLE: Sound\n    \"\"\"Sonido parpadeante. (parpadeante)\"\"\"\n    YAWN: Sound\n    \"\"\"Sonido de bostezo. (bostezo)\"\"\"",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"Mide la aceleraci\u00f3n del micro:bit y reconoce gestos. (aceler\u00f3metro)\"\"\"\nfrom typing import Tuple\n\ndef get_x() -> int:\n    \"\"\"Obtiene la medici\u00f3n de la aceleraci\u00f3n en el eje ``x`` en mili-g. (obtener x)\n\nExample: ``accelerometer.get_x()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Obtiene la medici\u00f3n de la aceleraci\u00f3n en el eje ``y`` en mili-g. (obtener y)\n\nExample: ``accelerometer.get_y()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Obtiene la medici\u00f3n de la aceleraci\u00f3n en el eje ``z`` en mili-g. (obtener z)\n\nExample: ``accelerometer.get_z()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"Obtiene las mediciones de las aceleraciones en todos los ejes como una tupla. (obtener valores)\n\nExample: ``x, y, z = accelerometer.get_values()``\n\n:return: a three-element tuple of integers ordered as X, Y, Z, each value a positive or negative integer depending on direction in the range +/- 2000mg\"\"\"\n    ...\n\ndef get_strength() -> int:\n    \"\"\"Obtiene la medida de la aceleraci\u00f3n de todos los ejes combinados, como un entero positivo. Es la suma Pitag\u00f3rica de los ejes X, Y y Z. (obtener fuerza)\n\nExample: ``accelerometer.get_strength()``\n\n:return: The combined acceleration strength of all the axes, in milli-g.\"\"\"\n    ...\n\ndef current_gesture() -> str:\n    \"\"\"Obtiene el nombre del gesto actual. (gesto actual)\n\nExample: ``accelerometer.current_gesture()``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:return: The current gesture\"\"\"\n    ...\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"Comprueba si el gesto est\u00e1 actualmente activo. (gesto activo)\n\nExample: ``accelerometer.is_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (nombre) El nombre del gesto.\n:return: ``True`` if the gesture is active, ``False`` otherwise.\"\"\"\n    ...\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"Comprueba si el gesto estuvo activo desde la \u00faltima llamada. (gesto anterior)\n\nExample: ``accelerometer.was_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (nombre) El nombre del gesto.\n:return: ``True`` if the gesture was active since the last call, ``False`` otherwise.\"\"\"\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Devuelve una tupla con el historial de gestos. (obtener gestos)\n\nExample: ``accelerometer.get_gestures()``\n\nClears the gesture history before returning.\n\nGestures are not updated in the background so there needs to be constant\ncalls to some accelerometer method to do the gesture detection. Usually\ngestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n\n:return: The history as a tuple, most recent last.\"\"\"\n    ...\n\ndef set_range(value: int) -> None:\n    \"\"\"Configura el rango de sensibilidad del aceler\u00f3metro, en g (gravedad est\u00e1ndar), a los valores m\u00e1s cercanos soportados por el hardware, por lo que redondea a ``2``, ``4``, u ``8`` g. (configurar rango)\n\nExample: ``accelerometer.set_range(8)``\n\n:param value: (valor) Nuevo rango para el aceler\u00f3metro, un entero en ``g``.\"\"\"",
    "/typeshed/stdlib/microbit/audio.pyi": "\"\"\"Reproducir sonidos usando el micro:bit (importar ``audio`` para compatibilidad con V1).\"\"\"\nfrom ..microbit import MicroBitDigitalPin, Sound, pin0\nfrom typing import ClassVar, Iterable, Union\n\ndef play(source: Union[Iterable[AudioFrame], Sound, SoundEffect], wait: bool=True, pin: MicroBitDigitalPin=pin0, return_pin: Union[MicroBitDigitalPin, None]=None) -> None:\n    \"\"\"Reproduce un sonido integrado, un efecto de sonido o marcos de audio personalizados. (reproducir)\n\nExample: ``audio.play(Sound.GIGGLE)``\n\n:param source: (origen) Un ``Sound`` integrado como ``Sound.GIGGLE``, un ``SoundEffect`` o datos de muestra como un iterable de objetos ``AudioFrame``.\n:param wait: (esperar) Si ``wait`` es ``True`` (verdadero), la funci\u00f3n se bloquear\u00e1 hasta que el sonido finalice.\n:param pin: Se puede usar un argumento opcional para especificar el pin de salida, reemplazando el valor predeterminado de ``pin0``. Si no queremos que se reproduzca ning\u00fan sonido, podemos usar ``pin=None``.\n:param return_pin: (devolver pin) Especifica un pin de conector de borde diferencial para conectarse a un altavoz externo en lugar de tierra. Esto se ignora para la revisi\u00f3n **V2**.\"\"\"\n\ndef is_playing() -> bool:\n    \"\"\"Comprueba si se est\u00e1 reproduciendo un sonido. (reproduciendo)\n\nExample: ``audio.is_playing()``\n\n:return: ``True`` if audio is playing, otherwise ``False``.\"\"\"\n    ...\n\ndef stop() -> None:\n    \"\"\"Detiene la reproducci\u00f3n de audio. (detener)\n\nExample: ``audio.stop()``\"\"\"\n    ...\n\nclass SoundEffect:\n    \"\"\"Un efecto de sonido, compuesto por un conjunto de par\u00e1metros configurados a trav\u00e9s del constructor o atributos. (efectosonido)\"\"\"\n    WAVEFORM_SINE: ClassVar[int]\n    \"\"\"Opci\u00f3n de onda senoidal utilizada para el par\u00e1metro ``waveform``. (forma de onda senoidal)\"\"\"\n    WAVEFORM_SAWTOOTH: ClassVar[int]\n    \"\"\"Opci\u00f3n de onda con diente de sierra usada para el par\u00e1metro ``waveform``. (forma de onda diente de sierra)\"\"\"\n    WAVEFORM_TRIANGLE: ClassVar[int]\n    \"\"\"Opci\u00f3n de onda triangular usada para el par\u00e1metro ``waveform``. (forma de onda triangular)\"\"\"\n    WAVEFORM_SQUARE: ClassVar[int]\n    \"\"\"Opci\u00f3n de onda cuadrada usada para el par\u00e1metro ``waveform``. (forma de onda cuadrada)\"\"\"\n    WAVEFORM_NOISE: ClassVar[int]\n    \"\"\"Opci\u00f3n de ruido usada para el par\u00e1metro ``waveform``. (forma de onda de ruido)\"\"\"\n    SHAPE_LINEAR: ClassVar[int]\n    \"\"\"Opci\u00f3n de interpolaci\u00f3n lineal usada para el par\u00e1metro ``shape``. (forma lineal)\"\"\"\n    SHAPE_CURVE: ClassVar[int]\n    \"\"\"Opci\u00f3n de interpolaci\u00f3n de curva usada para el par\u00e1metro ``shape``. (forma curva)\"\"\"\n    SHAPE_LOG: ClassVar[int]\n    \"\"\"Opci\u00f3n de interpolaci\u00f3n logar\u00edtmica usada para el par\u00e1metro ``shape``. (registro de forma)\"\"\"\n    FX_NONE: ClassVar[int]\n    \"\"\"Ninguna opci\u00f3n de efecto usada para el par\u00e1metro ``fx``. (fx ninguno)\"\"\"\n    FX_TREMOLO: ClassVar[int]\n    \"\"\"Opci\u00f3n de efecto Tr\u00e9molo usada para el par\u00e1metro ``fx``. (fx tr\u00e9molo)\"\"\"\n    FX_VIBRATO: ClassVar[int]\n    \"\"\"Opci\u00f3n de efecto vibrato utilizada para el par\u00e1metro ``fx``.\"\"\"\n    FX_WARBLE: ClassVar[int]\n    \"\"\"Opci\u00f3n de efecto gorjeo utilizada para el par\u00e1metro ``fx``. (fx gorjeo)\"\"\"\n    freq_start: int\n    \"\"\"Frecuencia de inicio en Hertz (Hz), un n\u00famero entre ``0`` y ``9999`` (frecuencia de inicio)\"\"\"\n    freq_end: int\n    \"\"\"Frecuencia final en Hertz (Hz), un n\u00famero entre ``0`` y ``9999`` (frecuencia final)\"\"\"\n    duration: int\n    \"\"\"Duraci\u00f3n del sonido en milisegundos, un n\u00famero entre ``0`` y ``9999`` (duraci\u00f3n)\"\"\"\n    vol_start: int\n    \"\"\"Valor de volumen inicial, un n\u00famero entre ``0`` y ``255`` (volumen de inicio)\"\"\"\n    vol_end: int\n    \"\"\"Valor final del volumen, un n\u00famero entre ``0`` y ``255`` (volumen final)\"\"\"\n    waveform: int\n    \"\"\"Tipo de forma ondulada, uno de estos valores: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (ruido generado aleatoriamente) (forma de onda)\"\"\"\n    fx: int\n    \"\"\"Efecto para a\u00f1adir en el sonido, uno de los siguientes valores: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``o ``FX_NONE``\"\"\"\n    shape: int\n    \"\"\"El tipo de curva de interpolaci\u00f3n entre las frecuencias de inicio y final, diferentes formas de onda tienen diferentes tasas de cambio en la frecuencia. Uno de los siguientes valores: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG`` (forma)\"\"\"\n\n    def __init__(self, freq_start: int=500, freq_end: int=2500, duration: int=500, vol_start: int=255, vol_end: int=0, waveform: int=WAVEFORM_SQUARE, fx: int=FX_NONE, shape: int=SHAPE_LOG):\n        \"\"\"Crea un nuevo efecto de sonido.\n\nExample: ``my_effect = SoundEffect(duration=1000)``\n\nAll the parameters are optional, with default values as shown above, and\nthey can all be modified via attributes of the same name. For example, we\ncan first create an effect ``my_effect = SoundEffect(duration=1000)``,\nand then change its attributes ``my_effect.duration = 500``.\n\n:param freq_start: (frecuencia de inicio) Frecuencia de inicio en Hertz (Hz), un n\u00famero entre ``0`` y ``9999``.\n:param freq_end: (frecuencia final) Frecuencia final en Hertz (Hz), un n\u00famero entre ``0`` y ``9999``.\n:param duration: (duraci\u00f3n) Duraci\u00f3n del sonido en milisegundos, un n\u00famero entre ``0`` y ``9999``.\n:param vol_start: (volumen inicial) Valor de volumen inicial, un n\u00famero entre ``0`` y ``255``.\n:param vol_end: (volumen final) Valor de volumen final, un n\u00famero entre ``0`` y ``255``.\n:param waveform: (forma de onda) Tipo de forma de onda, uno de estos valores: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (ruido generado aleatoriamente).\n:param fx: Efecto para a\u00f1adir en el sonido, uno de los siguientes valores: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``o ``FX_NONE``.\n:param shape: (forma) El tipo de curva de interpolaci\u00f3n entre las frecuencias de inicio y final, diferentes formas de onda tienen diferentes tasas de cambio en la frecuencia. Uno de los siguientes valores: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``.\"\"\"\n\n    def copy(self) -> SoundEffect:\n        \"\"\"Crea una copia de este ``SoundEffect``. (copiar)\n\nExample: ``sound_2 = sound_1.copy()``\n\n:return: A copy of the SoundEffect.\"\"\"\n\nclass AudioFrame:\n    \"\"\"Un objeto ``AudioFrame`` es una lista de 32 muestras, cada una de las cuales es un byte\nsin signo (n\u00famero entero entre 0 y 255).\n\nIt takes just over 4 ms to play a single frame.\n\nExample::\n\n    frame = AudioFrame()\n    for i in range(len(frame)):\n        frame[i] = 252 - i * 8\"\"\"\n\n    def copyfrom(self, other: AudioFrame) -> None:\n        \"\"\"Sobrescribe los datos de este ``AudioFrame`` con los datos de otra instancia ``AudioFrame``. (copiadesde)\n\nExample: ``my_frame.copyfrom(source_frame)``\n\n:param other: (otro) Instancia ``AudioFrame`` desde la que copiar los datos.\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __setitem__(self, key: int, value: int) -> None:\n        ...\n\n    def __getitem__(self, key: int) -> int:\n        ...",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"Usar la br\u00fajula incorporada. (br\u00fajula)\"\"\"\n\ndef calibrate() -> None:\n    \"\"\"Inicia el proceso de calibraci\u00f3n. (calibrar)\n\nExample: ``compass.calibrate()``\n\nAn instructive message will be scrolled to the user after which they will need\nto rotate the device in order to draw a circle on the LED display.\"\"\"\n    ...\n\ndef is_calibrated() -> bool:\n    \"\"\"Comprueba si la br\u00fajula est\u00e1 calibrada. (est\u00e1 calibrado)\n\nExample: ``compass.is_calibrated()``\n\n:return: ``True`` if the compass has been successfully calibrated, ``False`` otherwise.\"\"\"\n    ...\n\ndef clear_calibration() -> None:\n    \"\"\"Deshace la calibraci\u00f3n, haciendo que la br\u00fajula est\u00e9 otra vez sin calibrar. (eliminar calibraci\u00f3n)\n\nExample: ``compass.clear_calibration()``\"\"\"\n    ...\n\ndef get_x() -> int:\n    \"\"\"Obtiene la fuerza del campo magn\u00e9tico en el eje ``x``. (obtener x)\n\nExample: ``compass.get_x()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Obtiene la fuerza del campo magn\u00e9tico en el eje ``y``. (obtener y)\n\nExample: ``compass.get_y()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Obtiene la fuerza del campo magn\u00e9tico en el eje ``z``. (obtener z)\n\nExample: ``compass.get_z()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef heading() -> int:\n    \"\"\"Obtiene el rumbo de la br\u00fajula. (rumbo)\n\nExample: ``compass.heading()``\n\n:return: An integer in the range from 0 to 360, representing the angle in degrees, clockwise, with north as 0.\"\"\"\n    ...\n\ndef get_field_strength() -> int:\n    \"\"\"Obtiene la magnitud del campo magn\u00e9tico alrededor del dispositivo. (obtener fuerza del campo)\n\nExample: ``compass.get_field_strength()``\n\n:return: An integer indication of the magnitude of the magnetic field in nano tesla.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"Mostrar texto, im\u00e1genes y animaciones en la pantalla LED de 5 \u00d7 5. (pantalla)\"\"\"\nfrom ..microbit import Image\nfrom typing import Union, overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"Obtiene el brillo del LED que hay en la columna ``x`` y fila ``y``. (obtener p\u00edxel)\n\nExample: ``display.get_pixel(0, 0)``\n\n:param x: La columna de la pantalla (0..4)\n:param y: La fila de la pantalla (0..4)\n:return: A number between 0 (off) and 9 (bright)\"\"\"\n    ...\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"Establece el brillo del LED que hay en la columna ``x`` y fila ``y``. (configurar p\u00edxel)\n\nExample: ``display.set_pixel(0, 0, 9)``\n\n:param x: La columna de la pantalla (0..4)\n:param y: La fila de la pantalla (0..4)\n:param value: (valor) El brillo entre 0 (apagado) y 9 (brillante)\"\"\"\n    ...\n\ndef clear() -> None:\n    \"\"\"Ajusta el brillo de todos los LED a 0 (apagado). (borrar)\n\nExample: ``display.clear()``\"\"\"\n    ...\n\ndef show(image: Union[str, float, int, Image, Iterable[Image]], delay: int=400, wait: bool=True, loop: bool=False, clear: bool=False) -> None:\n    \"\"\"Muestra im\u00e1genes, letras o d\u00edgitos en la pantalla LED. (mostrar)\n\nExample: ``display.show(Image.HEART)``\n\nWhen ``image`` is an image or a list of images then each image is displayed in turn.\nIf ``image`` is a string or number, each letter or digit is displayed in turn.\n\n:param image: (imagen) Una cadena, n\u00famero, imagen o lista de im\u00e1genes para mostrar.\n:param delay: (retardo) Cada letra, d\u00edgito o imagen se muestra con ``delay`` milisegundos de retardo entre ellos.\n:param wait: (esperar) Si ``wait`` es ``True`` (verdadero), la funci\u00f3n se bloquear\u00e1 hasta que finalice la animaci\u00f3n; de lo contrario, la animaci\u00f3n se ejecutar\u00e1 en segundo plano.\n:param loop: (bucle) Si ``loop`` es ``True`` (verdadero), la animaci\u00f3n se repetir\u00e1 para siempre.\n:param clear: (borrar) Si ``clear`` es ``True`` (verdadero), la pantalla se borrar\u00e1 una vez que la secuencia haya terminado.\n\nThe ``wait``, ``loop`` and ``clear`` arguments must be specified using their keyword.\"\"\"\n    ...\n\ndef scroll(text: Union[str, float, int], delay: int=150, wait: bool=True, loop: bool=False, monospace: bool=False) -> None:\n    \"\"\"Desplaza un n\u00famero o texto por la pantalla LED. (desplazar)\n\nExample: ``display.scroll('micro:bit')``\n\n:param text: (texto) La cadena a desplazar. Si ``text`` es un entero o de coma flotante, primero se convertir\u00e1 a cadena usando ``str()``.\n:param delay: (retardo) El par\u00e1metro ``delay`` controla la velocidad de desplazamiento del texto.\n:param wait: (esperar) Si ``wait`` es ``True`` (verdadero), la funci\u00f3n se bloquear\u00e1 hasta que finalice la animaci\u00f3n; de lo contrario, la animaci\u00f3n se ejecutar\u00e1 en segundo plano.\n:param loop: (bucle) Si ``loop`` es ``True`` (verdadero), la animaci\u00f3n se repetir\u00e1 para siempre.\n:param monospace: Si ``monospace`` es ``True`` (verdadero), todos los caracteres ocupar\u00e1n columnas de 5 p\u00edxeles de ancho; de lo contrario, habr\u00e1 exactamente 1 columna de p\u00edxeles vac\u00edos entre cada car\u00e1cter a medida que se desplazan.\n\nThe ``wait``, ``loop`` and ``monospace`` arguments must be specified\nusing their keyword.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Enciende la pantalla LED. (encendido)\n\nExample: ``display.on()``\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Apaga la pantalla LED (desactivar la pantalla te permite reutilizar los pines GPIO para otros fines). (apagado)\n\nExample: ``display.off()``\"\"\"\n    ...\n\ndef is_on() -> bool:\n    \"\"\"Comprueba si la pantalla LED est\u00e1 activada. (est\u00e1 encendido)\n\nExample: ``display.is_on()``\n\n:return: ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n    ...\n\ndef read_light_level() -> int:\n    \"\"\"Lee el nivel de luz. (leer nivel de luz)\n\nExample: ``display.read_light_level()``\n\nUses the display's LEDs in reverse-bias mode to sense the amount of light\nfalling on the display.\n\n:return: An integer between 0 and 255 representing the light level, with larger meaning more light.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"Comunicarse con dispositivos que usan el protocolo de bus I\u00b2C.\"\"\"\nfrom _typeshed import ReadableBuffer\nfrom ..microbit import MicroBitDigitalPin, pin19, pin20\nfrom typing import List\n\ndef init(freq: int=100000, sda: MicroBitDigitalPin=pin20, scl: MicroBitDigitalPin=pin19) -> None:\n    \"\"\"Reinicia un perif\u00e9rico. (inic)\n\nExample: ``i2c.init()``\n\n:param freq: (frec) frecuencia del reloj\n:param sda: pin ``sda`` (por defecto, 20)\n:param scl: pin ``scl`` (por defecto, 19)\n\nOn a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\nthe accelerometer and compass stop working, as they are connected\ninternally to those pins. This warning does not apply to the **V2**\nrevision of the micro:bit as this has `separate I\u00b2C lines <https://tech.microbit.org/hardware/i2c/>`_\nfor the motion sensors and the edge connector.\"\"\"\n    ...\n\ndef scan() -> List[int]:\n    \"\"\"Escanea el bus para buscar dispositivos. (escanear)\n\nExample: ``i2c.scan()``\n\n:return: A list of 7-bit addresses corresponding to those devices that responded to the scan.\"\"\"\n    ...\n\ndef read(addr: int, n: int, repeat: bool=False) -> bytes:\n    \"\"\"Lee bytes de un dispositivo. (leer)\n\nExample: ``i2c.read(0x50, 64)``\n\n:param addr: (dir) La direcci\u00f3n de 7 bits del dispositivo\n:param n: El n\u00famero de bytes a leer\n:param repeat: (repetir) Si es ``True`` (verdadero), no se enviar\u00e1 ning\u00fan bit de parada\n:return: The bytes read\"\"\"\n    ...\n\ndef write(addr: int, buf: ReadableBuffer, repeat: bool=False) -> None:\n    \"\"\"Escribe bytes en un dispositivo. (escribir)\n\nExample: ``i2c.write(0x50, bytes([1, 2, 3]))``\n\n:param addr: (dir) La direcci\u00f3n de 7 bits del dispositivo\n:param buf: (b\u00faf) Un b\u00fafer que contiene los bytes a escribir\n:param repeat: (repetir) Si es ``True`` (verdadero), no se enviar\u00e1 ning\u00fan bit de parada\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/microphone.pyi": "\"\"\"Responde al sonido usando el micr\u00f3fono integrado (solo V2). (micr\u00f3fono)\"\"\"\nfrom typing import Optional, Tuple\nfrom ..microbit import SoundEvent\n\ndef current_event() -> Optional[SoundEvent]:\n    \"\"\"Obtiene el \u00faltimo evento de sonido grabado (evento actual)\n\nExample: ``microphone.current_event()``\n\n:return: The event, ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.\"\"\"\n    ...\n\ndef was_event(event: SoundEvent) -> bool:\n    \"\"\"Comprueba si se ha escuchado un sonido al menos una vez desde la \u00faltima llamada. (evento anterior)\n\nExample: ``microphone.was_event(SoundEvent.LOUD)``\n\nThis call clears the sound history before returning.\n\n:param event: (evento) El evento a comprobar, como ``SoundEvent.LOUD`` o ``SoundEvent.QUIET``\n:return: ``True`` if sound was heard at least once since the last call, otherwise ``False``.\"\"\"\n    ...\n\ndef is_event(event: SoundEvent) -> bool:\n    \"\"\"Comprueba el evento de sonido m\u00e1s reciente detectado. (evento reciente)\n\nExample: ``microphone.is_event(SoundEvent.LOUD)``\n\nThis call does not clear the sound event history.\n\n:param event: (evento) El evento a comprobar, como ``SoundEvent.LOUD`` o ``SoundEvent.QUIET``\n:return: ``True`` if sound was the most recent heard, ``False`` otherwise.\"\"\"\n    ...\n\ndef get_events() -> Tuple[SoundEvent, ...]:\n    \"\"\"Obtiene el historial de eventos de sonido como una tupla. (obtener eventos)\n\nExample: ``microphone.get_events()``\n\nThis call clears the sound history before returning.\n\n:return: A tuple of the event history with the most recent event last.\"\"\"\n    ...\n\ndef set_threshold(event: SoundEvent, value: int) -> None:\n    \"\"\"Establece el umbral para un evento de sonido. (configurar l\u00edmite)\n\nExample: ``microphone.set_threshold(SoundEvent.LOUD, 250)``\n\nA high threshold means the event will only trigger if the sound is very loud (>= 250 in the example).\n\n:param event: (evento) Un evento de sonido, como ``SoundEvent.LOUD`` o ``SoundEvent.QUIET``.\n:param value: (valor) El nivel de umbral en el rango 0 - 255.\"\"\"\n    ...\n\ndef sound_level() -> int:\n    \"\"\"Obtiene el nivel de presi\u00f3n sonora. (nivel de sonido)\n\nExample: ``microphone.sound_level()``\n\n:return: A representation of the sound pressure level in the range 0 to 255.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/speaker.pyi": "\"\"\"Controlar el altavoz integrado (solo V2). (altavoz)\"\"\"\n\ndef off() -> None:\n    \"\"\"Apaga el altavoz. (apagado)\n\nExample: ``speaker.off()``\n\nThis does not disable sound output to an edge connector pin.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Enciende el altavoz. (encendido)\n\nExample: ``speaker.on()``\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"Comunicarse con dispositivos que usan el bus de interfaz de perif\u00e9ricos serie (SPI, por sus siglas en ingl\u00e9s).\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom ..microbit import pin13, pin14, pin15, MicroBitDigitalPin\n\ndef init(baudrate: int=1000000, bits: int=8, mode: int=0, sclk: MicroBitDigitalPin=pin13, mosi: MicroBitDigitalPin=pin15, miso: MicroBitDigitalPin=pin14) -> None:\n    \"\"\"Inicializa la comunicaci\u00f3n SPI.\n\nExample: ``spi.init()``\n\nFor correct communication, the parameters have to be the same on both communicating devices.\n\n:param baudrate: (tasa de baudios) La velocidad de comunicaci\u00f3n.\n:param bits: El ancho en bits de cada transferencia. Actualmente solo se admite ``bits=8}, pero esto puede cambiar en el futuro.\n:param mode: (modo) Determina la combinaci\u00f3n de fase y polaridad del reloj - `ver tabla en l\u00ednea <https://microbit-micropython.readthedocs.io/en/v2-docs/spi.html#microbit.spi.init>`_.\n:param sclk: pin SCLK (por defecto, 13)\n:param mosi: pin MOSI (por defecto, 15)\n:param miso: pin MISO (por defecto, 14)\"\"\"\n    ...\n\ndef read(nbytes: int, out: int=0) -> bytes:\n    \"\"\"Lee como m\u00e1ximo ``nbytes`` mientras est\u00e1 escribiendo continuamente el byte individual dado por ``out``. (leer)\n\nExample: ``spi.read(64)``\n\n:param nbytes: N\u00famero m\u00e1ximo de bytes a leer.\n:param out: (salida) El valor del byte a escribir (por defecto 0).\n:return: The bytes read.\"\"\"\n    ...\n\ndef write(buffer: ReadableBuffer) -> None:\n    \"\"\"Escribe bytes en el bus. (escribir)\n\nExample: ``spi.write(bytes([1, 2, 3]))``\n\n:param buffer: (b\u00fafer) Un b\u00fafer del que leer datos.\"\"\"\n    ...\n\ndef write_readinto(out: WriteableBuffer, in_: ReadableBuffer) -> None:\n    \"\"\"Escribe el b\u00fafer ``out`` en el bus y lee cualquier respuesta en el b\u00fafer ``in_``. (escritura leeren)\n\nExample: ``spi.write_readinto(out_buffer, in_buffer)``\n\nThe length of the buffers should be the same. The buffers can be the same object.\n\n:param out: (a) El b\u00fafer en el que escribe una respuesta.\n:param in_: (de) El b\u00fafer del que leer datos.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"Comunicarse con un dispositivo usando una interfaz serie.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom ..microbit import MicroBitDigitalPin\nfrom typing import Optional, Union\nODD: int\n\"\"\"Paridad impar (impar)\"\"\"\nEVEN: int\n\"\"\"Paridad par (par)\"\"\"\n\ndef init(baudrate: int=9600, bits: int=8, parity: Optional[int]=None, stop: int=1, tx: Optional[MicroBitDigitalPin]=None, rx: Optional[MicroBitDigitalPin]=None) -> None:\n    \"\"\"Inicializa la comunicaci\u00f3n serie.\n\nExample: ``uart.init(115200, tx=pin0, rx=pin1)``\n\n:param baudrate: (tasa de baudios) La velocidad de comunicaci\u00f3n.\n:param bits: El tama\u00f1o de bytes transmitidos; micro:bit solo admite 8.\n:param parity: (paridad) C\u00f3mo se comprueba la paridad: ``None``, ``uart.ODD`` o ``uart.EVEN``.\n:param stop: (detener) El n\u00famero de bits de parada; tiene que ser 1 para el micro:bit.\n:param tx: Pin transmisor.\n:param rx: Pin receptor.\n\nInitializing the UART on external pins will cause the Python console on\nUSB to become unaccessible, as it uses the same hardware. To bring the\nconsole back you must reinitialize the UART without passing anything for\n``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\nthat calling ``uart.init(115200)`` is enough to restore the Python console.\n\nFor more details see `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/uart.html>`_.\"\"\"\n    ...\n\ndef any() -> bool:\n    \"\"\"Comprueba si hay datos en espera. (alg\u00fan)\n\nExample: ``uart.any()``\n\n:return: ``True`` if any data is waiting, else ``False``.\"\"\"\n    ...\n\ndef read(nbytes: Optional[int]=None) -> Optional[bytes]:\n    \"\"\"Lee bytes. (leer)\n\nExample: ``uart.read()``\n\n:param nbytes: Si se especifica ``nbytes``, lee como m\u00e1ximo ese n\u00famero de bytes; si no, lee tantos bytes como sea posible\n:return: A bytes object or ``None`` on timeout\"\"\"\n    ...\n\ndef readinto(buf: WriteableBuffer, nbytes: Optional[int]=None) -> Optional[int]:\n    \"\"\"Lee bytes en el ``buf``. (leeren)\n\nExample: ``uart.readinto(input_buffer)``\n\n:param buf: (b\u00faf) El b\u00fafer en el que escribir.\n:param nbytes: Si se especifica ``nbytes``, lee como m\u00e1ximo ese n\u00famero de bytes; si no, lee ``len(buf)`` bytes.\n:return: number of bytes read and stored into ``buf`` or ``None`` on timeout.\"\"\"\n    ...\n\ndef readline() -> Optional[bytes]:\n    \"\"\"Lee una l\u00ednea, terminando en un car\u00e1cter de nueva l\u00ednea. (leerl\u00ednea)\n\nExample: ``uart.readline()``\n\n:return: The line read or ``None`` on timeout. The newline character is included in the returned bytes.\"\"\"\n    ...\n\ndef write(buf: Union[bytes, str]) -> Optional[int]:\n    \"\"\"Escribe un b\u00fafer en el bus. (escribir)\n\nExample: ``uart.write('hello world')``\n\n:param buf: (b\u00faf) Un objeto de bytes o una cadena.\n:return: The number of bytes written, or ``None`` on timeout.\n\nExamples::\n\n    uart.write('hello world')\n    uart.write(b'hello world')\n    uart.write(bytes([1, 2, 3]))\"\"\"\n    ...",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Optional,\n    Reversible,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n)\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}