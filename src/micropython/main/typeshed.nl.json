{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]\n    ) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "",
    "/typeshed/stdlib/array.pyi": "from typing import Generic, Iterable, MutableSequence, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode]\n\n_T = TypeVar(\"_T\", int, float)\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(\n        self: array[int],\n        typecode: _IntTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[float],\n        typecode: _FloatTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...\n    ) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n\nArrayType = array\n",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __slots__: str | Iterable[str]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls: Type[_T]) -> _T: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> str | Tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __name__: str\n    __qualname__: str\n    __text_signature__: str | None\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], dict: dict[str, Any], **kwds: Any\n    ) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: Type[_TT],\n        name: str,\n        bases: Tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwds: Any,\n    ) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> list[_TT]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(\n        metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any\n    ) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.UnionType: ...\n        def __ror__(self, t: Any) -> types.UnionType: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(\n        cls: Type[_T],\n        x: str | bytes | SupportsInt | SupportsIndex | _SupportsTrunc = ...,\n    ) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], x: str | bytes | bytearray, base: SupportsIndex\n    ) -> _T: ...\n    def to_bytes(\n        self,\n        length: SupportsIndex,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls,\n        bytes: Iterable[SupportsIndex] | SupportsBytes,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n    @overload\n    def __pow__(\n        self, __x: int, __modulo: int | None = ...\n    ) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(\n        cls: Type[_T], x: SupportsFloat | SupportsIndex | str | bytes | bytearray = ...\n    ) -> _T: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], real: str | SupportsComplex | SupportsIndex | complex\n    ) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...\n    ) -> _T: ...\n    def count(\n        self,\n        x: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self,\n        __suffix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def index(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: str | None = ...) -> str: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    def rfind(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def rstrip(self, __chars: str | None = ...) -> str: ...\n    def split(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def startswith(\n        self,\n        __prefix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __chars: str | None = ...) -> str: ...\n    def upper(self) -> str: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: int | slice) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ByteString | memoryview]) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytes: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray:\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[_T_co | _T, ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(\n        self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n\n# Can we remove this?\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: dict[str, Any]\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls: type[Self]) -> Self: ...\n    @overload\n    def __new__(cls: type[Self], __iterable: Iterable[_T_co]) -> Self: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(\n        self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(\n        self: list[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n    ) -> None: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, x: list[_T]) -> list[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: list[_T]) -> bool: ...\n    def __ge__(self, x: list[_T]) -> bool: ...\n    def __lt__(self, x: list[_T]) -> bool: ...\n    def __le__(self, x: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(\n        self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(\n        cls, __iterable: Iterable[_T], __value: None = ...\n    ) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(\n        self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> _T | _VT: ...\n\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exec(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(\n        self, __function: Callable[[_T], Any], __iterable: Iterable[_T]\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\n@overload\ndef getattr(__o: object, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: object, name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n    def issubclass(\n        __cls: type,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n\nelse:\n    def isinstance(\n        __obj: object, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef max(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef max(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef min(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef min(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIO: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes) -> int: ...\ndef print(\n    *values: object,\n    sep: str | None = ...,\n    end: str | None = ...,\n    file: SupportsWrite[str] | None = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(\n        base: int, exp: int, mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n) -> list[SupportsLessThanT]: ...\n@overload\ndef sorted(\n    __iterable: Iterable[_T],\n    *,\n    key: Callable[[_T], SupportsLessThan],\n    reverse: bool = ...,\n) -> list[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> _T | _S: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> _T | _S: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]\n    ) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Mapping[str, Any] | None = ...,\n    locals: Mapping[str, Any] | None = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(\n        self, *args: object, name: str | None = ..., path: str | None = ...\n    ) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass NotImplementedError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\n",
    "/typeshed/stdlib/errno.pyi": "from typing import Mapping\n\nerrorcode: Mapping[int, str]\n\nEACCES: int\nEADDRINUSE: int\nEAGAIN: int\nEALREADY: int\nEBADF: int\nECONNABORTED: int\nECONNREFUSED: int\nECONNRESET: int\nEEXIST: int\nEHOSTUNREACH: int\nEINPROGRESS: int\nEINVAL: int\nEIO: int\nEISDIR: int\nENOBUFS: int\nENODEV: int\nENOENT: int\nENOMEM: int\nENOTCONN: int\nEOPNOTSUPP: int\nEPERM: int\nETIMEDOUT: int\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Beheer de garbagecollector\"\"\"\nfrom typing import overload\n\ndef enable() -> None:\n    \"\"\"Automatische afvalcollectie inschakelen. (inschakelen)\"\"\"\n    ...\n\ndef disable() -> None:\n    \"\"\"Automatische afvalinzameling uitschakelen. (uitschakelen)\n\nHeap memory can still be allocated,\nand garbage collection can still be initiated manually using ``gc.collect``.\"\"\"\n\ndef collect() -> None:\n    \"\"\"Voer een garbagecollectie uit. (verzamel)\"\"\"\n    ...\n\ndef mem_alloc() -> int:\n    \"\"\"Krijg het aantal bytes van heap RAM die toegewezen zijn.\n\n:return: The number of bytes allocated.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\ndef mem_free() -> int:\n    \"\"\"Krijg het aantal bytes van beschikbare heap RAM, of -1 als dit bedrag niet bekend is.\n\n:return: The number of bytes free.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\n@overload\ndef threshold() -> int:\n    \"\"\"Vraag de extra GC toewijzingsdrempel op. (drempelwaarde)\n\n:return: The GC allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\"\"\"\n    ...\n\n@overload\ndef threshold(amount: int) -> None:\n    \"\"\"Stel de extra GC toewijzingsdrempel in. (drempelwaarde)\n\nNormally, a collection is triggered only when a new allocation\ncannot be satisfied, i.e. on an  out-of-memory (OOM) condition.\nIf this function is called, in addition to OOM, a collection\nwill be triggered each time after ``amount`` bytes have been\nallocated (in total, since the previous time such an amount of bytes\nhave been allocated). ``amount`` is usually specified as less than the\nfull heap size, with the intention to trigger a collection earlier than when the\nheap becomes exhausted, and in the hope that an early collection will prevent\nexcessive memory fragmentation. This is a heuristic measure, the effect\nof which will vary from application to application, as well as\nthe optimal value of the ``amount`` parameter.\n\nA value of -1 means a disabled allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\n\n:param amount: (bedrag) Het aantal bytes waarna een garbage collectie moet worden geactiveerd.\"\"\"\n    ...",
    "/typeshed/stdlib/log.pyi": "\"\"\"Log gegevens in op je micro:bit V2.\"\"\"\nfrom typing import Literal, Mapping, Optional, Union, overload\nMILLISECONDS = 1\n\"\"\"Milliseconden tijdstempel formaat. (milliseconden)\"\"\"\nSECONDS = 10\n\"\"\"Seconden tijdstempel formaat. (seconden)\"\"\"\nMINUTES = 600\n\"\"\"Minuten tijdstempel formaat. (minuten)\"\"\"\nHOURS = 36000\n\"\"\"Uren tijdstempel formaat. (uren)\"\"\"\nDAYS = 864000\n\"\"\"Dagen tijdstempel formaat. (dagen)\"\"\"\n\ndef set_labels(*labels: str, timestamp: Optional[Literal[1, 10, 36000, 864000]]=SECONDS) -> None:\n    \"\"\"Stel de logbestandheader in. (kies labels)\n\nExample: ``log.set_labels('X', 'Y', 'Z', timestamp=log.MINUTES)``\n\nIdeally this function should be called a single time, before any data is\nlogged, to configure the data table header once.\n\nIf a log file already exists when the program starts, or if this function\nis called multiple times, it will check the labels already defined in the\nlog file. If this function call contains any new labels not already\npresent, it will generate a new header row with the additional columns.\n\nBy default the first column contains a timestamp for each row. The time\nunit can be selected via the timestamp argument.\n\n:param *labels: Een willekeurig aantal positionele argumenten, elk corresponderend aan een vermelding in de log header.\n:param timestamp: (tijdstempel) Selecteer de eenheid van de tijdsaanduiding die automatisch als eerste kolom in elke rij wordt toegevoegd. Tijdstempel waarden kunnen een van ``log.MILLISECONDS``, ``log.SECONDS``, ``log.MINUTES``, , , ``log.HOURS``, ``log.DAYS`` of ``None`` om de tijdstempel uit te schakelen. De standaardwaarde is ``log.SECONDS``.\"\"\"\n    ...\n\n@overload\ndef add(data_dictionary: Optional[Mapping[str, Union[str, int, float]]]) -> None:\n    \"\"\"Voeg een gegevensrij toe aan de log door een woordenboek van koppen en waarden te passeren. (toevoegen)\n\nExample: ``log.add({ 'temp': temperature() })``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\n\n:param data_dictionary: (gegevenswoordenboek) De gegevens die moeten worden geregistreerd als woordenboek met een sleutel voor elke header.\"\"\"\n    ...\n\n@overload\ndef add(**kwargs: Union[str, int, float]) -> None:\n    \"\"\"Voeg een gegevensrij toe aan het logboek met behulp van trefwoordargumenten. (toevoegen)\n\nExample: ``log.add(temp=temperature())``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\"\"\"\n    ...\n\ndef delete(full=False):\n    \"\"\"Verwijdert de inhoud van het log, inclusief headers. (verwijderen)\n\nExample: ``log.delete()``\n\nTo add the log headers again the ``set_labels`` function should to be called after this function.\n\nThere are two erase modes; \u201cfull\u201d completely removes the data from the physical storage,\nand \u201cfast\u201d invalidates the data without removing it.\n\n:param full: (volledig) ``True`` selecteert een \"volledige\" wissen en ``False`` selecteert de \"snel\" wis methode.\"\"\"\n    ...\n\ndef set_mirroring(serial: bool):\n    \"\"\"Configureer het spiegelen van de data logging activiteit naar de seri\u00eble uitgang. (stel spiegelen in)\n\nExample: ``log.set_mirroring(True)``\n\nSerial mirroring is disabled by default. When enabled, it will print to serial each row logged into the log file.\n\n:param serial: (serieel) ``True`` maakt het spiegelen van gegevens naar de seri\u00eble uitvoer mogelijk.\"\"\"\n    ...",
    "/typeshed/stdlib/love.pyi": "def badaboom() -> None: ...\n",
    "/typeshed/stdlib/machine.pyi": "\"\"\"Hulpprogramma's op laag niveau.\"\"\"\nfrom typing import Any\nfrom .microbit import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Krijg een byte string met een uniek id van een bord. (uniek id)\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Reset het apparaat op een manier die lijkt op de externe RESET knop.\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Krijg de CPU frequentie in Hertz. (frequentie)\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"Interruptie verzoeken uitschakelen. (irq uitschakelen)\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"Zet interruptie verzoeken opnieuw aan. (irq inschakelen)\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: (staat) De waarde die is teruggestuurd van de meest recente oproep naar de ``disable_irq`` functie.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Time een puls op een pin. (tijd pulse us)\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: De pin om te gebruiken\n:param pulse_level: (puls niveau) 0 om een lage puls te tikken of 1 om een hoge puls te tikken\n:param timeout_us: Een microseconde time-out\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"De klasse van de ``mem8``, ``mem16`` en ``mem32`` geheugenweergaven.\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Toegang tot een waarde uit het geheugen.\n\n:param address: (adres) Het geheugenadres.\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"Stel een waarde in op het opgegeven adres.\n\n:param address: (adres) Het geheugen adres.\n:param value: (waarde) De integerwaarde die moet worden ingesteld.\"\"\"\n        ...\nmem8: mem\n\"\"\"8-bit (byte) weergave van het geheugen.\"\"\"\nmem16: mem\n\"\"\"16-bit (byte) weergave van het geheugen.\"\"\"\nmem32: mem\n\"\"\"32-bit (byte) weergave van het geheugen.\"\"\"",
    "/typeshed/stdlib/math.pyi": "\"\"\"Wiskundige functies. (wiskunde)\"\"\"\nfrom typing import Tuple\n\ndef acos(x: float) -> float:\n    \"\"\"Bereken de inverse cosinus.\n\nExample: ``math.acos(1)``\n\n:param x: (\u0445) Een getal\n:return: The inverse cosine of ``x``\"\"\"\n    ...\n\ndef asin(x: float) -> float:\n    \"\"\"Bereken de inverse sinus.\n\nExample: ``math.asin(0)``\n\n:param x: (\u0445) Een getal\n:return: The inverse sine of ``x``\"\"\"\n    ...\n\ndef atan(x: float) -> float:\n    \"\"\"Bereken de inverse tangens.\n\nExample: ``math.atan(0)``\n\n:param x: (\u0445) Een getal\n:return: The inverse tangent of ``x``\"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float:\n    \"\"\"Bereken de hoofdwaarde van de inverse tangens van ``y/x``.\n\nExample: ``math.atan2(0, -1)``\n\n:param y: (\u0445) Een getal\n:param x: (\u0445) Een getal\n:return: The principal value of the inverse tangent of ``y/x``\"\"\"\n    ...\n\ndef ceil(x: float) -> float:\n    \"\"\"Rond een getal af op een positief oneindig. (plafond)\n\nExample: ``math.ceil(0.1)``\n\n:param x: (\u0445) Een getal\n:return: ``x`` rounded towards positive infinity.\"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float:\n    \"\"\"Bereken ``x`` met de teken van ``y``.\n\nExample: ``math.copysign(1, -1)``\n\n:param x: (\u0445) Een getal\n:param y: De bron van het teken voor de retourwaarde\n:return: ``x`` with the sign of ``y``\"\"\"\n    ...\n\ndef cos(x: float) -> float:\n    \"\"\"Bereken de cosinus van ``x``.\n\nExample: ``math.cos(0)``\n\n:param x: (\u0445) Een getal\n:return: The cosine of ``x``\"\"\"\n    ...\n\ndef degrees(x: float) -> float:\n    \"\"\"radialen converteren naar graden: (graden)\n\nExample: ``math.degrees(2 * math.pi)``\n\n:param x: (\u0445) Een waarde in radialen\n:return: The value converted to degrees\"\"\"\n    ...\n\ndef exp(x: float) -> float:\n    \"\"\"Bereken de exponenti\u00eble van ``x``.\n\nExample: ``math.exp(1)``\n\n:param x: (\u0445) Een getal\n:return: The exponential of ``x``.\"\"\"\n    ...\n\ndef fabs(x: float) -> float:\n    \"\"\"Geeft de absolute waarde van ``x``.\n\nExample: ``math.fabs(-0.1)``\n\n:param x: (\u0445) Een getal\n:return: The absolute value of ``x``\"\"\"\n    ...\n\ndef floor(x: float) -> int:\n    \"\"\"Rond een getal af op een negatief oneindig.\n\nExample: ``math.floor(0.9)``\n\n:param x: (\u0445) Een getal\n:return: ``x`` rounded towards negative infinity.\"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float:\n    \"\"\"Bereken de rest van ``x/y``.\n\nExample: ``math.fmod(10, 3)``\n\n:param x: (\u0445) De nummeraar\n:param y: De noemer\"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]:\n    \"\"\"Ontleedt een getal met drijvende komma in zijn mantisse en exponent.\n\nExample: ``mantissa, exponent = math.frexp(2)``\n\nThe returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\nexactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\nthe relation ``0.5 <= abs(m) < 1`` holds.\n\n:param x: (\u0445) Getal met drijvende komma\n:return: A tuple of length two containing its mantissa then exponent\"\"\"\n    ...\n\ndef isfinite(x: float) -> bool:\n    \"\"\"Controleer of een waarde eindig is. (is eindig)\n\nExample: ``math.isfinite(float('inf'))``\n\n:param x: (\u0445) Een getal.\n:return: ``True`` if ``x`` is finite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isinf(x: float) -> bool:\n    \"\"\"Controleer of een waarde oneindig is.\n\nExample: ``math.isinf(float('-inf'))``\n\n:param x: (\u0445) Een getal.\n:return: ``True`` if ``x`` is infinite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isnan(x: float) -> bool:\n    \"\"\"Check if is een waarde is geen getal (NaN).\n\nExample: ``math.isnan(float('nan'))``\n\n:param x: (\u0445) Een getal\n:return: ``True`` if ``x`` is not-a-number (NaN), ``False`` otherwise.\"\"\"\n    ...\n\ndef ldexp(x: float, exp: int) -> float:\n    \"\"\"Bereken ``x * (2**exp)``.\n\nExample: ``math.ldexp(0.5, 2)``\n\n:param x: (\u0445) Een getal\n:param exp: Integer exponent\n:return: ``x * (2**exp)``\"\"\"\n    ...\n\ndef log(x: float, base: float=e) -> float:\n    \"\"\"Bereken het logaritme van ``x`` naar de opgegeven basis (standaard is het natuurlijke logalgoritme).\n\nExample: ``math.log(math.e)``\n\nWith one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as ``log(x)/log(base)``.\n\n:param x: (\u0445) Een getal\n:param base: (grondtal) Het grondtal om te gebruiken\n:return: The natural logarithm of ``x``\"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]:\n    \"\"\"Bereken de fractionele en integrale onderdelen van ``x``.\n\nExample: ``fractional, integral = math.modf(1.5)``\n\n:param x: (\u0445) Een getal\n:return: A tuple of two floats representing the fractional then integral parts of ``x``.\n\nBoth the fractional and integral values have the same sign as ``x``.\"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float:\n    \"\"\"Retourneert ``x`` naar de kracht van ``y``.\n\nExample: ``math.pow(4, 0.5)``\n\n:param x: (\u0445) Een getal\n:param y: De exponent\n:return: ``x`` to the power of ``y``\"\"\"\n    ...\n\ndef radians(x: float) -> float:\n    \"\"\"Converteer graden naar radialen. (radialen)\n\nExample: ``math.radians(360)``\n\n:param x: (\u0445) Een waarde in graden\n:return: The value converted to radians\"\"\"\n    ...\n\ndef sin(x: float) -> float:\n    \"\"\"Bereken de sinus van ``x``.\n\nExample: ``math.sin(math.pi/2)``\n\n:param x: (\u0445) Een getal\n:return: The sine of ``x``\"\"\"\n    ...\n\ndef sqrt(x: float) -> float:\n    \"\"\"Bereken de wortel van ``x``. (wortel)\n\nExample: ``math.sqrt(4)``\n\n:param x: (\u0445) Een getal\n:return: The square root of ``x``\"\"\"\n    ...\n\ndef tan(x: float) -> float:\n    \"\"\"Bereken de tangens van ``x``.\n\nExample: ``math.tan(0)``\n\n:param x: (\u0445) Een getal\n:return: The tangent of ``x``.\"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\"Rond een getal af naar 0.\n\nExample: ``math.trunc(-0.9)``\n\n:param x: (\u0445) Een getal\n:return: ``x`` rounded towards zero.\"\"\"\n    ...\ne: float\n\"\"\"Basis van het natuurlijke logaritme\"\"\"\npi: float\n\"\"\"De omtrek van een cirkel tot de diameter\"\"\"",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"MicroPython intern.\"\"\"\nfrom typing import Any, TypeVar, overload\n_T = TypeVar('_T')\n\ndef const(expr: _T) -> _T:\n    \"\"\"Gebruikt om te verklaren dat de expressie een constante is zodat de compiler\ndeze kan optimaliseren.\n\nThe use of this function should be as follows::\n\n    from micropython import const\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\nConstants declared this way are still accessible as global variables from\noutside the module they are declared in. On the other hand, if a constant\nbegins with an underscore then it is hidden, it is not available as a\nglobal variable, and does not take up any memory during execution.\n\n:param expr: Een constante expressie.\"\"\"\n    ...\n\n@overload\ndef opt_level() -> int:\n    \"\"\"Krijg het huidige optimalisatieniveau voor de compilatie van scripts. (Kies niveau)\n\nExample: ``micropython.opt_level()``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\n:return: An integer representing the current level.\"\"\"\n    ...\n\n@overload\ndef opt_level(level: int) -> None:\n    \"\"\"Stelt het optimalisatie niveau in voor de latere compilatie van scripts. (opt niveau)\n\nExample: ``micropython.opt_level(1)``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\nThe default optimisation level is usually level 0.\n\n:param level: (niveau) Een integer optimaliserings niveau.\"\"\"\n    ...\n\ndef mem_info(verbose: Any=None) -> None:\n    \"\"\"Druk informatie af over het momenteel gebruikte geheugen.\n\nExample: ``micropython.mem_info()``\n\n:param verbose: Als het argument van ``verbose`` wordt opgegeven, wordt extra informatie afgedrukt.\"\"\"\n    ...\n\ndef qstr_info(verbose: Any=None) -> None:\n    \"\"\"Druk informatie af over momenteel gebruikte interne tekenreeksen.\n\nExample: ``micropython.qstr_info()``\n\n:param verbose: Als het argument van ``verbose`` wordt opgegeven, wordt extra informatie afgedrukt.\n\nThe information that is printed is implementation dependent, but currently\nincludes the number of interned strings and the amount of RAM they use.  In\nverbose mode it prints out the names of all RAM-interned strings.\"\"\"\n    ...\n\ndef stack_use() -> int:\n    \"\"\"Retourneert een integer getal dat huidige hoeveelheid stack vertegenwoordigt die wordt gebruikt. (stapel gebruik)\n\nExample: ``micropython.stack_use()``\n\nThe absolute value of this is not particularly useful, rather it\nshould be used to compute differences in stack usage at different points.\n\n:return: An integer representing current stack use.\"\"\"\n    ...\n\ndef heap_lock() -> None:\n    \"\"\"Lock de heap. (heap slot)\n\nExample: ``micropython.heap_lock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef heap_unlock() -> None:\n    \"\"\"Unlock the heap.\n\nExample: ``micropython.heap_unlock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"Stel het karakter in dat een ``KeyboardInterrupt`` -uitzondering maakt.\n\nExample: ``micropython.kbd_intr(-1)``\n\n:param chr: Karakter code om de onderbreking of -1 om opname van Ctrl-C uit te schakelen.\n\nBy default this is set to 3 during script execution, corresponding to Ctrl-C.\nPassing -1 to this function will disable capture of Ctrl-C, and passing 3\nwill restore it.\n\nThis function can be used to prevent the capturing of Ctrl-C on the\nincoming stream of characters that is usually used for the REPL, in case\nthat stream is used for other purposes.\"\"\"\n    ...",
    "/typeshed/stdlib/music.pyi": "\"\"\"Maak en speel melodie\u00ebn. (muziek)\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .microbit import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"Melodie: de opening naar Beethoven's 5e Symfonie in C minor.\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"Melody: het openingsfragment van Scott Joplin\u2019s Ragtime classic \u201cThe Entertainer\u201d.\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"Melodie: de opening van de eerste prelude in C Major van J.S.Bach's 48 Preludes en Fugues.\"\"\"\nODE: Tuple[str, ...]\n\"\"\"Melodie: het thema \"Ode aan Joy\" van Beethoven zijn negende Symfonie in D-klein.\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"Melodie: het Nyan Cat thema (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"Melodie: iets dat klinkt als een beltoon van een mobiele telefoon. (beltoon)\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"Melodie: een grappige bas lijn voor geheime agenten en criminele meesterbreinen.\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"Melodie: een boogie-woogie 12-bar blues wandel bas. (Blues)\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"Melodie: \u201cHappy Birthday to You\u2026\u201d (verjaardag)\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"Melodie: het bruidskoor van de opera van Wagner \u201cLohengrin\u201d. (bruiloft)\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"Melody: de \u201cbegrafenismars\u201d die ook bekend staat als Fr\u00e9d\u00e9ric Chopin\u2019s Piano Sonata No. 2 in B\u266d minor, Op. 35. (begrafenis)\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"Melodie: een grappig fragment dat aangeeft dat er een grap is gemaakt. (clou)\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"Melodie: John Philip Sousa's mars \"Liberty Bell\", ook bekend als het thema voor \"Monty Python's Flying Circus\" (waarnaar de programmeertaal Python is vernoemd).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"Melodie: stomme filmtijdperk de binnenkomst van een boef. (boef)\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"Melodie: stille film tijdperk achtervolgings-sc\u00e8ne. (achtervolgen)\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"Melodie: een kort signaal om aan te geven dat er iets is gebeurd.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"Melody: een zeer trieste trombone.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"Melody: voor gebruik in een spel om opwaartse beweging aan te geven. (spring omhoog)\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"Melody: voor gebruik in een spel, om neerwaartse beweging aan te geven. (spring omlaag)\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"Melodie: een fanfare die aantoont dat een prestatie ontgrendeld is. (opstarten)\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"Melody: een droevige fanfare om aan te geven dat een prestatie verloren is gegaan. (afsluiten)\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"Stelt het geschatte tempo in voor het afspelen. (kies tempo)\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: (tikken) Het aantal tikken in een beat.\n:param bpm: Een geheel getal dat het aantal beats per minuut bepaalt.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"Haalt het huidige tempo op als een heel geheel getal: ``(ticks, bpm)``. (krijg tempo)\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Speelt muziek af. (afspelen)\n\nExample: ``music.play(music.NYAN)``\n\n:param music: (muziek) muziek opgegeven in `a special notation <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: de uitvoer pin voor gebruik met een externe luidspreker (standaard ``pin0``), ``None`` voor geen geluid.\n:param wait: (wacht) Als ``wait`` is ingesteld op ``True``wordt deze functie geblokkeerd.\n:param loop: Als ``loop`` is ingesteld op ``True``herhaalt de melodie tot ``stop`` wordt opgeroepen of wordt de blokkerende oproep word onderbroken.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Speel een noot. (toonhoogte)\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: (frequentie) Een integere frequentie\n:param duration: (Duur) Een milliseconde duur. Als negatief dan gaat het geluid door tot de volgende oproep of een oproep tot ``stop``.\n:param pin: Optionele uitvoer pin (standaard ``pin0``).\n:param wait: (wacht) Als ``wait`` is ingesteld op ``True``wordt deze functie geblokkeerd.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Stopt alle muziek op de ingebouwde luidspreker en elke pin die geluid uitzendt.\n\nExample: ``music.stop()``\n\n:param pin: Een optioneel argument kan worden opgegeven om een pin op te geven, bijvoorbeeld ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Reset ticks, bpm, duur en octaven naar hun standaardwaarden.\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Individueel adresseerbare RGB en RGBW LED-strips.\"\"\"\nfrom .microbit import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"Initialiseer een nieuwe strip van neopixel LED's beheerd via een pin. (initialiseren)\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: De pin regelt de neopixelstrook.\n:param n: Het aantal neopixels in de strip.\n:param bpp: Bytes per pixel. Voor ondersteuning van RGBW neopixels geeft je 4 aan in plaats van de standaardwaarde van 3 voor RGB en GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Verwijder alle pixels. (wissen)\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"Toon de pixels. (toon)\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Toon de pixels (alleen micro:bit V2). (schrijven)\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Kleur alle pixels een bepaalde RGB/RGBW waarde (alleen micro:bit V2). (opvullen)\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: (kleur) Een tuple van dezelfde lengte als het aantal bytes per pixel (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"Stel een pixelkleur in.\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: (sleutel) Het pixelnummer.\n:param value: (waarde) De kleur.\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"Krijg een pixelkleur.\n\nExample: ``r, g, b = np[0]``\n\n:param key: (sleutel) Het pixelnummer.\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"Haal de lengte op van deze pixelstrip.\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "\"\"\"Toegang tot het bestandssysteem.\"\"\"\nfrom typing import Tuple\nfrom typing import List\n\ndef listdir() -> List[str]:\n    \"\"\"Bestanden weergeven.\n\nExample: ``os.listdir()``\n\n:return: A list of the names of all the files contained within the local\npersistent on-device file system.\"\"\"\n    ...\n\ndef remove(filename: str) -> None:\n    \"\"\"Verwijder (verwijder) een bestand. (verwijder)\n\nExample: ``os.remove('data.txt')``\n\n:param filename: (bestands naam) Het bestand is verwijderd\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n    ...\n\ndef size(filename: str) -> int:\n    \"\"\"Geeft de grootte van een bestand weer. (grootte)\n\nExample: ``os.size('data.txt')``\n\n:param filename: (bestands naam) Het bestand\n:return: The size in bytes.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n\nclass uname_result(Tuple[str, str, str, str, str]):\n    \"\"\"Resultaat van ``os.uname()`` (uname resultaat)\"\"\"\n    sysname: str\n    \"\"\"Besturingssysteem naam\"\"\"\n    nodename: str\n    \"\"\"Naam van machine op het netwerk (implementation-defined).\"\"\"\n    release: str\n    \"\"\"Besturingssysteem release. (vrijgeven)\"\"\"\n    version: str\n    \"\"\"Besturingssysteem versie. (versie)\"\"\"\n    machine: str\n    \"\"\"Identificatie hardware\"\"\"\n\ndef uname() -> uname_result:\n    \"\"\"Geeft informatie terug die het huidige besturingssysteem identificeert.\n\nExample: ``os.uname()``\n\nThe return value is an object with five attributes:\n\n- ``sysname`` - operating system name\n- ``nodename`` - name of machine on network (implementation-defined)\n- ``release`` - operating system release\n- ``version`` - operating system version\n- ``machine`` - hardware identifier\n\nThere is no underlying operating system in MicroPython. As a result the\ninformation returned by the ``uname`` function is mostly useful for\nversioning details.\"\"\"\n    ...",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "\"\"\"Communiceer tussen micro:bits met de ingebouwde radio.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom typing import Optional, Tuple\nRATE_1MBIT: int\n\"\"\"Constante gebruikt om een doorvoer van 1 MBit per seconde aan te geven.\"\"\"\nRATE_2MBIT: int\n\"\"\"Constante gebruikt om een doorvoer van 2 MBit per seconde aan te geven.\"\"\"\n\ndef on() -> None:\n    \"\"\"Zet de radio aan. (aan)\n\nExample: ``radio.on()``\n\nThis needs to be explicitly called since the radio draws power and takes\nup memory that you may otherwise need.\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Schakelt de radio uit, bespaar stroom en geheugen. (uit)\n\nExample: ``radio.off()``\"\"\"\n    ...\n\ndef config(length: int=32, queue: int=3, channel: int=7, power: int=6, address: int=1969383796, group: int=0, data_rate: int=RATE_1MBIT) -> None:\n    \"\"\"Configureert de radio. (configuratie)\n\nExample: ``radio.config(group=42)``\n\nThe default configuration is suitable for most use.\n\n:param length: (lengte) (default=32) definieert de maximale lengte, in bytes, van een bericht dat via de radio wordt verzonden.\nHet kan maximaal 251 bytes lang zijn (254 - 3 bytes voor S0, LENGTH en S1 preamble).\n:param queue: (wachtrij) (standaard=3) geeft het aantal berichten aan dat in de wachtrij van het inkomende bericht kan worden opgeslagen.\nAls er geen ruimte meer is in de wachtrij voor binnenkomende berichten, dan valt het inkomende bericht weg.\n:param channel: (kanaal) (default=7) een integer waarde van 0 tot 83 (inclusief) die een willekeurig \"kanaal\" definieert waaraan de radio wordt afgestemd.\nBerichten worden via dit kanaal verzonden en alleen via dit kanaal worden berichten in de wachtrij van het inkomende berichten geplaatst. Elke stap is 1 MHz breed, gebaseerd op 2400MHz.\n:param power: (vermogen) (default=6) is een integer waarde van 0 tot 7 (inclusief) om de sterkte van het signaal aan te geven dat wordt gebruikt bij het uitzenden van een bericht.\nHoe hoger de waarde, des te sterker het signaal, maar hoe meer stroom het apparaat verbruikt. De nummering vertaalt naar posities in de volgende lijst van dBm (decibel milliwatt) waarden: -30, -20, -16, -12, -8, -4, 0, 4.\n:param address: (adres) (default=0x75626974) een willekeurige naam, uitgedrukt als een 32-bits adres, wordt gebruikt om inkomende pakketten op hardware-niveau te filteren, waarbij alleen de pakketten worden bewaard die overeenkomen met het adres dat je zelf instelt.\nDe standaard gebruiker door andere micro:bit gerelateerde platforms is de standaard instelling die hier wordt gebruikt.\n:param group: (groep) (standaard=0) een 8-bit waarde (0-255) gebruikt met de ``address`` bij het filteren van berichten.\nConceptueel, \"adres\" is als een huis/kantooradres en \"groep\" is als de persoon op dat adres waarnaar je je bericht wilt sturen.\n:param data_rate: (Gegevens snelheid) (default=``radio.RATE_1MBIT``) geeft aan hoe snel de doorvoer van gegevens plaatsvindt.\nKan een van de volgende constanten zijn gedefinieerd in de ``radio`` module: ``RATE_250KBIT``, ``RATE_1MBIT`` of ``RATE_2MBIT``.\n\nIf ``config`` is not called then the defaults described above are assumed.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Reset alle instellingen naar hun standaardwaarde.\n\nExample: ``radio.reset()``\n\nThe defaults as as per the ``config`` function above.\"\"\"\n    ...\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Stuurt een bericht met bytes. (verstuur bytes)\n\nExample: ``radio.send_bytes(b'hello')``\n\n:param message: (bericht) De te verzenden bytes.\"\"\"\n    ...\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Ontvang het volgende inkomende bericht in de wachtrij van het bericht. (ontvang bytes)\n\nExample: ``radio.receive_bytes()``\n\n:return: The message bytes if any, otherwise ``None``.\"\"\"\n    ...\n\ndef receive_bytes_into(buffer: WriteableBuffer) -> Optional[int]:\n    \"\"\"Kopieer het volgende inkomende bericht in de wachtrij van het bericht naar een buffer. (ontvang bytes in)\n\nExample: ``radio.receive_bytes_info(buffer)``\n\n:param buffer: De doel buffer. Het bericht wordt ingekort als het groter is dan de buffer.\n:return: ``None`` if there are no pending messages, otherwise it returns the length of the message (which might be more than the length of the buffer).\"\"\"\n    ...\n\ndef send(message: str) -> None:\n    \"\"\"Stuurt een berichtenreeks. (verzenden)\n\nExample: ``radio.send('hello')``\n\nThis is the equivalent of ``radio.send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\nprepended to the front (to make it compatible with other platforms that target the micro:bit).\n\n:param message: (bericht) De te verzenden tekenreeks.\"\"\"\n    ...\n\ndef receive() -> Optional[str]:\n    \"\"\"Werkt op precies dezelfde manier als ``receive_bytes`` , maar retourneert wat er verzonden is. (ontvang)\n\nExample: ``radio.receive()``\n\nEquivalent to ``str(receive_bytes(), 'utf8')`` but with a check that the the first\nthree bytes are ``b'\\x01\\x00\\x01'`` (to make it compatible with other platforms that\nmay target the micro:bit).\n\n:return: The message with the prepended bytes stripped and converted to a string.\n\nA ``ValueError`` exception is raised if conversion to string fails.\"\"\"\n    ...\n\ndef receive_full() -> Optional[Tuple[bytes, int, int]]:\n    \"\"\"Geeft als resultaat een dup met drie waarden die het volgende inkomende bericht in de wachtrij van het bericht weergeven. (Ontvang vol)\n\nExample: ``radio.receive_full()``\n\nIf there are no pending messages then ``None`` is returned.\n\nThe three values in the tuple represent:\n\n- the next incoming message on the message queue as bytes.\n- the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n- a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\nFor example::\n\n    details = radio.receive_full()\n    if details:\n        msg, rssi, timestamp = details\n\nThis function is useful for providing information needed for triangulation\nand/or trilateration with other micro:bit devices.\n\n:return: ``None`` if there is no message, otherwise a tuple of length three with the bytes, strength and timestamp values.\"\"\"\n    ...",
    "/typeshed/stdlib/random.pyi": "\"\"\"Willekeurige getallen genereren. (willekeurig)\"\"\"\nfrom typing import TypeVar, Sequence, Union, overload\n\ndef getrandbits(n: int) -> int:\n    \"\"\"Genereer een geheel getal met ``n`` willekeurige bits.\n\nExample: ``random.getrandbits(1)``\n\n:param n: Een waarde tussen 1-30 (inclusief).\"\"\"\n    ...\n\ndef seed(n: int) -> None:\n    \"\"\"Initialiseer de willekeurige getalgenerator.\n\nExample: ``random.seed(0)``\n\n:param n: De integer seed\n\nThis will give you reproducibly deterministic randomness from a given starting\nstate (``n``).\"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int:\n    \"\"\"Kies een willekeurig geheel getal tussen ``a`` en ``b`` inclusief.\n\nExample: ``random.randint(0, 9)``\n\n:param a: Beginwaarde voor het bereik (inclusief)\n:param b: Eindwaarde voor het bereik (inclusief)\n\nAlias for ``randrange(a, b + 1)``.\"\"\"\n    ...\n\n@overload\ndef randrange(stop: int) -> int:\n    \"\"\"Kies een willekeurig geselecteerd geheel getal tussen nul en tot (maar niet\ninclusief) ``stop``.\n\nExample: ``random.randrange(10)``\n\n:param stop: Eindwaarde voor het bereik (exclusief)\"\"\"\n    ...\n\n@overload\ndef randrange(start: int, stop: int, step: int=1) -> int:\n    \"\"\"Kies een willekeurig geselecteerd element uit ``range(start, stop, step)``.\n\nExample: ``random.randrange(0, 10)``\n\n:param start: Het begin van het bereik (inclusief)\n:param stop: Einde van het bereik (exclusief)\n:param step: (stap) De stap.\"\"\"\n    ...\n_T = TypeVar('_T')\n\ndef choice(seq: Sequence[_T]) -> _T:\n    \"\"\"Kies een willekeurig element uit de niet-lege reeks ``seq``. (keuze)\n\nExample: ``random.choice([Image.HAPPY, Image.SAD])``\n\n:param seq: Een volgorde.\n\nIf ``seq`` is  empty, raises ``IndexError``.\"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"Genereer een willekeurig zwevend puntnummer in het bereik [0.0, 1.0). (willekeurig)\n\nExample: ``random.random()``\n\n:return: The random floating point number\"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float:\n    \"\"\"Geeft een willekeurig zwevend punt nummer tussen ``a`` en ``b`` inclusief.\n\nExample: ``random.uniform(0, 9)``\n\n:param a: Beginwaarde voor het bereik (inclusief)\n:param b: Eindwaarde voor het bereik (inclusief)\"\"\"\n    ...",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Laat de micro:bit praten, zingen en andere spraak maken, zoals geluid. (spraak)\"\"\"\nfrom typing import Optional\nfrom .microbit import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Vertaal Engelse woorden naar fonemen. (vertalen)\n\nExample: ``speech.translate('hello world')``\n\n:param words: (woorden) Een tekenreeks Engelse woorden.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Uitspraak phonemes. (uitspreken)\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemen) De reeks fonemen om uit te spreken\n:param pitch: (toonhoogte) Een nummer dat de toonhoogte van de stem weergeeft\n:param speed: (snelheid) Een nummer dat de snelheid van de stem vertegenwoordigt\n:param mouth: (mond) Een nummer dat de mond van de stem weergeeft\n:param throat: (keel) Een nummer dat de keel van de stem weergeeft\n:param pin: Een optioneel argument om de uitvoer pin op te geven, kan worden gebruikt om de standaard van ``pin0``te overschrijven. Als we geen geluid willen afspelen, kunnen we ``pin=None`` gebruiken. Alleen voor micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Zeg Engelse woorden. (zeg)\n\nExample: ``speech.say('hello world')``\n\n:param words: (woorden) De tekenreeks van woorden om te zeggen.\n:param pitch: (toonhoogte) Een nummer dat de toonhoogte van de stem weergeeft\n:param speed: (snelheid) Een nummer dat de snelheid van de stem vertegenwoordigt\n:param mouth: (mond) Een nummer dat de mond van de stem weergeeft\n:param throat: (keel) Een nummer dat de keel van de stem weergeeft\n:param pin: Een optioneel argument om de uitvoer pin op te geven, kan worden gebruikt om de standaard van ``pin0``te overschrijven. Als we geen geluid willen afspelen, kunnen we ``pin=None`` gebruiken. Alleen voor micro:bit V2.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Zing fonemen. (zing)\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: (fonemen) De tekenreeks van woorden om te zingen.\n:param pitch: (toonhoogte) Een nummer dat de toonhoogte van de stem weergeeft\n:param speed: (snelheid) Een nummer dat de snelheid van de stem vertegenwoordigt\n:param mouth: (mond) Een nummer dat de mond van de stem weergeeft\n:param throat: (keel) Een nummer dat de keel van de stem weergeeft\n:param pin: Een optioneel argument om de uitvoer pin op te geven, kan worden gebruikt om de standaard van ``pin0``te overschrijven. Als we geen geluid willen afspelen, kunnen we ``pin=None`` gebruiken. Alleen voor micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "\"\"\"Primitieve datatypes inpakken en uitpakken.\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom typing import Any, Tuple, Union\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"Haal het aantal bytes op dat nodig is om de gegeven ``fmt`` op te slaan.\n\nExample: ``struct.calcsize('hf')``\n\n:param fmt: Tekenreeks opmaak.\n:return The number of bytes needed to store such a value.\"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"Verpak de waarden op basis van een string formaat. (inpakken)\n\nExample: ``struct.pack('hf', 1, 3.1415)``\n\n:param fmt: De formaat tekenreeks.\n:param v1: De eerste waarde.\n:param *vn: De resterende waarden.\n:return A bytes object encoding the values.\"\"\"\n    ...\n\ndef pack_into(fmt: str, buffer: WriteableBuffer, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"Verpak de waarden op basis van een string formaat. (inpakken)\n\nExample: ``struct.pack_info('hf', buffer, 1, 3.1415)``\n\n:param fmt: De formaat tekenreeks.\n:param buffer: De doelbuffer om in te schrijven.\n:param offset: (Offset) De compensatie in de buffer. Kan negatief zijn om te tellen aan het einde van de buffer.\n:param v1: De eerste waarde.\n:param *vn: De resterende waarden.\"\"\"\n    ...\n\ndef unpack(fmt: str, data: ReadableBuffer) -> Tuple[Any, ...]:\n    \"\"\"Uitpakken van gegevens volgens een opmaakreeks. (uitpakken)\n\nExample: ``v1, v2 = struct.unpack('hf', buffer)``\n\n:param fmt: De formaat tekenreeks.\n:param data: (gegevens) De gegevens.\n:return: A tuple of the unpacked values.\"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: ReadableBuffer, offset: int=0) -> Tuple:\n    \"\"\"Uitpakken van gegevens van een buffer volgens een opmaak. (uitpakken van)\n\nExample: ``v1, v2 = struct.unpack_from('hf', buffer)``\n\n:param fmt: De formaat tekenreeks.\n:param buffer: De bronbuffer om uit te lezen.\n:param offset: (Offset) De compensatie in de buffer. Kan negatief zijn om te tellen aan het einde van de buffer.\n:return: A tuple of the unpacked values.\"\"\"\n    ...",
    "/typeshed/stdlib/sys.pyi": "\"\"\"Systeem specifieke functies\"\"\"\nfrom typing import Any, Dict, List, NoReturn, TextIO, Tuple\n\ndef exit(retval: object=...) -> NoReturn:\n    \"\"\"Be\u00ebindig het huidige programma met een bepaalde exit code. (afsluiten)\n\nExample: ``sys.exit(1)``\n\nThis function raises a ``SystemExit`` exception. If an argument is given, its\nvalue given as an argument to ``SystemExit``.\n\n:param retval: De exit code of bericht.\"\"\"\n    ...\n\ndef print_exception(exc: Exception) -> None:\n    \"\"\"Print een exception met traceback. (exceptie afdrukken)\n\nExample: ``sys.print_exception(e)``\n\n:param exc: De af te drukken uitzondering\n\nThis is simplified version of a function which appears in the\n``traceback`` module in CPython.\"\"\"\nargv: List[str]\n\"\"\"Een veranderlijke lijst met argumenten waarmee het huidige programma is gestart.\"\"\"\nbyteorder: str\n\"\"\"De byte volgorde van het systeem (``\"little\"`` of ``\"big\"``). (byte volgorde)\"\"\"\n\nclass _implementation:\n    name: str\n    version: Tuple[int, int, int]\nimplementation: _implementation\n\"\"\"Object met informatie over de huidige Python implementatie. (implementatie)\n\nFor MicroPython, it has following attributes:\n\n- ``name`` - string \"micropython\"\n- ``version`` - tuple (major, minor, micro), e.g. (1, 7, 0)\n\nThis object is the recommended way to distinguish MicroPython from other\nPython implementations (note that it still may not exist in the very\nminimal ports).\n\nCPython mandates more attributes for this object, but the actual useful\nbare minimum is implemented in MicroPython.\n\"\"\"\nmaxsize: int\n\"\"\"\nMaximale waarde die een native integer type kan aanhouden op het huidige platform, of de maximale waarde die kan worden vertegenwoordigd door MicroPython integer type, als het kleiner is dan platform max waarde (dat is het geval voor MicroPython poorten zonder\nlange int ondersteuning).\n\nThis attribute is useful for detecting \"bitness\" of a platform (32-bit vs\n64-bit, etc.). It's recommended to not compare this attribute to some\nvalue directly, but instead count number of bits in it::\n\n    bits = 0\n    v = sys.maxsize\n    while v:\n        bits += 1\n        v >>= 1\n    if bits > 32:\n        # 64-bit (or more) platform\n        ...\n    else:\n        # 32-bit (or less) platform\n        # Note that on 32-bit platform, value of bits may be less than 32\n        # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n        # \"> 32\", \"> 64\" style of comparisons.\n\"\"\"\nmodules: Dict[str, Any]\n\"\"\"Woordenboek van geladen modules. \n\nOn some ports, it may not include builtin modules.\"\"\"\npath: List[str]\n\"\"\"Een aanpasbare lijst van mappen om te zoeken naar ge\u00efmporteerde modules. (pad)\"\"\"\nplatform: str\n\"\"\"Het platform waarop MicroPython actief is. \n\nFor OS/RTOS ports, this is usually an identifier of the OS, e.g. ``\"linux\"``.\nFor baremetal ports it is an identifier of a board, e.g. ``\"pyboard\"`` for \nthe original MicroPython reference board. It thus can be used to\ndistinguish one board from another.\n\nIf you need to check whether your program runs on MicroPython (vs other\nPython implementation), use ``sys.implementation`` instead.\n\"\"\"\nversion: str\n\"\"\"Python taalversie waar deze implementatie mee overeenstemt als tekenreeks. (versie)\"\"\"\nversion_info: Tuple[int, int, int]\n\"\"\"Python taalversie waaraan deze implementatie voldoet, als een tupel van ints. (versie informatie)\n\nOnly the first three version numbers (major, minor, micro) are supported and\nthey can be referenced only by index, not by name.\n\"\"\"",
    "/typeshed/stdlib/this.pyi": "def authors() -> str: ...\n",
    "/typeshed/stdlib/time.pyi": "\"\"\"Meet tijd en voeg vertragingen toe aan programma's. (tijd)\"\"\"\nfrom typing import Union\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"Vertraag een aantal seconden. (slapen)\n\nExample: ``time.sleep(1)``\n\n:param seconds: (seconden) Het aantal seconden om voor te slapen.\nGebruik een floating-point nummer om te slapen voor een fractioneel aantal seconden.\"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"Vertraging voor een bepaald aantal milliseconden. (slaap ms)\n\nExample: ``time.sleep_ms(1_000_000)``\n\n:param ms: Het aantal milliseconden vertraging (>= 0).\"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"Vertraging voor een bepaald aantal microseconden. (slaap us)\n\nExample: ``time.sleep_us(1000)``\n\n:param us: Het aantal microseconden vertraging (>= 0).\"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"Krijg een toenemende milliseconde teller met een willekeurig referentiepunt, dat omwikkeld na een waarde.\n\nExample: ``time.ticks_ms()``\n\n:return: The counter value in milliseconds.\"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"Krijg een toenemende milliseconde teller met een willekeurig referentiepunt, dat omwikkeld na een waarde.\n\nExample: ``time.ticks_us()``\n\n:return: The counter value in microseconds.\"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"Waarde van de offset ticks door een bepaald getal, die ofwel positief ofwel\nnegatief kan zijn. (ticks toevoegen)\n\nExample: ``time.ticks_add(time.ticks_ms(), 200)``\n\nGiven a ticks value, this function allows to calculate ticks\nvalue delta ticks before or after it, following modular-arithmetic\ndefinition of tick values.\n\n:param ticks: (tikken) Een ticks waarde\n:param delta: Een integer verschuiving\n\nExample::\n\n    # Find out what ticks value there was 100ms ago\n    print(ticks_add(time.ticks_ms(), -100))\n\n    # Calculate deadline for operation and test for it\n    deadline = ticks_add(time.ticks_ms(), 200)\n    while ticks_diff(deadline, time.ticks_ms()) > 0:\n        do_a_little_of_something()\n\n    # Find out TICKS_MAX used by this port\n    print(ticks_add(0, -1))\"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"Meet het verschil in ticks tussen waarden die worden geretourneerd door ``time.ticks_ms()`` of ``ticks_us()``, als een ondertekende waarde die rond kan lopen.\n\nExample: ``time.ticks_diff(scheduled_time, now)``\n\n:param ticks1: De waarde om van af te trekken\n:param ticks2: De waarde om af te trekken\n\nThe argument order is the same as for subtraction operator,\n``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n``ticks_diff()`` is designed to accommodate various usage\npatterns, among them:\n\nPolling with timeout. In this case, the order of events is known, and you\nwill deal only with positive results of :func:`time.ticks_diff()`::\n\n    # Wait for GPIO pin to be asserted, but at most 500us\n    start = time.ticks_us()\n    while pin.value() == 0:\n        if time.ticks_diff(time.ticks_us(), start) > 500:\n            raise TimeoutError\n\n\nScheduling events. In this case, :func:`time.ticks_diff()` result may be\nnegative if an event is overdue::\n\n    # This code snippet is not optimized\n    now = time.ticks_ms()\n    scheduled_time = task.scheduled_time()\n    if ticks_diff(scheduled_time, now) > 0:\n        print(\"Too early, let's nap\")\n        sleep_ms(ticks_diff(scheduled_time, now))\n        task.run()\n    elif ticks_diff(scheduled_time, now) == 0:\n        print(\"Right at time!\")\n        task.run()\n    elif ticks_diff(scheduled_time, now) < 0:\n        print(\"Oops, running late, tell task to run faster!\")\n        task.run(run_faster=True)\"\"\"\n    ...",
    "/typeshed/stdlib/types.pyi": "import sys\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    __hash__: None  # type: ignore\n    cell_contents: Any\n\n@final\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    __globals__: dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: None  # type: ignore\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: dict[str, Any]\n    __package__: str | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: GeneratorType[_T_co, _T_contra, Any] | None\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Awaitable[Any] | None\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\n@final\nclass CoroutineType:\n    cr_await: Any | None\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: object | None, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    __closure__: Tuple[_Cell, ...] | None  # inherited from the added function\n    __defaults__: Tuple[Any, ...] | None  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    __self__: object | ModuleType\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    @final\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    @final\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\n@final\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(\n            self,\n            tb_next: TracebackType | None,\n            tb_frame: FrameType,\n            tb_lasti: int,\n            tb_lineno: int,\n        ) -> None: ...\n        tb_next: TracebackType | None\n    else:\n        @property\n        def tb_next(self) -> TracebackType | None: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    f_back: FrameType | None\n    f_builtins: dict[str, Any]\n    f_code: CodeType\n    f_globals: dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: dict[str, Any]\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: dict[str, Any] | None = ...\n) -> Tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    @final\n    class UnionType:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> UnionType: ...\n        def __ror__(self, obj: Any) -> UnionType: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = ...,\n    localns: dict[str, Any] | None = ...,\n    include_extras: bool = ...,\n) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Type[Any] | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: None | Type[Any] | str = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "from array import *\n",
    "/typeshed/stdlib/ucollections.pyi": "from collections import *\n",
    "/typeshed/stdlib/uerrno.pyi": "from errno import *\n",
    "/typeshed/stdlib/urandom.pyi": "from random import *\n",
    "/typeshed/stdlib/ustruct.pyi": "from struct import *\n",
    "/typeshed/stdlib/usys.pyi": "from sys import *\n",
    "/typeshed/stdlib/utime.pyi": "from time import *\n",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any]]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any]]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"Pinnen, afbeeldingen, geluiden, temperatuur en volume.\"\"\"\nfrom typing import Any, Callable, List, Optional, Tuple, Union, overload\nfrom _typeshed import ReadableBuffer\nfrom . import accelerometer as accelerometer\nfrom . import audio as audio\nfrom . import compass as compass\nfrom . import display as display\nfrom . import i2c as i2c\nfrom . import microphone as microphone\nfrom . import speaker as speaker\nfrom . import spi as spi\nfrom . import uart as uart\n\ndef run_every(callback: Optional[Callable[[], None]]=None, days: int=0, h: int=0, min: int=0, s: int=0, ms: int=0) -> Callable[[Callable[[], None]], Callable[[], None]]:\n    \"\"\"Plan om een functie uit te voeren volgens het interval dat gespecificeerd is door het time argument  **V2 alleen**. (draai elke)\n\nExample: ``run_every(my_logging, min=5)``\n\n``run_every`` can be used in two ways:\n\nAs a Decorator - placed on top of the function to schedule. For example::\n\n    @run_every(h=1, min=20, s=30, ms=50)\n    def my_function():\n        # Do something here\n\nAs a Function - passing the callback as a positional argument. For example::\n\n    def my_function():\n        # Do something here\n    run_every(my_function, s=30)\n\nEach argument corresponds to a different time unit and they are additive.\nSo ``run_every(min=1, s=30)`` schedules the callback every minute and a half.\n\nWhen an exception is thrown inside the callback function it deschedules the\nfunction. To avoid this you can catch exceptions with ``try/except``.\n\n:param callback: Functie om op te roepen bij de meegeleverde interval. Weglaten wanneer je als decorator gebruikt.\n:param days: (dagen) Stelt de dag markering in voor de planning.\n:param h: (uur) Stelt de urenmarkering in voor de planning.\n:param min: Stelt de minuut markering in voor de planning.\n:param s: Stelt de seconde markering in voor de planning.\n:param ms: Stelt de milliseconde markering in voor de planning.\"\"\"\n\ndef panic(n: int) -> None:\n    \"\"\"Voer een paniekmodus in. (paniek)\n\nExample: ``panic(127)``\n\n:param n: Een willekeurig geheel getal <= 255 om een status aan te geven.\n\nRequires restart.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Herstart het bord.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[int, int]) -> int:\n    \"\"\"Zet een waarde om van een bereik naar een ander bereik van natuurlijke getallen. (schaal)\n\nExample: ``volume = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))``\n\nFor example, to convert an accelerometer X value to a speaker volume.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\n\n    temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))\n\n:param value: (waarde) Een getal om te converteren\n:param from_: (van) Een getallen paar wat het bereik aangeeft vanwaar je wilt converteren\n:param to: (naar) Een getallen paar om het bereik te defini\u00ebren waar je naar wilt converteren.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[float, float]) -> float:\n    \"\"\"Zet een waarde om van een bereik naar een ander bereik van decimale getallen. (schaal)\n\nExample: ``temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))``\n\nFor example, to convert temperature from a Celsius scale to Fahrenheit.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\nIf they are both integers (i.e ``10``), it will return an integer::\n\n    returns_int = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))\n\n:param value: (waarde) Een getal om te converteren\n:param from_: (van) Een getallen paar wat het bereik aangeeft vanwaar je wilt converteren\n:param to: (naar) Een getallen paar om het bereik te defini\u00ebren waar je naar wilt converteren.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\ndef sleep(n: float) -> None:\n    \"\"\"Wacht op ``n`` milliseconden. (slapen)\n\nExample: ``sleep(1000)``\n\n:param n: Het aantal milliseconden te wachten\n\nOne second is 1000 milliseconds, so::\n\n    microbit.sleep(1000)\n\nwill pause the execution for one second.\"\"\"\n\ndef running_time() -> int:\n    \"\"\"Bekijk de looptijd van het bord. (looptijd)\n\n:return: The number of milliseconds since the board was switched on or restarted.\"\"\"\n\ndef temperature() -> int:\n    \"\"\"Krijg de temperatuur van de micro:bit in graden Celsius. (temperatuur)\"\"\"\n\ndef set_volume(v: int) -> None:\n    \"\"\"Stelt het volume in. (stel volume in)\n\nExample: ``set_volume(127)``\n\n:param v: een waarde tussen 0 (laag) en 255 (hoog).\n\nOut of range values will be clamped to 0 or 255.\n\n**V2** only.\"\"\"\n    ...\n\nclass Button:\n    \"\"\"De klasse voor de knoppen ``button_a`` en ``button_b``. (knop)\"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"Controleer of op de knop wordt gedrukt. (is ingedrukt)\n\n:return: ``True`` if the specified button ``button`` is pressed, and ``False`` otherwise.\"\"\"\n        ...\n\n    def was_pressed(self) -> bool:\n        \"\"\"Controleer of de knop was ingedrukt sinds het apparaat is gestart of de laatste keer dat deze methode is gebruikt. (was ingedrukt)\n\nCalling this method will clear the press state so\nthat the button must be pressed again before this method will return\n``True`` again.\n\n:return: ``True`` if the specified button ``button`` was pressed, and ``False`` otherwise\"\"\"\n        ...\n\n    def get_presses(self) -> int:\n        \"\"\"Krijg het totale aantal ingedrukte knoppen en reset dit totaal\nnaar nul voordat u terugkeert. (zie knop acties)\n\n:return: The number of presses since the device started or the last time this method was called\"\"\"\n        ...\nbutton_a: Button\n\"\"\"Het object van de linker knop ``Button``. (knop a)\"\"\"\nbutton_b: Button\n\"\"\"Het object van de rechter knop ``Button``. (knop b)\"\"\"\n\nclass MicroBitDigitalPin:\n    \"\"\"Een digitale pin\n\nSome pins support analog and touch features using the ``MicroBitAnalogDigitalPin`` and ``MicroBitTouchPin`` subclasses.\"\"\"\n    NO_PULL: int\n    PULL_UP: int\n    PULL_DOWN: int\n\n    def read_digital(self) -> int:\n        \"\"\"Haal de digitale waarde van de pincode op. (digitaal lezen)\n\nExample: ``value = pin0.read_digital()``\n\n:return: 1 if the pin is high, and 0 if it's low.\"\"\"\n        ...\n\n    def write_digital(self, value: int) -> None:\n        \"\"\"Stel de digitale waarde van de pin in. (digitaal schrijven)\n\nExample: ``pin0.write_digital(1)``\n\n:param value: (waarde) 1 om de pin hoog of 0 om de pin laag in te stellen\"\"\"\n        ...\n\n    def set_pull(self, value: int) -> None:\n        \"\"\"Zet de pull-status op een van de drie mogelijke waarden: ``PULL_UP``, ``PULL_DOWN`` of ``NO_PULL``. (pull instellen)\n\nExample: ``pin0.set_pull(pin0.PULL_UP)``\n\n:param value: (waarde) De pull-status van de relevante pincode, bijvoorbeeld ``pin0.PULL_UP``.\"\"\"\n        ...\n\n    def get_pull(self) -> int:\n        \"\"\"Bekijk de pull status van een pin. (pull instellen)\n\nExample: ``pin0.get_pull()``\n\n:return: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``\n\nThese are set using the ``set_pull()`` method or automatically configured\nwhen a pin mode requires it.\"\"\"\n        ...\n\n    def get_mode(self) -> str:\n        \"\"\"Geeft de pinmodus weer. (Bekijk modus)\n\nExample: ``pin0.get_mode()``\n\nWhen a pin is used for a specific function, like\nwriting a digital value, or reading an analog value, the pin mode\nchanges.\n\n:return: ``\"unused\"``, ``\"analog\"``, ``\"read_digital\"``, ``\"write_digital\"``, ``\"display\"``, ``\"button\"``, ``\"music\"``, ``\"audio\"``, ``\"touch\"``, ``\"i2c\"``, or ``\"spi\"``\"\"\"\n        ...\n\n    def write_analog(self, value: int) -> None:\n        \"\"\"Voer een PWM-signaal uit op de pin, waarbij de taakcyclus proportioneel is aan ``value``. (analoge schrijven)\n\nExample: ``pin0.write_analog(254)``\n\n:param value: (waarde) Een geheel getal of een zwevend punt getal tussen 0 (0% tariefcyclus) en 1023 (100% belasting).\"\"\"\n\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"Stel de periode in van het PWM-signaal dat uitgevoerd wordt naar ``period`` in milliseconden. (gebruik analoge periode)\n\nExample: ``pin0.set_analog_period(10)``\n\n:param period: (periode) De periode in milliseconden met een minimale geldige waarde van 1 ms.\"\"\"\n\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"Stel de periode in van het PWM-signaal dat uitgevoerd wordt naar ``period`` in milliseconden. (microseconden analoge periode instellen)\n\nExample: ``pin0.set_analog_period_microseconds(512)``\n\n:param period: (periode) De periode in microseconden met een minimumwaarde van 256 mres.\"\"\"\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    \"\"\"Een pin met analoge en digitale functies.\"\"\"\n\n    def read_analog(self) -> int:\n        \"\"\"Lees de spanning op de pin. (lees analoge)\n\nExample: ``pin0.read_analog()``\n\n:return: An integer between 0 (meaning 0V) and 1023 (meaning 3.3V).\"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    \"\"\"Een pin met analoge, digitale en touch functies.\"\"\"\n    CAPACITIVE: int\n    RESISTIVE: int\n\n    def is_touched(self) -> bool:\n        \"\"\"Controleer of de pin aangeraakt wordt. (is aangeraakt)\n\nExample: ``pin0.is_touched()``\n\nThe default touch mode for the pins on the edge connector is ``resistive``.\nThe default for the logo pin **V2** is ``capacitive``.\n\n**Resistive touch**\nThis test is done by measuring how much resistance there is between the\npin and ground.  A low resistance gives a reading of ``True``.  To get\na reliable reading using a finger you may need to touch the ground pin\nwith another part of your body, for example your other hand.\n\n**Capacitive touch**\nThis test is done by interacting with the electric field of a capacitor\nusing a finger as a conductor. `Capacitive touch\n<https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_\ndoes not require you to make a ground connection as part of a circuit.\n\n:return: ``True`` if the pin is being touched with a finger, otherwise return ``False``.\"\"\"\n        ...\n\n    def set_touch_mode(self, value: int) -> None:\n        \"\"\"Stel de aanraakmodus voor de pin in. (aanraakmodus instellen)\n\nExample: ``pin0.set_touch_mode(pin0.CAPACITIVE)``\n\nThe default touch mode for the pins on the edge connector is\n``resistive``. The default for the logo pin **V2** is ``capacitive``.\n\n:param value: (waarde) ``CAPACITIVE`` of ``RESISTIVE`` van de relevante speler.\"\"\"\n        ...\npin0: MicroBitTouchPin\n\"\"\"Pin met digitale, analoge en touch functies.\"\"\"\npin1: MicroBitTouchPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin2: MicroBitTouchPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin3: MicroBitAnalogDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin4: MicroBitAnalogDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin5: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin6: MicroBitDigitalPin\n\"\"\"Pin met digitale functies.\"\"\"\npin7: MicroBitDigitalPin\n\"\"\"Pin met digitale functies.\"\"\"\npin8: MicroBitDigitalPin\n\"\"\"Pin met digitale functies.\"\"\"\npin9: MicroBitDigitalPin\n\"\"\"Pin met digitale functies.\"\"\"\npin10: MicroBitAnalogDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin11: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin12: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin13: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin14: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin15: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin16: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin19: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin20: MicroBitDigitalPin\n\"\"\"Pin met digitale, analoge en aanraak functies.\"\"\"\npin_logo: MicroBitTouchPin\n\"\"\"Een aanraak gevoelige logo pin op de voorkant van de micro:bit, die standaard is ingesteld op capacitieve aanraking modus.\"\"\"\npin_speaker: MicroBitAnalogDigitalPin\n\"\"\"Een pin om de micro:bit luidspreker aan te spreken. (pin luidspreker)\n\nThis API is intended only for use in Pulse-Width Modulation pin operations e.g. pin_speaker.write_analog(128).\n\"\"\"\n\nclass Image:\n    \"\"\"Een afbeelding om te laten zien op het micro:bit LED display. (afbeelding)\n\nGiven an image object it's possible to display it via the ``display`` API::\n\n    display.show(Image.HAPPY)\"\"\"\n    HEART: Image\n    \"\"\"Hart afbeelding (hart)\"\"\"\n    HEART_SMALL: Image\n    \"\"\"Klein hart afbeelding. (hart klein)\"\"\"\n    HAPPY: Image\n    \"\"\"Blije gezichtsafbeelding. (blij)\"\"\"\n    SMILE: Image\n    \"\"\"Glimlach gezicht afbeelding. (glimlach)\"\"\"\n    SAD: Image\n    \"\"\"Droevige gezichtsafbeelding. (verdrietig)\"\"\"\n    CONFUSED: Image\n    \"\"\"Verward gezichtsafbeelding. (verward)\"\"\"\n    ANGRY: Image\n    \"\"\"Boos gezichtsafbeelding. (kwaad)\"\"\"\n    ASLEEP: Image\n    \"\"\"Slapend gezicht afbeelding. (in slaap)\"\"\"\n    SURPRISED: Image\n    \"\"\"Verraste gezichtsafbeelding. (verrast)\"\"\"\n    SILLY: Image\n    \"\"\"Gek gezichtsafbeelding. (gek)\"\"\"\n    FABULOUS: Image\n    \"\"\"Zonnebril gezichtsafbeelding. (fantastisch)\"\"\"\n    MEH: Image\n    \"\"\"Niet onder de indruk gezichtsafbeelding.\"\"\"\n    YES: Image\n    \"\"\"Aanvinken afbeelding. (ja)\"\"\"\n    NO: Image\n    \"\"\"Kruis afbeelding. (nee)\"\"\"\n    CLOCK12: Image\n    \"\"\"Afbeelding met lijn die naar 12.00 uur wijst. (klok 12)\"\"\"\n    CLOCK11: Image\n    \"\"\"Afbeelding met lijn die naar 11.00 uur wijst. (klok 11)\"\"\"\n    CLOCK10: Image\n    \"\"\"Afbeelding met lijn die naar 10.00 uur wijst. (klok 10)\"\"\"\n    CLOCK9: Image\n    \"\"\"Afbeelding met lijn die naar 9.00 uur wijst. (klok 9)\"\"\"\n    CLOCK8: Image\n    \"\"\"Afbeelding met lijn die naar 8.00 uur wijst. (klok 8)\"\"\"\n    CLOCK7: Image\n    \"\"\"Afbeelding met lijn die naar 7.00 uur wijst. (klok 7)\"\"\"\n    CLOCK6: Image\n    \"\"\"Afbeelding met lijn die naar 6.00 uur wijst. (klok 6)\"\"\"\n    CLOCK5: Image\n    \"\"\"Afbeelding met lijn die naar 5.00 uur wijst. (klok 5)\"\"\"\n    CLOCK4: Image\n    \"\"\"Afbeelding met lijn die naar 4.00 uur wijst. (klok 4)\"\"\"\n    CLOCK3: Image\n    \"\"\"Afbeelding met lijn die naar 3.00 uur wijst. (klok 3)\"\"\"\n    CLOCK2: Image\n    \"\"\"Afbeelding met lijn die naar 2 uur wijst. (klok2)\"\"\"\n    CLOCK1: Image\n    \"\"\"Afbeelding met lijn die naar 1 uur wijst. (klok1)\"\"\"\n    ARROW_N: Image\n    \"\"\"Afbeelding van pijl richting het noorden. (pijl n)\"\"\"\n    ARROW_NE: Image\n    \"\"\"Afbeelding van pijl richting het noord oosten. (pijl NO)\"\"\"\n    ARROW_E: Image\n    \"\"\"Afbeelding van pijl richting het oosten. (pijl e)\"\"\"\n    ARROW_SE: Image\n    \"\"\"Afbeelding van pijl richting het zuid-oosten. (pijl ZO)\"\"\"\n    ARROW_S: Image\n    \"\"\"Afbeelding van pijltje richting het zuiden. (pijl z)\"\"\"\n    ARROW_SW: Image\n    \"\"\"Afbeelding van pijl richting het zuid-westen. (pijl ZW)\"\"\"\n    ARROW_W: Image\n    \"\"\"Afbeelding van pijl richting het westen. (pijl w)\"\"\"\n    ARROW_NW: Image\n    \"\"\"Afbeelding van pijl richting het noord-westen. (pijl NW)\"\"\"\n    TRIANGLE: Image\n    \"\"\"Afbeelding van een driehoek die naar boven wijst. (driehoek)\"\"\"\n    TRIANGLE_LEFT: Image\n    \"\"\"Afbeelding van een driehoek in de linker hoek. (Driehoek links)\"\"\"\n    CHESSBOARD: Image\n    \"\"\"Alternatieve LED's verlichten in een schaakbord patroon. (schaakbord)\"\"\"\n    DIAMOND: Image\n    \"\"\"Diamanten afbeelding. (diamant)\"\"\"\n    DIAMOND_SMALL: Image\n    \"\"\"Kleine diamanten afbeelding. (diamant klein)\"\"\"\n    SQUARE: Image\n    \"\"\"Vierkante afbeelding (vierkant)\"\"\"\n    SQUARE_SMALL: Image\n    \"\"\"Kleine vierkante afbeelding. (vierkant klein)\"\"\"\n    RABBIT: Image\n    \"\"\"Konijn afbeelding. (konijn)\"\"\"\n    COW: Image\n    \"\"\"Koe afbeelding. (koe)\"\"\"\n    MUSIC_CROTCHET: Image\n    \"\"\"Kwartnoot afbeelding. (muziek kwartnoot)\"\"\"\n    MUSIC_QUAVER: Image\n    \"\"\"Kwartnoot afbeelding. (muziek kwartnoot)\"\"\"\n    MUSIC_QUAVERS: Image\n    \"\"\"Koppel van kwartnoten afbeelding. (muziek kwartnoten)\"\"\"\n    PITCHFORK: Image\n    \"\"\"Stemvork afbeelding. (stemvork)\"\"\"\n    XMAS: Image\n    \"\"\"Kerstboom afbeelding. (kerstmis)\"\"\"\n    PACMAN: Image\n    \"\"\"Pac-Man arcade karakterafbeelding. (Pacman)\"\"\"\n    TARGET: Image\n    \"\"\"Doel afbeelding. (doel)\"\"\"\n    TSHIRT: Image\n    \"\"\"T-shirt afbeelding.\"\"\"\n    ROLLERSKATE: Image\n    \"\"\"Rolschaats afbeelding. (rolschaatsen)\"\"\"\n    DUCK: Image\n    \"\"\"Eend afbeelding. (eend)\"\"\"\n    HOUSE: Image\n    \"\"\"Huis afbeelding. (huis)\"\"\"\n    TORTOISE: Image\n    \"\"\"Schildpad afbeelding. (schildpad)\"\"\"\n    BUTTERFLY: Image\n    \"\"\"Vlinder afbeelding. (vlinder)\"\"\"\n    STICKFIGURE: Image\n    \"\"\"Stok figuur afbeelding. (stok figuur)\"\"\"\n    GHOST: Image\n    \"\"\"Spook afbeelding. (spook)\"\"\"\n    SWORD: Image\n    \"\"\"Zwaard afbeelding. (zwaard)\"\"\"\n    GIRAFFE: Image\n    \"\"\"Giraffe afbeelding.\"\"\"\n    SKULL: Image\n    \"\"\"Schedel afbeelding. (doodshoofd)\"\"\"\n    UMBRELLA: Image\n    \"\"\"Paraplu afbeelding. (paraplu)\"\"\"\n    SNAKE: Image\n    \"\"\"Slang afbeelding. (slang)\"\"\"\n    SCISSORS: Image\n    \"\"\"Schaar afbeelding. (schaar)\"\"\"\n    ALL_CLOCKS: List[Image]\n    \"\"\"Een lijst met alle CLOCK_ afbeeldingen achter elkaar. (alle klokken)\"\"\"\n    ALL_ARROWS: List[Image]\n    \"\"\"Een lijst met alle ARROW_ afbeeldingen in reeks. (alle pijlen)\"\"\"\n\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"Maak een afbeelding van een tekenreeks die beschrijft welke LED's zijn. (initialiseren)\n\n``string`` has to consist of digits 0-9 arranged into lines,\ndescribing the image, for example::\n\n    image = Image(\"90009:\"\n                  \"09090:\"\n                  \"00900:\"\n                  \"09090:\"\n                  \"90009\")\n\nwill create a 5\u00d75 image of an X. The end of a line is indicated by a\ncolon. It's also possible to use newlines (\\\\n) insead of the colons.\n\n:param string: (tekenreeks) De tekenreeks die de afbeelding beschrijft.\"\"\"\n        ...\n\n    @overload\n    def __init__(self, width: int=5, height: int=5, buffer: ReadableBuffer=None) -> None:\n        \"\"\"Maak een lege afbeelding met ``width`` kolommen en ``height`` rijen. (initialiseren)\n\n:param width: (breedte) Optionele breedte van de afbeelding\n:param height: (hoogte) Optionele hoogte van de afbeelding\n:param buffer: Optionele array of bytes van ``width``\u00d7``height`` integers in bereik 0-9 om de afbeelding te initialiseren\n\nExamples::\n\n    Image(2, 2, b'\\x08\\x08\\x08\\x08')\n    Image(2, 2, bytearray([9,9,9,9]))\n\nThese create 2 x 2 pixel images at full brightness.\"\"\"\n        ...\n\n    def width(self) -> int:\n        \"\"\"Haal het aantal kolommen op. (breedte)\n\n:return: The number of columns in the image\"\"\"\n        ...\n\n    def height(self) -> int:\n        \"\"\"Krijg het aantal rijen. (hoogte)\n\n:return: The number of rows in the image\"\"\"\n        ...\n\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"Stel de helderheid van een pixel in. (pixel instellen)\n\nExample: ``my_image.set_pixel(0, 0, 9)``\n\n:param x: (\u0445) Het kolom nummer\n:param y: Het rij nummer\n:param value: (waarde) De helderheid als een geheel getal tussen 0 (donker) en 9 (helder)\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"Krijg de helderheid van een pixel. (verkrijg pixel)\n\nExample: ``my_image.get_pixel(0, 0)``\n\n:param x: (\u0445) Het kolom nummer\n:param y: Het rij nummer\n:return: The brightness as an integer between 0 and 9.\"\"\"\n        ...\n\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de afbeelding naar links te verschuiven. (verschuiving naar links)\n\nExample: ``Image.HEART_SMALL.shift_left(1)``\n\n:param n: Het aantal te verschuiven kolommen\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de afbeelding rechts te verschuiven. (verschuif Rechts)\n\nExample: ``Image.HEART_SMALL.shift_right(1)``\n\n:param n: Het aantal te verschuiven kolommen\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de afbeelding omhoog te schuiven. (verschuiving omhoog)\n\nExample: ``Image.HEART_SMALL.shift_up(1)``\n\n:param n: Het aantal rijen om te verschuiven met\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de afbeelding omlaag te verschuiven. (verschuif omlaag)\n\nExample: ``Image.HEART_SMALL.shift_down(1)``\n\n:param n: Het aantal rijen om te verschuiven met\n:return: The shifted image\"\"\"\n        ...\n\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de afbeelding bij te snijden. (bij snijden)\n\nExample: ``Image.HEART.crop(1, 1, 3, 3)``\n\n:param x: (\u0445) De kolom verschuiving\n:param y: De rij verschuiving\n:param w: De bij snij breedte\n:param h: (uur) Hoogte bijsnijden\n:return: The new image\"\"\"\n        ...\n\n    def copy(self) -> Image:\n        \"\"\"Maak een exacte kopie van de afbeelding. (kopi\u00eber)\n\nExample: ``Image.HEART.copy()``\n\n:return: The new image\"\"\"\n        ...\n\n    def invert(self) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de helderheid van de pixels in de\nbronafbeelding om te draaien. (omkeren)\n\nExample: ``Image.SMALL_HEART.invert()``\n\n:return: The new image.\"\"\"\n        ...\n\n    def fill(self, value: int) -> None:\n        \"\"\"Stel de helderheid van alle pixels in de afbeelding in. (opvullen)\n\nExample: ``my_image.fill(5)``\n\n:param value: (waarde) De nieuwe helderheid als een getal tussen 0 (donker) en 9 (helder).\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def blit(self, src: Image, x: int, y: int, w: int, h: int, xdest: int=0, ydest: int=0) -> None:\n        \"\"\"Kopieer een gebied van een andere afbeelding naar deze afbeelding.\n\nExample: ``my_image.blit(Image.HEART, 1, 1, 3, 3, 1, 1)``\n\n:param src: De bron afbeelding\n:param x: (\u0445) De begin kolom offset in de bron afbeelding\n:param y: De beginkolom offset in de bronafbeelding\n:param w: Het aantal te kopi\u00ebren kolommen\n:param h: (uur) Het aantal te kopi\u00ebren rijen\n:param xdest: De kolomverschuiving om aan te passen in deze afbeelding\n:param ydest: De kolomverschuiving om aan te passen in deze afbeelding\n\nPixels outside the source image are treated as having a brightness of 0.\n\n``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\nand ``crop()`` can are all implemented by using ``blit()``.\n\nFor example, img.crop(x, y, w, h) can be implemented as::\n\n    def crop(self, x, y, w, h):\n        res = Image(w, h)\n        res.blit(self, x, y, w, h)\n        return res\"\"\"\n        ...\n\n    def __repr__(self) -> str:\n        \"\"\"Krijg een compacte tekenreeks die de afbeelding vertegenwoordigt.\"\"\"\n        ...\n\n    def __str__(self) -> str:\n        \"\"\"Krijg een leesbare tekenreeks die de afbeelding vertegenwoordigt.\"\"\"\n        ...\n\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de helderheidswaarden van de twee\nafbeeldingen voor elke pixel toe te voegen. (toevoegen)\n\nExample: ``Image.HEART + Image.HAPPY``\n\n:param other: (overige) De afbeelding om toe te voegen.\"\"\"\n        ...\n\n    def __sub__(self, other: Image) -> Image:\n        \"\"\"Maak een nieuw beeld door de helderheidswaarden van de andere afbeelding van deze afbeelding af te trekken.\n\nExample: ``Image.HEART - Image.HEART_SMALL``\n\n:param other: (overige) De afbeelding om af te trekken.\"\"\"\n        ...\n\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de helderheid van elke pixel te vermenigvuldigen met\n``n``.\n\nExample: ``Image.HEART * 0.5``\n\n:param n: De waarde om te vermenigvuldigen.\"\"\"\n        ...\n\n    def __truediv__(self, n: float) -> Image:\n        \"\"\"Maak een nieuwe afbeelding door de helderheid van elke pixel te delen door\n``n``.\n\nExample: ``Image.HEART / 2``\n\n:param n: De waarde om mee te delen.\"\"\"\n        ...\n\nclass SoundEvent:\n    LOUD: SoundEvent\n    \"\"\"Vertegenwoordigt de transitie van geluidsgebeurtenissen, van ``quiet`` tot ``loud`` zoals klappen of roepen. (luid)\"\"\"\n    QUIET: SoundEvent\n    \"\"\"Vertegenwoordigt de transitie van geluidsgebeurtenissen, van ``loud`` tot ``quiet`` zoals spreken of achtergrondmuziek. (stil)\"\"\"\n\nclass Sound:\n    \"\"\"De ingebouwde geluiden kunnen worden aangeroepen met ``audio.play(Sound.NAME)``. (geluid)\"\"\"\n    GIGGLE: Sound\n    \"\"\"Giechelgeluidjes (giechelen)\"\"\"\n    HAPPY: Sound\n    \"\"\"Blij geluid. (blij)\"\"\"\n    HELLO: Sound\n    \"\"\"Groet geluid. (hallo)\"\"\"\n    MYSTERIOUS: Sound\n    \"\"\"Mysterieus geluid. (mysterieus)\"\"\"\n    SAD: Sound\n    \"\"\"Droevig geluid. (verdrietig)\"\"\"\n    SLIDE: Sound\n    \"\"\"Glij geluid. (Veeg)\"\"\"\n    SOARING: Sound\n    \"\"\"Zweef geluid. (stijgend)\"\"\"\n    SPRING: Sound\n    \"\"\"Spring geluid. (veer)\"\"\"\n    TWINKLE: Sound\n    \"\"\"Twinkel geluid. (twinkeling)\"\"\"\n    YAWN: Sound\n    \"\"\"Geeuwgeluiden (geeuw)\"\"\"",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"Meet de versnelling van de micro:bit en herken gebaren. (acceleratiemeter)\"\"\"\nfrom typing import Tuple\n\ndef get_x() -> int:\n    \"\"\"Krijg de acceleratiemeting in de ``x`` as in milli-g. (krijg x)\n\nExample: ``accelerometer.get_x()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Krijg de acceleratiemeting in de ``y`` as in milli-g. (krijg y)\n\nExample: ``accelerometer.get_y()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Krijg de acceleratiemeter meting in de ``z`` as in milli-g. (krijg z)\n\nExample: ``accelerometer.get_z()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"Verkrijg de acceleratiemeter metingen in alle assen tegelijk als een tupel. (krijg waarden)\n\nExample: ``x, y, z = accelerometer.get_values()``\n\n:return: a three-element tuple of integers ordered as X, Y, Z, each value a positive or negative integer depending on direction in the range +/- 2000mg\"\"\"\n    ...\n\ndef get_strength() -> int:\n    \"\"\"Krijg de versnelling meting van alle assen gecombineerd, als een positief getal. Dit is de Pythagorische som van de X, Y en Z assen. (krijg sterkte)\n\nExample: ``accelerometer.get_strength()``\n\n:return: The combined acceleration strength of all the axes, in milli-g.\"\"\"\n    ...\n\ndef current_gesture() -> str:\n    \"\"\"Verkrijg de naam van het huidige gebaar. (huidig gebaar)\n\nExample: ``accelerometer.current_gesture()``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:return: The current gesture\"\"\"\n    ...\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"Controleer of het benoemde gebaar momenteel actief is. (is gebaren)\n\nExample: ``accelerometer.is_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (naam) De naam van het gebaar.\n:return: ``True`` if the gesture is active, ``False`` otherwise.\"\"\"\n    ...\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"Controleer of het benoemde gebaar actief was sinds het laatste gesprek. (was gebaren)\n\nExample: ``accelerometer.was_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (naam) De naam van het gebaar.\n:return: ``True`` if the gesture was active since the last call, ``False`` otherwise.\"\"\"\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Geeft als resultaat een reeks van de gebaren geschiedenis. (verkrijg gebaren)\n\nExample: ``accelerometer.get_gestures()``\n\nClears the gesture history before returning.\n\nGestures are not updated in the background so there needs to be constant\ncalls to some accelerometer method to do the gesture detection. Usually\ngestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n\n:return: The history as a tuple, most recent last.\"\"\"\n    ...\n\ndef set_range(value: int) -> None:\n    \"\"\"Stel het gevoeligheidsbereik van de acceleratiemeter, in g (standaard zwaartekracht), in op de dichtstbijzijnde waarden die door de hardware worden ondersteund, zodat het wordt afgerond op ``2``, ``4`` of ``8`` g. (kies bereik)\n\nExample: ``accelerometer.set_range(8)``\n\n:param value: (waarde) Nieuwe bereik voor de acceleratiemeter, een geheel getal in ``g``.\"\"\"",
    "/typeshed/stdlib/microbit/audio.pyi": "\"\"\"Geluid afspelen met behulp van de micro:bit (importeer ``audio`` voor V1 compatibiliteit).\"\"\"\nfrom ..microbit import MicroBitDigitalPin, Sound, pin0\nfrom typing import ClassVar, Iterable, Union\n\ndef play(source: Union[Iterable[AudioFrame], Sound, SoundEffect], wait: bool=True, pin: MicroBitDigitalPin=pin0, return_pin: Union[MicroBitDigitalPin, None]=None) -> None:\n    \"\"\"Een ingebouwde geluid, geluids effect of aangepaste audio frames afspelen. (afspelen)\n\nExample: ``audio.play(Sound.GIGGLE)``\n\n:param source: (bron) Een ingebouwde ``Sound`` zoals ``Sound.GIGGLE``, een ``SoundEffect`` of voorbeeldgegevens als een iteratie van ``AudioFrame`` objecten.\n:param wait: (wacht) Als ``wait`` ``True``is, wordt deze functie geblokkeerd totdat het geluid is voltooid.\n:param pin: Een optioneel argument om de uitvoerpin op te geven kan worden gebruikt om de standaard van ``pin0``te overschrijven. Als we geen geluid willen afspelen, kunnen we ``pin=None`` gebruiken.\n:param return_pin: (retourneer pin) Specificeert een differenti\u00eble rand connector pin om verbinding te maken met een externe luidspreker in plaats van de grond. Dit wordt genegeerd voor de **V2** herziening.\"\"\"\n\ndef is_playing() -> bool:\n    \"\"\"Controleer of een geluid wordt gespeeld. (speelt af)\n\nExample: ``audio.is_playing()``\n\n:return: ``True`` if audio is playing, otherwise ``False``.\"\"\"\n    ...\n\ndef stop() -> None:\n    \"\"\"Stop het afspelen van de audio.\n\nExample: ``audio.stop()``\"\"\"\n    ...\n\nclass SoundEffect:\n    \"\"\"Een geluidseffect, bestaande uit een set parameters geconfigureerd via de constructor of attributen.\"\"\"\n    WAVEFORM_SINE: ClassVar[int]\n    \"\"\"De sinusgolf optie gebruikt voor de ``waveform`` parameter. (golfvorm sinus)\"\"\"\n    WAVEFORM_SAWTOOTH: ClassVar[int]\n    \"\"\"Zaag golf optie gebruikt voor de ``waveform`` parameter. (golfvorm zaagtand)\"\"\"\n    WAVEFORM_TRIANGLE: ClassVar[int]\n    \"\"\"De drie hoeks golf optie gebruikt voor de ``waveform`` parameter. (golfvorm driehoek)\"\"\"\n    WAVEFORM_SQUARE: ClassVar[int]\n    \"\"\"Blok golf optie die wordt gebruikt voor de parameter ``waveform``. (golfvorm vierkant)\"\"\"\n    WAVEFORM_NOISE: ClassVar[int]\n    \"\"\"Noise optie gebruikt voor de ``waveform`` parameter. (golfvormig geluid)\"\"\"\n    SHAPE_LINEAR: ClassVar[int]\n    \"\"\"Lineaire interpolatie optie die wordt gebruikt voor de ``shape`` parameter. (vorm lineair)\"\"\"\n    SHAPE_CURVE: ClassVar[int]\n    \"\"\"Curve interpolatie optie gebruikt voor de ``shape`` parameter. (vorm curve)\"\"\"\n    SHAPE_LOG: ClassVar[int]\n    \"\"\"Logaritmische interpolatie optie gebruikt voor de ``shape`` parameter. (vorm log)\"\"\"\n    FX_NONE: ClassVar[int]\n    \"\"\"Geen effectoptie gebruikt voor de  ``fx`` parameter. (geen fx)\"\"\"\n    FX_TREMOLO: ClassVar[int]\n    \"\"\"Tremolo effect optie die wordt gebruikt voor de ``fx`` parameter.\"\"\"\n    FX_VIBRATO: ClassVar[int]\n    \"\"\"Vibrato effect optie die wordt gebruikt voor de ``fx`` parameter.\"\"\"\n    FX_WARBLE: ClassVar[int]\n    \"\"\"Warble effect optie die wordt gebruikt voor de ``fx`` parameter .\"\"\"\n    freq_start: int\n    \"\"\"Start frequentie in Hertz (Hz), een getal tussen ``0`` en ``9999`` (frequentie start)\"\"\"\n    freq_end: int\n    \"\"\"Eind frequentie in Hertz (Hz), een getal tussen ``0`` en ``9999`` (frequentie einde)\"\"\"\n    duration: int\n    \"\"\"Duur van het geluid in milliseconden, een getal tussen ``0`` en ``9999`` (Duur)\"\"\"\n    vol_start: int\n    \"\"\"Start volume waarde, een getal tussen ``0`` en ``255``\"\"\"\n    vol_end: int\n    \"\"\"Eind volume waarde, een getal tussen ``0`` en ``255`` (vol einde)\"\"\"\n    waveform: int\n    \"\"\"Type van golfvorm, \u00e9\u00e9n van deze waarden: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (willekeurig gegenereerde lawaai) (golfvorm)\"\"\"\n    fx: int\n    \"\"\"Effect om aan het geluid toe te voegen, een van de volgende waarden: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``of ``FX_NONE``\"\"\"\n    shape: int\n    \"\"\"Het type van de interpolatie curve tussen de begin- en eind frequenties, verschillende golfvormen hebben verschillende snelheid bij het wijzigen van de frequentie. Een van de volgende waarden: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG`` (vorm)\"\"\"\n\n    def __init__(self, freq_start: int=500, freq_end: int=2500, duration: int=500, vol_start: int=255, vol_end: int=0, waveform: int=WAVEFORM_SQUARE, fx: int=FX_NONE, shape: int=SHAPE_LOG):\n        \"\"\"Maak een nieuw geluidseffect. (initialiseren)\n\nExample: ``my_effect = SoundEffect(duration=1000)``\n\nAll the parameters are optional, with default values as shown above, and\nthey can all be modified via attributes of the same name. For example, we\ncan first create an effect ``my_effect = SoundEffect(duration=1000)``,\nand then change its attributes ``my_effect.duration = 500``.\n\n:param freq_start: (frequentie start) Start frequentie in Hertz (Hz), een getal tussen ``0`` en ``9999``.\n:param freq_end: (frequentie einde) Eind frequentie in Hertz (Hz), een getal tussen ``0`` en ``9999``.\n:param duration: (duur) Duur van het geluid in milliseconden, een getal tussen ``0`` en ``9999``.\n:param vol_start: Startvolumewaarde, een getal tussen ``0`` en ``255``.\n:param vol_end: (vol einde) Eindvolumewaarde, een getal tussen ``0`` en ``255``.\n:param waveform: (golfvorm) Type golfvorm, \u00e9\u00e9n van deze waarden: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (willekeurig gegenereerde geluid).\n:param fx: Effect om het geluid toe te voegen, een van de volgende waarden: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``of ``FX_NONE``.\n:param shape: (vorm) Het type van de interpolatie curve tussen de begin- en eind frequenties, verschillende golfvormen hebben verschillende snelheid bij het wijzigen van de frequentie. Een van de volgende waarden: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``.\"\"\"\n\n    def copy(self) -> SoundEffect:\n        \"\"\"Maak een kopie van dit ``SoundEffect``. (kopi\u00eber)\n\nExample: ``sound_2 = sound_1.copy()``\n\n:return: A copy of the SoundEffect.\"\"\"\n\nclass AudioFrame:\n    \"\"\"Een ``AudioFrame`` object is een lijst van 32 samples elk een niet-ondertekende byte\n(geheel getal tussen 0 en 255).\n\nIt takes just over 4 ms to play a single frame.\n\nExample::\n\n    frame = AudioFrame()\n    for i in range(len(frame)):\n        frame[i] = 252 - i * 8\"\"\"\n\n    def copyfrom(self, other: AudioFrame) -> None:\n        \"\"\"Overschrijf de gegevens in deze ``AudioFrame`` met de gegevens van een andere ``AudioFrame`` instantie. (kopieer van)\n\nExample: ``my_frame.copyfrom(source_frame)``\n\n:param other: (overige) ``AudioFrame`` exemplaar van waar de gegevens worden gekopieerd.\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __setitem__(self, key: int, value: int) -> None:\n        ...\n\n    def __getitem__(self, key: int) -> int:\n        ...",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"Gebruik het ingebouwde kompas. (kompas)\"\"\"\n\ndef calibrate() -> None:\n    \"\"\"Start het kalibratieproces. (Kalibreren)\n\nExample: ``compass.calibrate()``\n\nAn instructive message will be scrolled to the user after which they will need\nto rotate the device in order to draw a circle on the LED display.\"\"\"\n    ...\n\ndef is_calibrated() -> bool:\n    \"\"\"Controleer of het kompas is gekalibreerd. (gekalibreerd)\n\nExample: ``compass.is_calibrated()``\n\n:return: ``True`` if the compass has been successfully calibrated, ``False`` otherwise.\"\"\"\n    ...\n\ndef clear_calibration() -> None:\n    \"\"\"Kalibratie ongedaan maken, waardoor het kompas weer losgemaakt wordt. (kalibratie wissen)\n\nExample: ``compass.clear_calibration()``\"\"\"\n    ...\n\ndef get_x() -> int:\n    \"\"\"Krijg de magnetische veldsterkte op de ``x`` as. (krijg x)\n\nExample: ``compass.get_x()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Krijg de magnetische veldsterkte op de ``y`` as. (krijg y)\n\nExample: ``compass.get_y()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Krijg de magnetische veldsterkte op de ``z`` as. (krijg z)\n\nExample: ``compass.get_z()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef heading() -> int:\n    \"\"\"Haal de kompaskop op. (kop)\n\nExample: ``compass.heading()``\n\n:return: An integer in the range from 0 to 360, representing the angle in degrees, clockwise, with north as 0.\"\"\"\n    ...\n\ndef get_field_strength() -> int:\n    \"\"\"Krijg de magnitude van het magnetische veld rond het apparaat. (krijg veldsterkte)\n\nExample: ``compass.get_field_strength()``\n\n:return: An integer indication of the magnitude of the magnetic field in nano tesla.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"Tekst, afbeeldingen en animaties weergeven op het 5\u00d75 LED-weergave.\"\"\"\nfrom ..microbit import Image\nfrom typing import Union, overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"Krijg de helderheid van de LED in kolom ``x`` en rij ``y``. (verkrijg pixel)\n\nExample: ``display.get_pixel(0, 0)``\n\n:param x: (\u0445) De weergavekolom (0..4)\n:param y: De weergave rij (0.4)\n:return: A number between 0 (off) and 9 (bright)\"\"\"\n    ...\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"Stel de helderheid van de LED in op kolom ``x`` en rij ``y``. (pixel instellen)\n\nExample: ``display.set_pixel(0, 0, 9)``\n\n:param x: (\u0445) De weergavekolom (0..4)\n:param y: De weergave rij (0.4)\n:param value: (waarde) De helderheid tussen 0 (uit) en 9 (helderst)\"\"\"\n    ...\n\ndef clear() -> None:\n    \"\"\"Stel de helderheid van alle LED's in op 0 (uit). (wissen)\n\nExample: ``display.clear()``\"\"\"\n    ...\n\ndef show(image: Union[str, float, int, Image, Iterable[Image]], delay: int=400, wait: bool=True, loop: bool=False, clear: bool=False) -> None:\n    \"\"\"Toont afbeeldingen, letters of cijfers op het LED-scherm. (toon)\n\nExample: ``display.show(Image.HEART)``\n\nWhen ``image`` is an image or a list of images then each image is displayed in turn.\nIf ``image`` is a string or number, each letter or digit is displayed in turn.\n\n:param image: (afbeelding) Een string, nummer, afbeelding of lijst van weer te geven afbeeldingen.\n:param delay: (vertraging) Elke letter, cijfer of afbeelding wordt weergegeven met ``delay`` milliseconden tussen hen.\n:param wait: (wacht) Als ``wait`` ``True``is, blokkeert deze functie totdat de animatie is voltooid, anders gebeurt de animatie op de achtergrond.\n:param loop: Als ``loop`` ``True``is, zal de animatie voor altijd herhalen.\n:param clear: (wissen) Als ``clear`` ``True``is, wordt het scherm gewist nadat de reeks is voltooid.\n\nThe ``wait``, ``loop`` and ``clear`` arguments must be specified using their keyword.\"\"\"\n    ...\n\ndef scroll(text: Union[str, float, int], delay: int=150, wait: bool=True, loop: bool=False, monospace: bool=False) -> None:\n    \"\"\"Scrolt een nummer of tekst op het LED display (scrollen)\n\nExample: ``display.scroll('micro:bit')``\n\n:param text: (tekst) De tekenreeks om te scrollen. Als ``text`` een geheel getal of float is, wordt het eerst geconverteerd naar een tekenreeks met behulp van ``str()``.\n:param delay: (vertraging) De parameter ``delay`` bepaalt hoe snel de tekst scrolt.\n:param wait: (wacht) Als ``wait`` ``True``is, blokkeert deze functie totdat de animatie is voltooid, anders gebeurt de animatie op de achtergrond.\n:param loop: Als ``loop`` ``True``is, zal de animatie voor altijd herhalen.\n:param monospace: Als ``monospace`` ``True`` is, nemen de tekens allemaal 5 pixel kolommen in de breedte in beslag, anders staat er precies 1 lege pixelkolom tussen elk teken terwijl ze scrollen.\n\nThe ``wait``, ``loop`` and ``monospace`` arguments must be specified\nusing their keyword.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Schakel het LED display in. (aan)\n\nExample: ``display.on()``\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Het uitschakelen van het LED display (uitschakelen van het scherm geeft je de mogelijkheid om de GPIO-pinnen opnieuw te gebruiken voor andere doeleinden). (uit)\n\nExample: ``display.off()``\"\"\"\n    ...\n\ndef is_on() -> bool:\n    \"\"\"Controleer of de LED-weergave is ingeschakeld. (staat aan)\n\nExample: ``display.is_on()``\n\n:return: ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n    ...\n\ndef read_light_level() -> int:\n    \"\"\"Lees het licht niveau. (lees licht niveau)\n\nExample: ``display.read_light_level()``\n\nUses the display's LEDs in reverse-bias mode to sense the amount of light\nfalling on the display.\n\n:return: An integer between 0 and 255 representing the light level, with larger meaning more light.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"Communiceer met apparaten met behulp van het I\u00b2C bus protocol.\"\"\"\nfrom _typeshed import ReadableBuffer\nfrom ..microbit import MicroBitDigitalPin, pin19, pin20\nfrom typing import List\n\ndef init(freq: int=100000, sda: MicroBitDigitalPin=pin20, scl: MicroBitDigitalPin=pin19) -> None:\n    \"\"\"Initialiseer een randapparaat opnieuw. (initialiseren)\n\nExample: ``i2c.init()``\n\n:param freq: (frequentie) klok frequentie\n:param sda: ``sda`` pin (standaard 20)\n:param scl: ``scl`` pin (standaard 19)\n\nOn a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\nthe accelerometer and compass stop working, as they are connected\ninternally to those pins. This warning does not apply to the **V2**\nrevision of the micro:bit as this has `separate I\u00b2C lines <https://tech.microbit.org/hardware/i2c/>`_\nfor the motion sensors and the edge connector.\"\"\"\n    ...\n\ndef scan() -> List[int]:\n    \"\"\"Scan de bus op apparaten. (scannen)\n\nExample: ``i2c.scan()``\n\n:return: A list of 7-bit addresses corresponding to those devices that responded to the scan.\"\"\"\n    ...\n\ndef read(addr: int, n: int, repeat: bool=False) -> bytes:\n    \"\"\"Lees bytes van een apparaat. (lezen)\n\nExample: ``i2c.read(0x50, 64)``\n\n:param addr: Het 7-bit adres van het apparaat\n:param n: Het aantal te lezen bytes\n:param repeat: (herhaal) Als ``True``, zal er geen stop bit worden verzonden\n:return: The bytes read\"\"\"\n    ...\n\ndef write(addr: int, buf: ReadableBuffer, repeat: bool=False) -> None:\n    \"\"\"Schrijven van bytes naar een apparaat. (schrijven)\n\nExample: ``i2c.write(0x50, bytes([1, 2, 3]))``\n\n:param addr: Het 7-bit adres van het apparaat\n:param buf: Een buffer met de te schrijven bytes\n:param repeat: (herhaal) Als ``True``, zal er geen stop bit worden verzonden\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/microphone.pyi": "\"\"\"Reageer op geluid met de ingebouwde microfoon (V2 alleen). (microfoon)\"\"\"\nfrom typing import Optional, Tuple\nfrom ..microbit import SoundEvent\n\ndef current_event() -> Optional[SoundEvent]:\n    \"\"\"Krijg de laatst opgenomen geluidsgebeurtenis (huidige gebeurtenis)\n\nExample: ``microphone.current_event()``\n\n:return: The event, ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.\"\"\"\n    ...\n\ndef was_event(event: SoundEvent) -> bool:\n    \"\"\"Controleer of een geluid tenminste \u00e9\u00e9n keer is gehoord sinds het laatste gesprek.\n\nExample: ``microphone.was_event(SoundEvent.LOUD)``\n\nThis call clears the sound history before returning.\n\n:param event: (gebeurtenis) Het te controleren evenement, zoals ``SoundEvent.LOUD`` of ``SoundEvent.QUIET``\n:return: ``True`` if sound was heard at least once since the last call, otherwise ``False``.\"\"\"\n    ...\n\ndef is_event(event: SoundEvent) -> bool:\n    \"\"\"Controleer de meest recente geluidsgebeurtenis gedetecteerd.\n\nExample: ``microphone.is_event(SoundEvent.LOUD)``\n\nThis call does not clear the sound event history.\n\n:param event: (gebeurtenis) Het te controleren evenement, zoals ``SoundEvent.LOUD`` of ``SoundEvent.QUIET``\n:return: ``True`` if sound was the most recent heard, ``False`` otherwise.\"\"\"\n    ...\n\ndef get_events() -> Tuple[SoundEvent, ...]:\n    \"\"\"Krijg de geluidsgeschiedenis als tuple.\n\nExample: ``microphone.get_events()``\n\nThis call clears the sound history before returning.\n\n:return: A tuple of the event history with the most recent event last.\"\"\"\n    ...\n\ndef set_threshold(event: SoundEvent, value: int) -> None:\n    \"\"\"Stel de drempel in voor een geluidsgebeurtenis. (stel drempelwaarde in)\n\nExample: ``microphone.set_threshold(SoundEvent.LOUD, 250)``\n\nA high threshold means the event will only trigger if the sound is very loud (>= 250 in the example).\n\n:param event: (gebeurtenis) Een geluidsgebeurtenis, zoals ``SoundEvent.LOUD`` of ``SoundEvent.QUIET``.\n:param value: (waarde) Het drempelniveau in het bereik 0-255.\"\"\"\n    ...\n\ndef sound_level() -> int:\n    \"\"\"Krijg het Geluidsdrukniveau. (geluidsniveau)\n\nExample: ``microphone.sound_level()``\n\n:return: A representation of the sound pressure level in the range 0 to 255.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/speaker.pyi": "\"\"\"Beheer de ingebouwde luidspreker (alleen V2). (luidspreker)\"\"\"\n\ndef off() -> None:\n    \"\"\"Luidspreker uitschakelen. (uit)\n\nExample: ``speaker.off()``\n\nThis does not disable sound output to an edge connector pin.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Luidspreker inschakelen (aan)\n\nExample: ``speaker.on()``\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"Communiceer met apparaten met behulp van de seri\u00eble perifere interface (SPI) bus.\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom ..microbit import pin13, pin14, pin15, MicroBitDigitalPin\n\ndef init(baudrate: int=1000000, bits: int=8, mode: int=0, sclk: MicroBitDigitalPin=pin13, mosi: MicroBitDigitalPin=pin15, miso: MicroBitDigitalPin=pin14) -> None:\n    \"\"\"Initialiseer SPI communicatie. (initialiseren)\n\nExample: ``spi.init()``\n\nFor correct communication, the parameters have to be the same on both communicating devices.\n\n:param baudrate: De snelheid van de communicatie.\n:param bits: De breedte in bits van elke overdracht. Momenteel wordt alleen ``bits=8`` ondersteund. Dit kan echter veranderen in de toekomst.\n:param mode: (modus) Bepaalt de combinatie van klokpolariteit en fase - `zie online tabel <https://microbit-micropython.readthedocs.io/en/v2-docs/spi.html#microbit.spi.init>`_.\n:param sclk: sclk pin (standaard 13)\n:param mosi: mosi pin (standaard 15)\n:param miso: miso pin (standaard 14)\"\"\"\n    ...\n\ndef read(nbytes: int, out: int=0) -> bytes:\n    \"\"\"Lees minstens ``nbytes`` terwijl het enkele byte gegeven in ``out`` continu geschreven wordt. (lezen)\n\nExample: ``spi.read(64)``\n\n:param nbytes: Maximum aantal te lezen bytes.\n:param out: (uit) De byte-waarde om te schrijven (standaard 0).\n:return: The bytes read.\"\"\"\n    ...\n\ndef write(buffer: ReadableBuffer) -> None:\n    \"\"\"Schrijf bytes naar de bus. (schrijven)\n\nExample: ``spi.write(bytes([1, 2, 3]))``\n\n:param buffer: Een buffer om gegevens van te lezen.\"\"\"\n    ...\n\ndef write_readinto(out: WriteableBuffer, in_: ReadableBuffer) -> None:\n    \"\"\"Schrijf de ``out`` buffer naar de bus en lees elke reactie in de ``in_`` buffer. (schrijf readinto)\n\nExample: ``spi.write_readinto(out_buffer, in_buffer)``\n\nThe length of the buffers should be the same. The buffers can be the same object.\n\n:param out: (uit) De buffer om een reactie naar te schrijven.\n:param in_: De buffer om gegevens van te lezen.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"Communiceer met een apparaat via een seri\u00eble interface.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom ..microbit import MicroBitDigitalPin\nfrom typing import Optional, Union\nODD: int\n\"\"\"Oneven pariteit (oneven)\"\"\"\nEVEN: int\n\"\"\"Even pariteit\"\"\"\n\ndef init(baudrate: int=9600, bits: int=8, parity: Optional[int]=None, stop: int=1, tx: Optional[MicroBitDigitalPin]=None, rx: Optional[MicroBitDigitalPin]=None) -> None:\n    \"\"\"Initialiseer seri\u00eble communicatie. (initialiseren)\n\nExample: ``uart.init(115200, tx=pin0, rx=pin1)``\n\n:param baudrate: De snelheid van de communicatie.\n:param bits: De grootte van de bytes die worden verzonden. micro:bit ondersteunt slechts 8.\n:param parity: (pariteit) Hoe de pariteit is aangevinkt, ``None``, ``uart.ODD`` of ``uart.EVEN``.\n:param stop: Het aantal stop bits, moet 1 zijn voor micro:bit.\n:param tx: Verzend pin.\n:param rx: Ontvangende pin.\n\nInitializing the UART on external pins will cause the Python console on\nUSB to become unaccessible, as it uses the same hardware. To bring the\nconsole back you must reinitialize the UART without passing anything for\n``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\nthat calling ``uart.init(115200)`` is enough to restore the Python console.\n\nFor more details see `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/uart.html>`_.\"\"\"\n    ...\n\ndef any() -> bool:\n    \"\"\"Controleer of er nog gegevens staan te wachten. (elke)\n\nExample: ``uart.any()``\n\n:return: ``True`` if any data is waiting, else ``False``.\"\"\"\n    ...\n\ndef read(nbytes: Optional[int]=None) -> Optional[bytes]:\n    \"\"\"Lees bytes. (lezen)\n\nExample: ``uart.read()``\n\n:param nbytes: Als ``nbytes`` is gespecificeerd, lees dan maximaal zoveel bytes, anders lees zo veel mogelijk bytes\n:return: A bytes object or ``None`` on timeout\"\"\"\n    ...\n\ndef readinto(buf: WriteableBuffer, nbytes: Optional[int]=None) -> Optional[int]:\n    \"\"\"Lees bytes in de ``buf``. (inlezen)\n\nExample: ``uart.readinto(input_buffer)``\n\n:param buf: De buffer om naar te schrijven.\n:param nbytes: Als ``nbytes`` is gespecificeerd, lees dan hooguit zoveel bytes, anders lees ``len(buf)`` bytes.\n:return: number of bytes read and stored into ``buf`` or ``None`` on timeout.\"\"\"\n    ...\n\ndef readline() -> Optional[bytes]:\n    \"\"\"Lees een regel, eindigend in een nieuw karakter regel. (leesregel)\n\nExample: ``uart.readline()``\n\n:return: The line read or ``None`` on timeout. The newline character is included in the returned bytes.\"\"\"\n    ...\n\ndef write(buf: Union[bytes, str]) -> Optional[int]:\n    \"\"\"Schrijf bytes naar de bus. (schrijven)\n\nExample: ``uart.write('hello world')``\n\n:param buf: Een bytes object of een tekenreeks.\n:return: The number of bytes written, or ``None`` on timeout.\n\nExamples::\n\n    uart.write('hello world')\n    uart.write(b'hello world')\n    uart.write(bytes([1, 2, 3]))\"\"\"\n    ...",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Optional,\n    Reversible,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n)\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}