{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]\n    ) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "",
    "/typeshed/stdlib/array.pyi": "from typing import Generic, Iterable, MutableSequence, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode]\n\n_T = TypeVar(\"_T\", int, float)\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(\n        self: array[int],\n        typecode: _IntTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[float],\n        typecode: _FloatTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...\n    ) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n\nArrayType = array\n",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __slots__: str | Iterable[str]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls: Type[_T]) -> _T: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> str | Tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __name__: str\n    __qualname__: str\n    __text_signature__: str | None\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], dict: dict[str, Any], **kwds: Any\n    ) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: Type[_TT],\n        name: str,\n        bases: Tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwds: Any,\n    ) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> list[_TT]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(\n        metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any\n    ) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.UnionType: ...\n        def __ror__(self, t: Any) -> types.UnionType: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(\n        cls: Type[_T],\n        x: str | bytes | SupportsInt | SupportsIndex | _SupportsTrunc = ...,\n    ) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], x: str | bytes | bytearray, base: SupportsIndex\n    ) -> _T: ...\n    def to_bytes(\n        self,\n        length: SupportsIndex,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls,\n        bytes: Iterable[SupportsIndex] | SupportsBytes,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n    @overload\n    def __pow__(\n        self, __x: int, __modulo: int | None = ...\n    ) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(\n        cls: Type[_T], x: SupportsFloat | SupportsIndex | str | bytes | bytearray = ...\n    ) -> _T: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], real: str | SupportsComplex | SupportsIndex | complex\n    ) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...\n    ) -> _T: ...\n    def count(\n        self,\n        x: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self,\n        __suffix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def index(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: str | None = ...) -> str: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    def rfind(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def rstrip(self, __chars: str | None = ...) -> str: ...\n    def split(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def startswith(\n        self,\n        __prefix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __chars: str | None = ...) -> str: ...\n    def upper(self) -> str: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: int | slice) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ByteString | memoryview]) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytes: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray:\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[_T_co | _T, ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(\n        self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n\n# Can we remove this?\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: dict[str, Any]\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls: type[Self]) -> Self: ...\n    @overload\n    def __new__(cls: type[Self], __iterable: Iterable[_T_co]) -> Self: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(\n        self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(\n        self: list[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n    ) -> None: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, x: list[_T]) -> list[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: list[_T]) -> bool: ...\n    def __ge__(self, x: list[_T]) -> bool: ...\n    def __lt__(self, x: list[_T]) -> bool: ...\n    def __le__(self, x: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(\n        self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(\n        cls, __iterable: Iterable[_T], __value: None = ...\n    ) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(\n        self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> _T | _VT: ...\n\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exec(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(\n        self, __function: Callable[[_T], Any], __iterable: Iterable[_T]\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\n@overload\ndef getattr(__o: object, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: object, name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n    def issubclass(\n        __cls: type,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n\nelse:\n    def isinstance(\n        __obj: object, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef max(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef max(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef min(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef min(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIO: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes) -> int: ...\ndef print(\n    *values: object,\n    sep: str | None = ...,\n    end: str | None = ...,\n    file: SupportsWrite[str] | None = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(\n        base: int, exp: int, mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n) -> list[SupportsLessThanT]: ...\n@overload\ndef sorted(\n    __iterable: Iterable[_T],\n    *,\n    key: Callable[[_T], SupportsLessThan],\n    reverse: bool = ...,\n) -> list[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> _T | _S: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> _T | _S: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]\n    ) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Mapping[str, Any] | None = ...,\n    locals: Mapping[str, Any] | None = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(\n        self, *args: object, name: str | None = ..., path: str | None = ...\n    ) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass NotImplementedError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\n",
    "/typeshed/stdlib/errno.pyi": "from typing import Mapping\n\nerrorcode: Mapping[int, str]\n\nEACCES: int\nEADDRINUSE: int\nEAGAIN: int\nEALREADY: int\nEBADF: int\nECONNABORTED: int\nECONNREFUSED: int\nECONNRESET: int\nEEXIST: int\nEHOSTUNREACH: int\nEINPROGRESS: int\nEINVAL: int\nEIO: int\nEISDIR: int\nENOBUFS: int\nENODEV: int\nENOENT: int\nENOMEM: int\nENOTCONN: int\nEOPNOTSUPP: int\nEPERM: int\nETIMEDOUT: int\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Rial\u00fa ar an bailitheoir truflais\"\"\"\nfrom typing import overload\n\ndef enable() -> None:\n    \"\"\"Cumasaigh baili\u00fa truflais uathoibr\u00edoch. (chumas\u00fa)\"\"\"\n    ...\n\ndef disable() -> None:\n    \"\"\"D\u00edchumasaigh baili\u00fa truflais uathoibr\u00edoch. (dh\u00edchumas\u00fa)\n\nHeap memory can still be allocated,\nand garbage collection can still be initiated manually using ``gc.collect``.\"\"\"\n\ndef collect() -> None:\n    \"\"\"Rith baili\u00fach\u00e1n truflais. (bhaili\u00fa)\"\"\"\n    ...\n\ndef mem_alloc() -> int:\n    \"\"\"Faigh l\u00edon na mbeart de RAM carn at\u00e1 leithdh\u00e1ilte.\n\n:return: The number of bytes allocated.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\ndef mem_free() -> int:\n    \"\"\"Faigh l\u00edon na mbeart de RAM gcarn at\u00e1 ar f\u00e1il, n\u00f3 -1 mura bhfuil an m\u00e9id seo ar eolas. (cuimhne saor)\n\n:return: The number of bytes free.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\n@overload\ndef threshold() -> int:\n    \"\"\"Ceistigh an tairseach leithdh\u00e1ilte GC bhreise. (tairseach)\n\n:return: The GC allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\"\"\"\n    ...\n\n@overload\ndef threshold(amount: int) -> None:\n    \"\"\"Socraigh an tairseach leithdh\u00e1ilte GC breise. (tairseach)\n\nNormally, a collection is triggered only when a new allocation\ncannot be satisfied, i.e. on an  out-of-memory (OOM) condition.\nIf this function is called, in addition to OOM, a collection\nwill be triggered each time after ``amount`` bytes have been\nallocated (in total, since the previous time such an amount of bytes\nhave been allocated). ``amount`` is usually specified as less than the\nfull heap size, with the intention to trigger a collection earlier than when the\nheap becomes exhausted, and in the hope that an early collection will prevent\nexcessive memory fragmentation. This is a heuristic measure, the effect\nof which will vary from application to application, as well as\nthe optimal value of the ``amount`` parameter.\n\nA value of -1 means a disabled allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\n\n:param amount: (m\u00e9id) L\u00edon na mbeart ina dhiaidh sin ba cheart baili\u00fach\u00e1n truflais a spreagadh.\"\"\"\n    ...",
    "/typeshed/stdlib/log.pyi": "\"\"\"Log\u00e1il sonra\u00ed chuig do micro:bit V2. (loga)\"\"\"\nfrom typing import Literal, Mapping, Optional, Union, overload\nMILLISECONDS = 1\n\"\"\"Form\u00e1id stampa ama milleasoicind\u00ed. (milleasoicind\u00ed)\"\"\"\nSECONDS = 10\n\"\"\"Form\u00e1id stampa ama soicind\u00ed. (soicind\u00ed)\"\"\"\nMINUTES = 600\n\"\"\"Form\u00e1id stampa ama n\u00f3im\u00e9ad. (n\u00f3im\u00e9ad)\"\"\"\nHOURS = 36000\n\"\"\"Form\u00e1id stampa ama uaireanta. (uair an chloig)\"\"\"\nDAYS = 864000\n\"\"\"Form\u00e1id stampa ama na laethanta. (laethanta)\"\"\"\n\ndef set_labels(*labels: str, timestamp: Optional[Literal[1, 10, 36000, 864000]]=SECONDS) -> None:\n    \"\"\"Socraigh ceannt\u00e1sc an chomhaid log\u00e1la. (lip\u00e9id a shocr\u00fa)\n\nExample: ``log.set_labels('X', 'Y', 'Z', timestamp=log.MINUTES)``\n\nIdeally this function should be called a single time, before any data is\nlogged, to configure the data table header once.\n\nIf a log file already exists when the program starts, or if this function\nis called multiple times, it will check the labels already defined in the\nlog file. If this function call contains any new labels not already\npresent, it will generate a new header row with the additional columns.\n\nBy default the first column contains a timestamp for each row. The time\nunit can be selected via the timestamp argument.\n\n:param *labels: (*lip\u00e9id) Aon l\u00edon arg\u00f3int\u00ed su\u00edmh, gach ceann ag freagairt d'iontr\u00e1il sa cheannt\u00e1sc loga.\n:param timestamp: (stampa ama) Roghnaigh an t-aonad stampa ama a chuirfear leis go huathoibr\u00edoch mar an ch\u00e9ad chol\u00fan i ngach r\u00f3. Is f\u00e9idir le luachanna stampa ama a bheith mar cheann de ``log.MILLISECONDS``, ``log.SECONDS``, ``log.MINUTES``, ``log.HOURS``, ``log.DAYS`` n\u00f3 ``None`` chun an stampa ama a dh\u00edchumas\u00fa. Is \u00e9 ``log.SECONDS`` an luach r\u00e9amhshocraithe.\"\"\"\n    ...\n\n@overload\ndef add(data_dictionary: Optional[Mapping[str, Union[str, int, float]]]) -> None:\n    \"\"\"Cuir r\u00f3 sonra\u00ed leis an loga tr\u00ed fhocl\u00f3ir ceannt\u00e1sca agus luachanna a rith. (cuir leis)\n\nExample: ``log.add({ 'temp': temperature() })``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\n\n:param data_dictionary: (focl\u00f3ir sonra\u00ed) Na sonra\u00ed le log\u00e1il mar fhocl\u00f3ir le heochair do gach ceannt\u00e1sc.\"\"\"\n    ...\n\n@overload\ndef add(**kwargs: Union[str, int, float]) -> None:\n    \"\"\"Cuir r\u00f3 sonra\u00ed leis an log\u00e1il ag baint \u00fas\u00e1ide as arg\u00f3int\u00ed eochairfhocail. (suimigh)\n\nExample: ``log.add(temp=temperature())``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\"\"\"\n    ...\n\ndef delete(full=False):\n    \"\"\"Scrios inneachar an loga, lena n-\u00e1ir\u00edtear ceannt\u00e1sca. (scrios)\n\nExample: ``log.delete()``\n\nTo add the log headers again the ``set_labels`` function should to be called after this function.\n\nThere are two erase modes; \u201cfull\u201d completely removes the data from the physical storage,\nand \u201cfast\u201d invalidates the data without removing it.\n\n:param full: (ioml\u00e1n) Roghna\u00edonn ``True`` scriosadh \u201cl\u00e1n\u201d agus roghna\u00edonn ``False`` an modh scriosta \u201ctapa\u201d.\"\"\"\n    ...\n\ndef set_mirroring(serial: bool):\n    \"\"\"Cumraigh sc\u00e1th\u00e1n\u00fa na gn\u00edomha\u00edochta log\u00e1la sonra\u00ed chuig an aschur sraitheach. (sc\u00e1th\u00e1n\u00fa socraithe)\n\nExample: ``log.set_mirroring(True)``\n\nSerial mirroring is disabled by default. When enabled, it will print to serial each row logged into the log file.\n\n:param serial: (sraitheach) Cumasa\u00edonn ``True`` sonra\u00ed a sc\u00e1th\u00e1n\u00fa leis an aschur sraitheach.\"\"\"\n    ...",
    "/typeshed/stdlib/love.pyi": "def badaboom() -> None: ...\n",
    "/typeshed/stdlib/machine.pyi": "\"\"\"F\u00f3ntais leibh\u00e9al \u00edseal. (meais\u00edn)\"\"\"\nfrom typing import Any\nfrom .microbit import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Faigh beart teaghr\u00e1n le haitheant\u00f3ir uath\u00fail cl\u00e1ir. (id uath\u00fail)\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Athshocraigh an gl\u00e9as ar bhealach cos\u00fail le br\u00faigh an cnaipe ATHSHOCRAITHE seachtrach. (athshocr\u00fa)\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Faigh an minic\u00edocht LAP i hertz. (minic\u00edocht)\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"D\u00edchumasaigh iarratais idirbhriste. (d\u00edchumasaigh irq)\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"Athchumasaigh iarratais idirbhriste. (cumasaigh irq)\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: (st\u00e1t) An luach a cuireadh ar ais \u00f3n nglao is d\u00e9ana\u00ed chuig an bhfeidhm ``disable_irq``.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Am buille ar bhior\u00e1in. (cuisle ama us)\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: (bior\u00e1in) An bior\u00e1n le h\u00fas\u00e1id\n:param pulse_level: (leibh\u00e9al cuisle) 0 go ham cuisle \u00edseal n\u00f3 1 go ham cuisle ard\n:param timeout_us: (am istigh linn) Teorainn ama micrea soicind\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"An rang le haghaidh radharcanna cuimhne ``mem8``, ``mem16`` agus ``mem32``. (cuimhne)\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Faigh luach \u00f3 chuimhne. (faigh-m\u00edr)\n\n:param address: (seoladh) An seoladh cuimhne.\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"Socraigh luach ag an seoladh a thugtar. (socraigh-m\u00edr)\n\n:param address: (seoladh) An seoladh cuimhne.\n:param value: (luach) An luach sl\u00e1nuimhir a shocr\u00fa.\"\"\"\n        ...\nmem8: mem\n\"\"\"Amharc 8-giot\u00e1n (beart) ar chuimhne. (cuimhne8)\"\"\"\nmem16: mem\n\"\"\"Radharc 16-giot\u00e1n ar chuimhne. (cuimhne16)\"\"\"\nmem32: mem\n\"\"\"Amharc 32-giot\u00e1n ar chuimhne. (cuimhne32)\"\"\"",
    "/typeshed/stdlib/math.pyi": "\"\"\"Feidhmeanna matamaitici\u00fala. (mata)\"\"\"\nfrom typing import Tuple\n\ndef acos(x: float) -> float:\n    \"\"\"R\u00edomh an cosine inbh\u00e9artach.\n\nExample: ``math.acos(1)``\n\n:param x: Uimhir\n:return: The inverse cosine of ``x``\"\"\"\n    ...\n\ndef asin(x: float) -> float:\n    \"\"\"R\u00edomh an sine inbh\u00e9artach.\n\nExample: ``math.asin(0)``\n\n:param x: Uimhir\n:return: The inverse sine of ``x``\"\"\"\n    ...\n\ndef atan(x: float) -> float:\n    \"\"\"R\u00edomh an tadhla\u00ed inbh\u00e9artach.\n\nExample: ``math.atan(0)``\n\n:param x: Uimhir\n:return: The inverse tangent of ``x``\"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float:\n    \"\"\"R\u00edomh pr\u00edomhluach an tadhla\u00ed inbh\u00e9artach de ``y/x``.\n\nExample: ``math.atan2(0, -1)``\n\n:param y: Uimhir\n:param x: Uimhir\n:return: The principal value of the inverse tangent of ``y/x``\"\"\"\n    ...\n\ndef ceil(x: float) -> float:\n    \"\"\"D\u00e9an roinnt a shl\u00e1n\u00fa i dtreo \u00e9igr\u00edochta dearfach. (s\u00edle\u00e1il)\n\nExample: ``math.ceil(0.1)``\n\n:param x: Uimhir\n:return: ``x`` rounded towards positive infinity.\"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float:\n    \"\"\"R\u00edomh ``x`` le comhartha ``y``. (c\u00f3ipchomhartha)\n\nExample: ``math.copysign(1, -1)``\n\n:param x: Uimhir\n:param y: Foinse an chomhartha don luach fillte\n:return: ``x`` with the sign of ``y``\"\"\"\n    ...\n\ndef cos(x: float) -> float:\n    \"\"\"R\u00edomh an comhsh\u00edneas de ``x``.\n\nExample: ``math.cos(0)``\n\n:param x: Uimhir\n:return: The cosine of ``x``\"\"\"\n    ...\n\ndef degrees(x: float) -> float:\n    \"\"\"Raidian Tiontaigh go c\u00e9imeanna. (c\u00e9imeanna)\n\nExample: ``math.degrees(2 * math.pi)``\n\n:param x: Luach i rada\u00edn\u00ed\n:return: The value converted to degrees\"\"\"\n    ...\n\ndef exp(x: float) -> float:\n    \"\"\"R\u00edomh easp\u00f3nant\u00fail ``x``.\n\nExample: ``math.exp(1)``\n\n:param x: Uimhir\n:return: The exponential of ``x``.\"\"\"\n    ...\n\ndef fabs(x: float) -> float:\n    \"\"\"Tabhair luach absal\u00f3ideach ``x``ar ais.\n\nExample: ``math.fabs(-0.1)``\n\n:param x: Uimhir\n:return: The absolute value of ``x``\"\"\"\n    ...\n\ndef floor(x: float) -> int:\n    \"\"\"Babhtaigh uimhir i dtreo \u00e9igr\u00edoch di\u00faltach. (url\u00e1r)\n\nExample: ``math.floor(0.9)``\n\n:param x: Uimhir\n:return: ``x`` rounded towards negative infinity.\"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float:\n    \"\"\"R\u00edomh an chuid eile de ``x/y``.\n\nExample: ``math.fmod(10, 3)``\n\n:param x: An t-uimhreoir\n:param y: An t-ainmneoir\"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]:\n    \"\"\"D\u00edscaoileann s\u00e9 uimhir sn\u00e1mhphointe isteach ina mantissa agus ina easp\u00f3nant.\n\nExample: ``mantissa, exponent = math.frexp(2)``\n\nThe returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\nexactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\nthe relation ``0.5 <= abs(m) < 1`` holds.\n\n:param x: Uimhir sn\u00e1mhphointe\n:return: A tuple of length two containing its mantissa then exponent\"\"\"\n    ...\n\ndef isfinite(x: float) -> bool:\n    \"\"\"Seice\u00e1il an bhfuil luach cr\u00edochta. (isfinideach)\n\nExample: ``math.isfinite(float('inf'))``\n\n:param x: Uimhir.\n:return: ``True`` if ``x`` is finite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isinf(x: float) -> bool:\n    \"\"\"Seice\u00e1il an bhfuil luach gan teorainn.\n\nExample: ``math.isinf(float('-inf'))``\n\n:param x: Uimhir\n:return: ``True`` if ``x`` is infinite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isnan(x: float) -> bool:\n    \"\"\"Seice\u00e1il an luach nach uimhir \u00e9 (NaN).\n\nExample: ``math.isnan(float('nan'))``\n\n:param x: Uimhir\n:return: ``True`` if ``x`` is not-a-number (NaN), ``False`` otherwise.\"\"\"\n    ...\n\ndef ldexp(x: float, exp: int) -> float:\n    \"\"\"R\u00edomh ``x * (2**exp)``.\n\nExample: ``math.ldexp(0.5, 2)``\n\n:param x: Uimhir\n:param exp: Easp\u00f3nant sl\u00e1nuimhir\n:return: ``x * (2**exp)``\"\"\"\n    ...\n\ndef log(x: float, base: float=e) -> float:\n    \"\"\"R\u00edomh logarithm ``x`` go dt\u00ed an bonn tugtha (r\u00e9amhshocraithe don logarithm n\u00e1d\u00fartha). (loga)\n\nExample: ``math.log(math.e)``\n\nWith one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as ``log(x)/log(base)``.\n\n:param x: Uimhir\n:param base: (bonn) An bonn le h\u00fas\u00e1id\n:return: The natural logarithm of ``x``\"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]:\n    \"\"\"R\u00edomh na codanna cod\u00e1nacha agus l\u00e1rnacha de ``x``.\n\nExample: ``fractional, integral = math.modf(1.5)``\n\n:param x: Uimhir\n:return: A tuple of two floats representing the fractional then integral parts of ``x``.\n\nBoth the fractional and integral values have the same sign as ``x``.\"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float:\n    \"\"\"Filleann ``x`` chuig cumhacht ``y``.\n\nExample: ``math.pow(4, 0.5)``\n\n:param x: Uimhir\n:param y: An l\u00e9iritheoir\n:return: ``x`` to the power of ``y``\"\"\"\n    ...\n\ndef radians(x: float) -> float:\n    \"\"\"Tiontaigh c\u00e9imeanna go raidian. (raidi\u00e1in)\n\nExample: ``math.radians(360)``\n\n:param x: Luach i gc\u00e9imeanna\n:return: The value converted to radians\"\"\"\n    ...\n\ndef sin(x: float) -> float:\n    \"\"\"R\u00edomh an s\u00edn de ``x``. (s\u00edneas)\n\nExample: ``math.sin(math.pi/2)``\n\n:param x: Uimhir\n:return: The sine of ``x``\"\"\"\n    ...\n\ndef sqrt(x: float) -> float:\n    \"\"\"R\u00edomh an fhr\u00e9amh chearnach de ``x``.\n\nExample: ``math.sqrt(4)``\n\n:param x: Uimhir\n:return: The square root of ``x``\"\"\"\n    ...\n\ndef tan(x: float) -> float:\n    \"\"\"R\u00edomh an tadhla\u00ed de ``x``.\n\nExample: ``math.tan(0)``\n\n:param x: Uimhir\n:return: The tangent of ``x``.\"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\"D\u00e9an uimhir a shl\u00e1n\u00fa i dtreo 0.\n\nExample: ``math.trunc(-0.9)``\n\n:param x: Uimhir\n:return: ``x`` rounded towards zero.\"\"\"\n    ...\ne: float\n\"\"\"Bun\u00fas an logartaim n\u00e1d\u00fartha\"\"\"\npi: float\n\"\"\"An c\u00f3imheas idir iml\u00edne ciorcail agus a thrastomhas\"\"\"",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"Gn\u00e9ithe inmhe\u00e1nacha MicroPython.\"\"\"\nfrom typing import Any, TypeVar, overload\n_T = TypeVar('_T')\n\ndef const(expr: _T) -> _T:\n    \"\"\"\u00das\u00e1idtear \u00e9 chun a dhearbh\u00fa go bhfuil an slonn tairiseach ionas gur f\u00e9idir leis an tiomsaitheoir\nan leas is fearr is f\u00e9idir a bhaint as.\n\nThe use of this function should be as follows::\n\n    from micropython import const\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\nConstants declared this way are still accessible as global variables from\noutside the module they are declared in. On the other hand, if a constant\nbegins with an underscore then it is hidden, it is not available as a\nglobal variable, and does not take up any memory during execution.\n\n:param expr: L\u00e9iri\u00fa tairiseach.\"\"\"\n    ...\n\n@overload\ndef opt_level() -> int:\n    \"\"\"Faigh an leibh\u00e9al optamaithe reatha chun scripteanna a thioms\u00fa. (leibh\u00e9al roghnaithe)\n\nExample: ``micropython.opt_level()``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\n:return: An integer representing the current level.\"\"\"\n    ...\n\n@overload\ndef opt_level(level: int) -> None:\n    \"\"\"Socraigh an leibh\u00e9al optamaithe le haghaidh tioms\u00fa scripteanna ina dhiaidh sin. (leibh\u00e9al rogha)\n\nExample: ``micropython.opt_level(1)``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\nThe default optimisation level is usually level 0.\n\n:param level: (leibh\u00e9al) Leibh\u00e9al optamaithe sl\u00e1nuimhir.\"\"\"\n    ...\n\ndef mem_info(verbose: Any=None) -> None:\n    \"\"\"Priont\u00e1il faisn\u00e9is faoin gcuimhne at\u00e1 in \u00fas\u00e1id faoi l\u00e1thair. (eolas cuimhne)\n\nExample: ``micropython.mem_info()``\n\n:param verbose: (foclach) M\u00e1 thugtar an arg\u00f3int ``verbose``, cl\u00f3itear faisn\u00e9is bhreise.\"\"\"\n    ...\n\ndef qstr_info(verbose: Any=None) -> None:\n    \"\"\"Priont\u00e1il eolas faoi th\u00e9ada at\u00e1 imtheorannaithe faoi l\u00e1thair. (eolas qstr)\n\nExample: ``micropython.qstr_info()``\n\n:param verbose: (foclach) M\u00e1 thugtar an arg\u00f3int ``verbose``, cl\u00f3itear faisn\u00e9is bhreise.\n\nThe information that is printed is implementation dependent, but currently\nincludes the number of interned strings and the amount of RAM they use.  In\nverbose mode it prints out the names of all RAM-interned strings.\"\"\"\n    ...\n\ndef stack_use() -> int:\n    \"\"\"Tabhair sl\u00e1nuimhir ar ais a l\u00e9ir\u00edonn an m\u00e9id reatha cruach at\u00e1 \u00e1\na \u00fas\u00e1idtear. (\u00fas\u00e1id cruach)\n\nExample: ``micropython.stack_use()``\n\nThe absolute value of this is not particularly useful, rather it\nshould be used to compute differences in stack usage at different points.\n\n:return: An integer representing current stack use.\"\"\"\n    ...\n\ndef heap_lock() -> None:\n    \"\"\"Glas\u00e1il an carn. (glas carn)\n\nExample: ``micropython.heap_lock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef heap_unlock() -> None:\n    \"\"\"D\u00edghlas\u00e1il an carn. (d\u00edghlas\u00e1il carn)\n\nExample: ``micropython.heap_unlock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"Socraigh an carachtar a ard\u00f3idh eisceacht ``KeyboardInterrupt`` .\n\nExample: ``micropython.kbd_intr(-1)``\n\n:param chr: C\u00f3d carachtar chun an t-idirbhriseadh n\u00f3 -1 a ard\u00fa chun gabh\u00e1il Ctrl-C a dh\u00edchumas\u00fa.\n\nBy default this is set to 3 during script execution, corresponding to Ctrl-C.\nPassing -1 to this function will disable capture of Ctrl-C, and passing 3\nwill restore it.\n\nThis function can be used to prevent the capturing of Ctrl-C on the\nincoming stream of characters that is usually used for the REPL, in case\nthat stream is used for other purposes.\"\"\"\n    ...",
    "/typeshed/stdlib/music.pyi": "\"\"\"Cruthaigh agus seinn s\u00e9iseanna. (ceol)\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .microbit import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"Fonn: oscailt 5\u00fa Siansa Beethoven i C mion.\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"Fonn: an bl\u00faire oscailte de chlasaic Ragtime Scott Joplin \"The Entertainer\". (siams\u00f3ir)\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"Fonn: oscailt an ch\u00e9ad R\u00e9amhr\u00e1 i C Major de 48 R\u00e9amhr\u00e1ite agus Fugues J.S.Bach. (r\u00e9amhr\u00e1)\"\"\"\nODE: Tuple[str, ...]\n\"\"\"Fonn: an t\u00e9ama \"Ode to Joy\" \u00f3 9\u00fa Siansa Beethoven in D minor.\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"Fonn: t\u00e9ama Nyan Cat (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"Fonn: rud a fhuaimn\u00edonn cos\u00fail le clingthon f\u00f3n p\u00f3ca. (clingthon)\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"Fonn: l\u00edne dord spra\u00ed\u00fail do ghn\u00edomhair\u00ed r\u00fanda agus do mh\u00e1istir-intinn choiri\u00fala. (func)\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"Fonn: a boogie-woogie 12-bar blues ag si\u00fal Bass.\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"Fonn: \"Breithl\u00e1 sona duit...\" (l\u00e1 breithe)\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"Fonn: an curf\u00e1 bridal \u00f3 cheoldr\u00e1ma Wagner \"Lohengrin\". (p\u00f3sadh)\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"Fonn : an \u201cm\u00e1irse\u00e1il sochraide\u201d ar a dtugtar freisin Son\u00e1id Phian\u00f3 Uimh. 2 i B\u266d beag, Op. 35 le Fr\u00e9d\u00e9ric Chopin. (sochraid)\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"Fonn: t\u00e1 bl\u00faire spraoi a l\u00e9ir\u00edonn magadh d\u00e9anta.\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"Fonn: M\u00e1irse\u00e1il John Philip Sousa \u201cLiberty Bell\u201d ar a dtugtar t\u00e9ama \u201cMonty Python\u2019s Flying Circus\u201d (ar a dtugtar an teanga r\u00edomhchl\u00e1r\u00fach\u00e1in Python ina diaidh).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"Fonn: bealach isteach r\u00e9 an scann\u00e1in chi\u00fain de drochdhuine. (drochdhuine)\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"Fonn: radharc ruaig r\u00e9 scann\u00e1n ci\u00fain. (ruaig)\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"Fonn: comhartha gearr chun a chur in i\u00fal gur tharla rud \u00e9igin.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"Fonn: tromb\u00f3n an-bhr\u00f3nach.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"Fonn: le h\u00fas\u00e1id i gcluiche, rud a l\u00e9ir\u00edonn gluaiseacht an\u00edos. (l\u00e9im suas)\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"S\u00e9is: le h\u00fas\u00e1id i gcluiche, rud a l\u00e9ir\u00edonn gluaiseacht anuas. (l\u00e9im s\u00edos)\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"Fonn: fonnf\u00f3ir chun \u00e9acht a dh\u00edghlas\u00e1il a l\u00e9iri\u00fa. (cumhacht suas)\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"Fonn: fait\u00edos br\u00f3nach chun \u00e9acht a cailleadh a l\u00e9iri\u00fa. (cumhacht s\u00edos)\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"Socraigh an luas garbh le haghaidh athsheinm. (socraigh tempo)\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: (sceart\u00e1in) L\u00edon na sceart\u00e1n ar buille iad.\n:param bpm: Sl\u00e1nuimhir a chinneann c\u00e9 mh\u00e9ad buille in aghaidh an n\u00f3im\u00e9id.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"Faigheann an luas reatha mar tupla sl\u00e1nuimhreacha: ``(ticks, bpm)``. (faigh tempo)\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Seinneann s\u00e9 ceol. (seinn)\n\nExample: ``music.play(music.NYAN)``\n\n:param music: (ceol) ceol a shonra\u00edtear in 'nodaireacht speisialta <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>'_\n:param pin: (bior\u00e1n) an bior\u00e1in aschuir le h\u00fas\u00e1id le cainteoir seachtrach (r\u00e9amhshocraithe ``pin0``), ``None`` gan aon fhuaim.\n:param wait: (fan) M\u00e1 t\u00e1 ``wait`` socraithe go ``True``, t\u00e1 an fheidhm seo ag bloc\u00e1il.\n:param loop: (l\u00fab) M\u00e1 t\u00e1 ``loop`` socraithe go ``True``, athr\u00e1 ar an ti\u00fan go dt\u00ed go dtugtar ``stop`` n\u00f3 go gcuirtear isteach ar an nglao bloc\u00e1la.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Seinn n\u00f3ta. (p\u00e1irc)\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: (minic\u00edocht) Minic\u00edocht sl\u00e1nuimhir\n:param duration: (fad) Fad milleasoicind. M\u00e1 t\u00e1 fuaim dhi\u00faltach ansin lean\u00fanach go dt\u00ed an ch\u00e9ad ghlao eile n\u00f3 glao ar ``stop``.\n:param pin: (bior\u00e1n) Bior\u00e1in aschuir roghnach (r\u00e9amhshocraithe ``pin0``).\n:param wait: (fan) M\u00e1 t\u00e1 ``wait`` socraithe go ``True``, t\u00e1 an fheidhm seo ag bloc\u00e1il.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Stopann s\u00e9 gach athsheinm ceoil ar an gcainteoir t\u00f3gtha isteach agus aon fhuaim aschur bior\u00e1in. (stad)\n\nExample: ``music.stop()``\n\n:param pin: (pionna) Is f\u00e9idir arg\u00f3int roghnach a chur ar f\u00e1il chun bior\u00e1n a shonr\u00fa, m.sh. ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Athshocraigh sceart\u00e1in, bpm, fad agus ochtach chuig a luachanna r\u00e9amhshocraithe. (athshocr\u00fa)\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Stiallacha RGB agus RGBW LED at\u00e1 inseolta ina n-aonar.\"\"\"\nfrom .microbit import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"T\u00fasaigh stiall nua de soilse neopicsel a riala\u00edtear tr\u00ed bhior\u00e1n.\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: (bior\u00e1n) An bior\u00e1n a riala\u00edonn an stiall neopicsel.\n:param n: L\u00edon na neopicsel sa stiall.\n:param bpp: Bearta in aghaidh an phicteil\u00edn. Maidir le taca\u00edocht neopicsel RGBW, pas 4 seachas mainneachtain 3 do RGB agus GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Glan na picteil\u00edn\u00ed go l\u00e9ir. (soil\u00e9ir)\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"Taispe\u00e1in na picteil\u00edn\u00ed. (taispe\u00e1in)\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Taispe\u00e1in na picteil\u00edn\u00ed (micro:bit V2 amh\u00e1in). (scr\u00edobh)\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Dathaigh gach picteil\u00edn luach RGB / RGBW ar leith (micro:bit V2 amh\u00e1in). (l\u00edonadh)\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: (dath) Tupla den fhad c\u00e9anna le l\u00edon na mbeart in aghaidh an phicteil\u00edn (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"Socraigh dath picteil\u00edn. (socraigh m\u00edr)\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: (eochair) Uimhir an phicteil\u00edn.\n:param value: (luach) An dath.\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"Faigh dath picteil\u00edn. (faigh m\u00edr)\n\nExample: ``r, g, b = np[0]``\n\n:param key: (eochair) Uimhir an phicteil\u00edn.\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"Faigh fad an stiall picteil\u00edn seo.\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "\"\"\"Rochtain a fh\u00e1il ar an gc\u00f3ras comhad.\"\"\"\nfrom typing import Tuple\nfrom typing import List\n\ndef listdir() -> List[str]:\n    \"\"\"Liostaigh comhaid.\n\nExample: ``os.listdir()``\n\n:return: A list of the names of all the files contained within the local\npersistent on-device file system.\"\"\"\n    ...\n\ndef remove(filename: str) -> None:\n    \"\"\"Bain (scrios) comhad. (bain)\n\nExample: ``os.remove('data.txt')``\n\n:param filename: (ainm comhaid) An comhad le scriosadh.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n    ...\n\ndef size(filename: str) -> int:\n    \"\"\"Tuairisce\u00e1in m\u00e9id comhaid. (m\u00e9id)\n\nExample: ``os.size('data.txt')``\n\n:param filename: (ainm comhaid) An comhad\n:return: The size in bytes.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n\nclass uname_result(Tuple[str, str, str, str, str]):\n    \"\"\"Toradh de ``os.uname()`` (toradh uname)\"\"\"\n    sysname: str\n    \"\"\"Ainm an ch\u00f3rais oibri\u00fach\u00e1in. (ainm an ch\u00f3rais)\"\"\"\n    nodename: str\n    \"\"\"Ainm an mheais\u00edn ar an l\u00edonra (cur i bhfeidhm sainithe). (ainm n\u00f3id)\"\"\"\n    release: str\n    \"\"\"Scaoileadh an ch\u00f3rais oibri\u00fach\u00e1in. (scaoileadh)\"\"\"\n    version: str\n    \"\"\"Leagan an ch\u00f3rais oibri\u00fach\u00e1in. (leagan)\"\"\"\n    machine: str\n    \"\"\"Aitheant\u00f3ir crua-earra\u00ed. (meais\u00edn)\"\"\"\n\ndef uname() -> uname_result:\n    \"\"\"Tuairisce\u00e1in faisn\u00e9is a aithn\u00edonn an c\u00f3ras oibri\u00fach\u00e1in reatha.\n\nExample: ``os.uname()``\n\nThe return value is an object with five attributes:\n\n- ``sysname`` - operating system name\n- ``nodename`` - name of machine on network (implementation-defined)\n- ``release`` - operating system release\n- ``version`` - operating system version\n- ``machine`` - hardware identifier\n\nThere is no underlying operating system in MicroPython. As a result the\ninformation returned by the ``uname`` function is mostly useful for\nversioning details.\"\"\"\n    ...",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "\"\"\"Cumars\u00e1id a dh\u00e9anamh idir micro:bit leis an raidi\u00f3 t\u00f3gtha. (raidi\u00f3)\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom typing import Optional, Tuple\nRATE_1MBIT: int\n\"\"\"Tairiseach a \u00fas\u00e1idtear chun tr\u00e9chur 1 MBit an dara ceann a l\u00e9iri\u00fa. (r\u00e1ta 1mbit)\"\"\"\nRATE_2MBIT: int\n\"\"\"Tairiseach a \u00fas\u00e1idtear chun tr\u00e9chur 2 MBit an dara ceann a l\u00e9iri\u00fa. (r\u00e1ta 2mbit)\"\"\"\n\ndef on() -> None:\n    \"\"\"Casann s\u00e9 an raidi\u00f3 air. (ar)\n\nExample: ``radio.on()``\n\nThis needs to be explicitly called since the radio draws power and takes\nup memory that you may otherwise need.\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"M\u00fachann s\u00e9 an raidi\u00f3, ag s\u00e1bh\u00e1il cumhachta agus cuimhne. (as)\n\nExample: ``radio.off()``\"\"\"\n    ...\n\ndef config(length: int=32, queue: int=3, channel: int=7, power: int=6, address: int=1969383796, group: int=0, data_rate: int=RATE_1MBIT) -> None:\n    \"\"\"Cumraigh an raidi\u00f3. (cumra\u00edocht)\n\nExample: ``radio.config(group=42)``\n\nThe default configuration is suitable for most use.\n\n:param length: (fad) Sainmh\u00edn\u00edonn (r\u00e9amhshocr\u00fa=32) an fad uasta, i mb\u00e9iteanna, de theachtaireacht a sheoltar tr\u00edd an raidi\u00f3.\nF\u00e9adfaidh s\u00e9 a bheith suas le 251 beart ar fhad (254 - 3 beart do r\u00e9amhr\u00e1 S0, FAD agus S1).\n:param queue: (scuaine) (r\u00e9amhshocr\u00fa = 3) sonra\u00edtear l\u00edon na dteachtaireachta\u00ed is f\u00e9idir a st\u00f3r\u00e1il ar an scuaine teachtaireachta isteach.\nMura bhfuil aon sp\u00e1sanna f\u00e1gtha ar an scuaine le haghaidh teachtaireachta\u00ed isteach, ansin t\u00e1 an teachtaireacht ag teacht isteach thit.\n:param channel: (cain\u00e9al) (r\u00e9amhshocr\u00fa = 7) sl\u00e1nuimhir luach \u00f3 0 go 83 (san \u00e1ireamh) a shainmh\u00edn\u00edonn \"cain\u00e9al\" treallach a bhfuil an raidi\u00f3 ti\u00fanta leis.\nSeolfar teachtaireachta\u00ed tr\u00edd an gcain\u00e9al seo agus n\u00ed chuirfear ach teachtaireachta\u00ed a fhaightear tr\u00edd an gcain\u00e9al seo ar an scuaine teachtaireachta\u00ed at\u00e1 ag teacht isteach. T\u00e1 gach c\u00e9im 1MHz ar leithead, bunaithe ar 2400MHz.\n:param power: (cumhacht) (r\u00e9amhshocr\u00fa = 6) Is luach sl\u00e1nuimhir \u00f3 0 go 7 (san \u00e1ireamh) a chur in i\u00fal ar an neart comhartha a \u00fas\u00e1idtear nuair a chraoladh teachtaireacht.\nD\u00e1 airde an luach is ea is l\u00e1idre an comhartha, ach is \u00e9 an gl\u00e9as is m\u00f3 a chaitheann an chumhacht. Aistr\u00edonn an t-uimhri\u00fa go poist sa liosta seo a leanas de luachanna dBm (decibel milliwatt): -30, -20, -16, -12, -8, -4, 0, 4.\n:param address: (seoladh) (default=0x75626974) ainm treallach, arna shloinneadh mar sheoladh 32-giot\u00e1n, a \u00fas\u00e1idtear chun paic\u00e9id at\u00e1 ag teacht isteach a scagadh ag leibh\u00e9al na crua-earra\u00ed, gan ach iad si\u00fad a mheaitse\u00e1il leis an seoladh a shocraigh t\u00fa a choinne\u00e1il.\nIs \u00e9 an r\u00e9amhshocr\u00fa a \u00fas\u00e1ideann ard\u00e1in eile a bhaineann le micro:bit an socr\u00fa r\u00e9amhshocraithe a \u00fas\u00e1idtear anseo.\n:param group: (gr\u00fapa) (default=0) luach 8-giot\u00e1n (0-255) a \u00fas\u00e1idtear leis an ``address`` agus teachtaireachta\u00ed \u00e1 scagadh.\nGo coincheap\u00fail, t\u00e1 \"seoladh\" cos\u00fail le seoladh t\u00ed / oifige agus t\u00e1 \"gr\u00fapa\" cos\u00fail leis an duine ag an seoladh sin ar mian leat do theachtaireacht a sheoladh chuige.\n:param data_rate: (r\u00e1ta sonra\u00ed) (r\u00e9amhshocr\u00fa=``radio.RATE_1MBIT``) an luas ag a dtarla\u00edonn tr\u00e9chur sonra\u00ed.\nIs f\u00e9idir a bheith ar cheann de na tairisigh seo a leanas a shainmh\u00edn\u00edtear sa mhod\u00fal ``radio`` : ``RATE_250KBIT``, ``RATE_1MBIT`` n\u00f3 ``RATE_2MBIT``.\n\nIf ``config`` is not called then the defaults described above are assumed.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Athshocraigh na socruithe d\u00e1 luachanna r\u00e9amhshocraithe. (athshocr\u00fa)\n\nExample: ``radio.reset()``\n\nThe defaults as as per the ``config`` function above.\"\"\"\n    ...\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Seolann seo teachtaireacht ina bhfuil bearta. (seol bearta)\n\nExample: ``radio.send_bytes(b'hello')``\n\n:param message: (teachtaireacht) Na bearta le seoladh.\"\"\"\n    ...\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Faigh an ch\u00e9ad teachtaireacht eile isteach ar an scuaine teachtaireachta\u00ed. (bearta a fh\u00e1il)\n\nExample: ``radio.receive_bytes()``\n\n:return: The message bytes if any, otherwise ``None``.\"\"\"\n    ...\n\ndef receive_bytes_into(buffer: WriteableBuffer) -> Optional[int]:\n    \"\"\"C\u00f3ipe\u00e1il an ch\u00e9ad teachtaireacht isteach eile ar an scuaine teachtaireachta isteach i maol\u00e1n. (bearta a fh\u00e1il isteach i)\n\nExample: ``radio.receive_bytes_info(buffer)``\n\n:param buffer: (maol\u00e1n) An maol\u00e1n sprice. T\u00e1 an teachtaireacht teasctha m\u00e1 t\u00e1 s\u00e9 n\u00edos m\u00f3 n\u00e1 an maol\u00e1n.\n:return: ``None`` if there are no pending messages, otherwise it returns the length of the message (which might be more than the length of the buffer).\"\"\"\n    ...\n\ndef send(message: str) -> None:\n    \"\"\"Seolann seo teaghr\u00e1n teachtaireachta. (seol)\n\nExample: ``radio.send('hello')``\n\nThis is the equivalent of ``radio.send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\nprepended to the front (to make it compatible with other platforms that target the micro:bit).\n\n:param message: (teachtaireacht) An sreang\u00e1n le seoladh.\"\"\"\n    ...\n\ndef receive() -> Optional[str]:\n    \"\"\"Oibr\u00edonn s\u00e9 ar an mbealach c\u00e9anna le ``receive_bytes`` ach filleann s\u00e9 cib\u00e9 rud a seoladh. (faigh)\n\nExample: ``radio.receive()``\n\nEquivalent to ``str(receive_bytes(), 'utf8')`` but with a check that the the first\nthree bytes are ``b'\\x01\\x00\\x01'`` (to make it compatible with other platforms that\nmay target the micro:bit).\n\n:return: The message with the prepended bytes stripped and converted to a string.\n\nA ``ValueError`` exception is raised if conversion to string fails.\"\"\"\n    ...\n\ndef receive_full() -> Optional[Tuple[bytes, int, int]]:\n    \"\"\"Tuairisce\u00e1in tupla ina bhfuil tr\u00ed luach a l\u00e9ir\u00edonn an ch\u00e9ad teachtaireacht eile ag teacht isteach ar an scuaine teachtaireacht. (faigh ioml\u00e1n)\n\nExample: ``radio.receive_full()``\n\nIf there are no pending messages then ``None`` is returned.\n\nThe three values in the tuple represent:\n\n- the next incoming message on the message queue as bytes.\n- the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n- a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\nFor example::\n\n    details = radio.receive_full()\n    if details:\n        msg, rssi, timestamp = details\n\nThis function is useful for providing information needed for triangulation\nand/or trilateration with other micro:bit devices.\n\n:return: ``None`` if there is no message, otherwise a tuple of length three with the bytes, strength and timestamp values.\"\"\"\n    ...",
    "/typeshed/stdlib/random.pyi": "\"\"\"Gin uimhreacha randamacha. (randamach)\"\"\"\nfrom typing import TypeVar, Sequence, Union, overload\n\ndef getrandbits(n: int) -> int:\n    \"\"\"Gin sl\u00e1nuimhir le ``n`` giot\u00e1n randamach.\n\nExample: ``random.getrandbits(1)``\n\n:param n: Luach idir 1-30 (san \u00e1ireamh).\"\"\"\n    ...\n\ndef seed(n: int) -> None:\n    \"\"\"T\u00fasaigh an ginead\u00f3ir uimhreacha randamacha. (s\u00edol)\n\nExample: ``random.seed(0)``\n\n:param n: An s\u00edol sl\u00e1nuimhir\n\nThis will give you reproducibly deterministic randomness from a given starting\nstate (``n``).\"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int:\n    \"\"\"Roghnaigh sl\u00e1nuimhir randamach idir ``a`` agus ``b`` san \u00e1ireamh.\n\nExample: ``random.randint(0, 9)``\n\n:param a: Luach tosaigh don raon (san \u00e1ireamh)\n:param b: Luach deiridh don raon (san \u00e1ireamh)\n\nAlias for ``randrange(a, b + 1)``.\"\"\"\n    ...\n\n@overload\ndef randrange(stop: int) -> int:\n    \"\"\"Roghnaigh sl\u00e1nuimhir a roghna\u00edodh go randamach idir nialas agus suas le (ach n\u00ed\nlena n-\u00e1ir\u00edtear) ``stop``.\n\nExample: ``random.randrange(10)``\n\n:param stop: (stad) Luach deiridh don raon (eisiach)\"\"\"\n    ...\n\n@overload\ndef randrange(start: int, stop: int, step: int=1) -> int:\n    \"\"\"Roghnaigh eilimint a roghna\u00edodh go randamach \u00f3 ``range(start, stop, step)``.\n\nExample: ``random.randrange(0, 10)``\n\n:param start: (t\u00fas) T\u00fas an raoin (san \u00e1ireamh)\n:param stop: (stad) Deireadh an raoin (eisiach)\n:param step: (c\u00e9im) An ch\u00e9im.\"\"\"\n    ...\n_T = TypeVar('_T')\n\ndef choice(seq: Sequence[_T]) -> _T:\n    \"\"\"Roghnaigh eilimint randamach \u00f3n seicheamh neamhfholamh ``seq``. (rogha)\n\nExample: ``random.choice([Image.HAPPY, Image.SAD])``\n\n:param seq: Seicheamh.\n\nIf ``seq`` is  empty, raises ``IndexError``.\"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"Gin uimhir randamach sn\u00e1mhphointe sa raon [0.0, 1.0). (randamach)\n\nExample: ``random.random()``\n\n:return: The random floating point number\"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float:\n    \"\"\"Seol uimhir randamach sn\u00e1mhphointe ar ais idir ``a`` agus ``b`` san \u00e1ireamh. (\u00e9ide)\n\nExample: ``random.uniform(0, 9)``\n\n:param a: Luach tosaigh don raon (san \u00e1ireamh)\n:param b: Luach deiridh don raon (san \u00e1ireamh)\"\"\"\n    ...",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Cuir an micro:bit ag caint, ag canadh agus ag d\u00e9anamh fuaimeanna eile cos\u00fail le cainte. (\u00f3r\u00e1id)\"\"\"\nfrom typing import Optional\nfrom .microbit import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"Aistrigh focail Bh\u00e9arla go f\u00f3in\u00e9im\u00ed. (aistrigh)\n\nExample: ``speech.translate('hello world')``\n\n:param words: (focail) Teaghr\u00e1n focal B\u00e9arla.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"F\u00f3in\u00e9im\u00ed a fhuaimni\u00fa. (fuaimni\u00fa)\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: (f\u00f3in\u00e9im\u00ed) An teaghr\u00e1n f\u00f3in\u00e9im\u00ed a fhuaimni\u00fa\n:param pitch: (airde) Uimhir a sheasann do ph\u00e1irc an ghutha\n:param speed: (luas) Uimhir a l\u00e9ir\u00edonn luas an ghutha\n:param mouth: (b\u00e9al) Uimhir a sheasann do bh\u00e9al an ghutha\n:param throat: (scornach) Uimhir a sheasann do scornach an ghutha\n:param pin: (bior\u00e1n) Is f\u00e9idir arg\u00f3int roghnach chun an bior\u00e1in aschuir a shonr\u00fa a \u00fas\u00e1id chun mainneachtain ``pin0``a sh\u00e1r\u00fa.\nMura dteasta\u00edonn uainn aon fhuaim a sheinm as na bior\u00e1in is f\u00e9idir ``pin=None``a \u00fas\u00e1id. micro:bit V2 amh\u00e1in.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Abair focail Bh\u00e9arla. (abair)\n\nExample: ``speech.say('hello world')``\n\n:param words: (focail) An teaghr\u00e1n focal le r\u00e1.\n:param pitch: (airde) Uimhir a l\u00e9ir\u00edonn airde an ghutha\n:param speed: (luas) Uimhir a l\u00e9ir\u00edonn luas an ghl\u00f3r\n:param mouth: (b\u00e9al) Uimhir a sheasann do bh\u00e9al an ghutha\n:param throat: (scornach) Uimhir a sheasann do scornach an ghutha\n:param pin: (bior\u00e1n) Is f\u00e9idir arg\u00f3int roghnach a \u00fas\u00e1id chun an bior\u00e1n aschuir a shonr\u00fa chun an r\u00e9amhshocr\u00fa ``pin0`` a sh\u00e1r\u00fa.\nMura dteasta\u00edonn uainn go seinnf\u00ed aon fhuaim as na bior\u00e1in is f\u00e9idir ``pin=None`` a \u00fas\u00e1id. micro:bit V2 amh\u00e1in.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Can f\u00f3in\u00e9im\u00ed. (canadh)\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: (f\u00f3in\u00e9im\u00ed) An teaghr\u00e1n focal le canadh.\n:param pitch: (airde) Uimhir a l\u00e9ir\u00edonn airde an ghutha\n:param speed: (luas) Uimhir a l\u00e9ir\u00edonn luas an ghl\u00f3r\n:param mouth: (b\u00e9al) Uimhir a sheasann do bh\u00e9al an ghutha\n:param throat: (scornach) Uimhir a sheasann do scornach an ghutha\n:param pin: (bior\u00e1n) Is f\u00e9idir arg\u00f3int roghnach chun an bior\u00e1in aschuir a shonr\u00fa a \u00fas\u00e1id chun mainneachtain ``pin0``a sh\u00e1r\u00fa.\nMura dteasta\u00edonn uainn aon fhuaim a sheinm as na bior\u00e1in is f\u00e9idir ``pin=None``a \u00fas\u00e1id. micro:bit V2 amh\u00e1in.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "\"\"\"Pac\u00e1isti\u00fa agus d\u00edphac\u00e1il cine\u00e1lacha sonra\u00ed bun\u00fasach.\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom typing import Any, Tuple, Union\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"Faigh l\u00edon na mbeart a theasta\u00edonn chun an ``fmt`` tugtha a st\u00f3r\u00e1il.\n\nExample: ``struct.calcsize('hf')``\n\n:param fmt: Teaghr\u00e1n form\u00e1ide.\n:return The number of bytes needed to store such a value.\"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"Pac\u00e1il luachanna de r\u00e9ir teaghr\u00e1n form\u00e1ide. (pac\u00e1iste)\n\nExample: ``struct.pack('hf', 1, 3.1415)``\n\n:param fmt: An teaghr\u00e1n form\u00e1ide.\n:param v1: An ch\u00e9ad luach.\n:param *vn: Na luachanna at\u00e1 f\u00e1gtha.\n:return A bytes object encoding the values.\"\"\"\n    ...\n\ndef pack_into(fmt: str, buffer: WriteableBuffer, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"Pac\u00e1il luachanna de r\u00e9ir teaghr\u00e1n form\u00e1ide. (pac\u00e1il isteach i)\n\nExample: ``struct.pack_info('hf', buffer, 1, 3.1415)``\n\n:param fmt: An teaghr\u00e1n form\u00e1ide.\n:param buffer: (maol\u00e1n) An maol\u00e1n sprice le scr\u00edobh isteach.\n:param offset: (frith\u00e1ireamh) An frith\u00e1ireamh isteach sa mhaol\u00e1n. D'fh\u00e9adfadh s\u00e9 a bheith di\u00faltach le comhaireamh \u00f3 dheireadh an mhaol\u00e1in.\n:param v1: An ch\u00e9ad luach.\n:param *vn: Na luachanna at\u00e1 f\u00e1gtha.\"\"\"\n    ...\n\ndef unpack(fmt: str, data: ReadableBuffer) -> Tuple[Any, ...]:\n    \"\"\"D\u00edphac\u00e1il sonra\u00ed de r\u00e9ir teaghr\u00e1n form\u00e1ide. (d\u00edphac\u00e1il)\n\nExample: ``v1, v2 = struct.unpack('hf', buffer)``\n\n:param fmt: An teaghr\u00e1n form\u00e1ide.\n:param data: (sonra\u00ed) Na sonra\u00ed.\n:return: A tuple of the unpacked values.\"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: ReadableBuffer, offset: int=0) -> Tuple:\n    \"\"\"D\u00edphac\u00e1il sonra\u00ed \u00f3 mhaol\u00e1n de r\u00e9ir teaghr\u00e1n form\u00e1ide. (d\u00edphac\u00e1il \u00f3)\n\nExample: ``v1, v2 = struct.unpack_from('hf', buffer)``\n\n:param fmt: An teaghr\u00e1n form\u00e1ide.\n:param buffer: (maol\u00e1n) An maol\u00e1n foinseach le l\u00e9amh as.\n:param offset: (frith\u00e1ireamh) An frith\u00e1ireamh isteach sa mhaol\u00e1n. D'fh\u00e9adfadh s\u00e9 a bheith di\u00faltach le comhaireamh \u00f3 dheireadh an mhaol\u00e1in.\n:return: A tuple of the unpacked values.\"\"\"\n    ...",
    "/typeshed/stdlib/sys.pyi": "\"\"\"Feidhmeanna a bhaineann go sonrach leis an gc\u00f3ras\"\"\"\nfrom typing import Any, Dict, List, NoReturn, TextIO, Tuple\n\ndef exit(retval: object=...) -> NoReturn:\n    \"\"\"Cuir deireadh leis an r\u00edomhchl\u00e1r reatha le c\u00f3d scoir ar leith. (scoir)\n\nExample: ``sys.exit(1)``\n\nThis function raises a ``SystemExit`` exception. If an argument is given, its\nvalue given as an argument to ``SystemExit``.\n\n:param retval: An c\u00f3d scoir n\u00f3 an teachtaireacht.\"\"\"\n    ...\n\ndef print_exception(exc: Exception) -> None:\n    \"\"\"Priont\u00e1il eisceacht le rian\u00fa siar. (eisceacht priont\u00e1la)\n\nExample: ``sys.print_exception(e)``\n\n:param exc: An eisceacht maidir le priont\u00e1il\n\nThis is simplified version of a function which appears in the\n``traceback`` module in CPython.\"\"\"\nargv: List[str]\n\"\"\"Liosta inathraithe d'arg\u00f3int\u00ed a cuireadh t\u00fas leis an gcl\u00e1r reatha leo.\"\"\"\nbyteorder: str\n\"\"\"Ord beart an ch\u00f3rais (``\"little\"`` n\u00f3 ``\"big\"``).\"\"\"\n\nclass _implementation:\n    name: str\n    version: Tuple[int, int, int]\nimplementation: _implementation\n\"\"\"Cusp\u00f3ir le faisn\u00e9is faoi chur i bhfeidhm reatha Python. (cur i bhfeidhm)\n\nFor MicroPython, it has following attributes:\n\n- ``name`` - string \"micropython\"\n- ``version`` - tuple (major, minor, micro), e.g. (1, 7, 0)\n\nThis object is the recommended way to distinguish MicroPython from other\nPython implementations (note that it still may not exist in the very\nminimal ports).\n\nCPython mandates more attributes for this object, but the actual useful\nbare minimum is implemented in MicroPython.\n\"\"\"\nmaxsize: int\n\"\"\"\nUasluach is f\u00e9idir le cine\u00e1l sl\u00e1nuimhir dh\u00fachasach a shealbh\u00fa ar an ard\u00e1n reatha,\nn\u00f3 an luach uasta is f\u00e9idir a l\u00e9iri\u00fa le cine\u00e1l sl\u00e1nuimhir MicroPython, m\u00e1 t\u00e1 s\u00e9 n\u00edos l\u00fa\nn\u00e1 uasluach ard\u00e1in (is \u00e9 sin an c\u00e1s i gc\u00e1s calafoirt MicroPython gan\ntaca\u00edocht int fada). (uasmh\u00e9id)\n\nThis attribute is useful for detecting \"bitness\" of a platform (32-bit vs\n64-bit, etc.). It's recommended to not compare this attribute to some\nvalue directly, but instead count number of bits in it::\n\n    bits = 0\n    v = sys.maxsize\n    while v:\n        bits += 1\n        v >>= 1\n    if bits > 32:\n        # 64-bit (or more) platform\n        ...\n    else:\n        # 32-bit (or less) platform\n        # Note that on 32-bit platform, value of bits may be less than 32\n        # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n        # \"> 32\", \"> 64\" style of comparisons.\n\"\"\"\nmodules: Dict[str, Any]\n\"\"\"Focl\u00f3ir mod\u00fail luchtaithe. (mod\u00fail) \n\nOn some ports, it may not include builtin modules.\"\"\"\npath: List[str]\n\"\"\"Liosta inathraithe d\u2019eolair\u00ed le cuardach a dh\u00e9anamh ar mhod\u00fail allmhairithe. (cos\u00e1n)\"\"\"\nplatform: str\n\"\"\"An t-ard\u00e1n a bhfuil MicroPython ag rith air. (ard\u00e1n) \n\nFor OS/RTOS ports, this is usually an identifier of the OS, e.g. ``\"linux\"``.\nFor baremetal ports it is an identifier of a board, e.g. ``\"pyboard\"`` for \nthe original MicroPython reference board. It thus can be used to\ndistinguish one board from another.\n\nIf you need to check whether your program runs on MicroPython (vs other\nPython implementation), use ``sys.implementation`` instead.\n\"\"\"\nversion: str\n\"\"\"Leagan teanga Python a chlo\u00edonn leis an gcur i bhfeidhm seo, mar theaghr\u00e1n. (leagan)\"\"\"\nversion_info: Tuple[int, int, int]\n\"\"\"Leagan teanga Python a gcomhl\u00edonann an cur i bhfeidhm seo, mar thupla de shl\u00e1inti\u00fair\u00ed. (eolas faoin leagan)\n\nOnly the first three version numbers (major, minor, micro) are supported and\nthey can be referenced only by index, not by name.\n\"\"\"",
    "/typeshed/stdlib/this.pyi": "def authors() -> str: ...\n",
    "/typeshed/stdlib/time.pyi": "\"\"\"Tomhais am agus cuir moilleanna le r\u00edomhchl\u00e1ir. (am)\"\"\"\nfrom typing import Union\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"Moill a chur ar roinnt soicind\u00ed. (codladh)\n\nExample: ``time.sleep(1)``\n\n:param seconds: (soicind\u00ed) L\u00edon na soicind\u00ed le codladh.\nBain \u00fas\u00e1id as uimhir sn\u00e1mhphointe chun codladh ar feadh uimhir chod\u00e1nach soicind.\"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"Moill ar l\u00edon \u00e1irithe milleasoicind\u00ed. (codladh ms)\n\nExample: ``time.sleep_ms(1_000_000)``\n\n:param ms: L\u00edon na milleasoicind\u00ed moill (>= 0).\"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"Moill ar l\u00edon \u00e1irithe micreasoicind\u00ed. (codladh linn)\n\nExample: ``time.sleep_us(1000)``\n\n:param us: (linn) L\u00edon na micreasoicind\u00ed moill (>= 0).\"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"Faigh cuntar milleasoicind at\u00e1 ag dul i m\u00e9id le pointe tagartha treallach,\na chl\u00fada\u00edonn thart tar \u00e9is luach \u00e9igin. (sceart\u00e1in ms)\n\nExample: ``time.ticks_ms()``\n\n:return: The counter value in milliseconds.\"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"Faigh cuntar m\u00e9adaitheach micreasoicind le pointe tagartha treallach,\na chl\u00fada\u00edonn thart tar \u00e9is luach \u00e9igin. (tic a chur orainn)\n\nExample: ``time.ticks_us()``\n\n:return: The counter value in microseconds.\"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"Frith\u00e1ireamh luach ticeanna de r\u00e9ir uimhir ar leith, a d'fh\u00e9adfadh a bheith dearfach n\u00f3\ndi\u00faltach. (cuir sceart\u00e1in)\n\nExample: ``time.ticks_add(time.ticks_ms(), 200)``\n\nGiven a ticks value, this function allows to calculate ticks\nvalue delta ticks before or after it, following modular-arithmetic\ndefinition of tick values.\n\n:param ticks: (sceart\u00e1in) Luach ticeanna\n:param delta: (deilte) Frith\u00e1ireamh sl\u00e1nuimhir\n\nExample::\n\n    # Find out what ticks value there was 100ms ago\n    print(ticks_add(time.ticks_ms(), -100))\n\n    # Calculate deadline for operation and test for it\n    deadline = ticks_add(time.ticks_ms(), 200)\n    while ticks_diff(deadline, time.ticks_ms()) > 0:\n        do_a_little_of_something()\n\n    # Find out TICKS_MAX used by this port\n    print(ticks_add(0, -1))\"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"Tomhais an difr\u00edocht idir luachanna a chuirtear ar ais \u00f3\n``time.ticks_ms()`` n\u00f3 ``ticks_us()``, mar luach s\u00ednithe\na d'fh\u00e9adfadh timfhilleadh timpeall. (ticeanna difr)\n\nExample: ``time.ticks_diff(scheduled_time, now)``\n\n:param ticks1: (ticeanna1) An luach a dheal\u00fa \u00f3\n:param ticks2: (ticeanna2) An luach a dheal\u00fa\n\nThe argument order is the same as for subtraction operator,\n``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n``ticks_diff()`` is designed to accommodate various usage\npatterns, among them:\n\nPolling with timeout. In this case, the order of events is known, and you\nwill deal only with positive results of :func:`time.ticks_diff()`::\n\n    # Wait for GPIO pin to be asserted, but at most 500us\n    start = time.ticks_us()\n    while pin.value() == 0:\n        if time.ticks_diff(time.ticks_us(), start) > 500:\n            raise TimeoutError\n\n\nScheduling events. In this case, :func:`time.ticks_diff()` result may be\nnegative if an event is overdue::\n\n    # This code snippet is not optimized\n    now = time.ticks_ms()\n    scheduled_time = task.scheduled_time()\n    if ticks_diff(scheduled_time, now) > 0:\n        print(\"Too early, let's nap\")\n        sleep_ms(ticks_diff(scheduled_time, now))\n        task.run()\n    elif ticks_diff(scheduled_time, now) == 0:\n        print(\"Right at time!\")\n        task.run()\n    elif ticks_diff(scheduled_time, now) < 0:\n        print(\"Oops, running late, tell task to run faster!\")\n        task.run(run_faster=True)\"\"\"\n    ...",
    "/typeshed/stdlib/types.pyi": "import sys\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    __hash__: None  # type: ignore\n    cell_contents: Any\n\n@final\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    __globals__: dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: None  # type: ignore\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: dict[str, Any]\n    __package__: str | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: GeneratorType[_T_co, _T_contra, Any] | None\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Awaitable[Any] | None\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\n@final\nclass CoroutineType:\n    cr_await: Any | None\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: object | None, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    __closure__: Tuple[_Cell, ...] | None  # inherited from the added function\n    __defaults__: Tuple[Any, ...] | None  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    __self__: object | ModuleType\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    @final\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    @final\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\n@final\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(\n            self,\n            tb_next: TracebackType | None,\n            tb_frame: FrameType,\n            tb_lasti: int,\n            tb_lineno: int,\n        ) -> None: ...\n        tb_next: TracebackType | None\n    else:\n        @property\n        def tb_next(self) -> TracebackType | None: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    f_back: FrameType | None\n    f_builtins: dict[str, Any]\n    f_code: CodeType\n    f_globals: dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: dict[str, Any]\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: dict[str, Any] | None = ...\n) -> Tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    @final\n    class UnionType:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> UnionType: ...\n        def __ror__(self, obj: Any) -> UnionType: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = ...,\n    localns: dict[str, Any] | None = ...,\n    include_extras: bool = ...,\n) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Type[Any] | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: None | Type[Any] | str = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "from array import *\n",
    "/typeshed/stdlib/ucollections.pyi": "from collections import *\n",
    "/typeshed/stdlib/uerrno.pyi": "from errno import *\n",
    "/typeshed/stdlib/urandom.pyi": "from random import *\n",
    "/typeshed/stdlib/ustruct.pyi": "from struct import *\n",
    "/typeshed/stdlib/usys.pyi": "from sys import *\n",
    "/typeshed/stdlib/utime.pyi": "from time import *\n",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any]]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any]]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"Bior\u00e1in, \u00edomh\u00e1nna, fuaimeanna, teocht agus toirt.\"\"\"\nfrom typing import Any, Callable, List, Optional, Tuple, Union, overload\nfrom _typeshed import ReadableBuffer\nfrom . import accelerometer as accelerometer\nfrom . import audio as audio\nfrom . import compass as compass\nfrom . import display as display\nfrom . import i2c as i2c\nfrom . import microphone as microphone\nfrom . import speaker as speaker\nfrom . import spi as spi\nfrom . import uart as uart\n\ndef run_every(callback: Optional[Callable[[], None]]=None, days: int=0, h: int=0, min: int=0, s: int=0, ms: int=0) -> Callable[[Callable[[], None]], Callable[[], None]]:\n    \"\"\"Sceideal chun feidhm a rith ag an eatramh a shonra\u00edtear leis na harg\u00f3int\u00ed ama **V2 amh\u00e1in**. (rith gach)\n\nExample: ``run_every(my_logging, min=5)``\n\n``run_every`` can be used in two ways:\n\nAs a Decorator - placed on top of the function to schedule. For example::\n\n    @run_every(h=1, min=20, s=30, ms=50)\n    def my_function():\n        # Do something here\n\nAs a Function - passing the callback as a positional argument. For example::\n\n    def my_function():\n        # Do something here\n    run_every(my_function, s=30)\n\nEach argument corresponds to a different time unit and they are additive.\nSo ``run_every(min=1, s=30)`` schedules the callback every minute and a half.\n\nWhen an exception is thrown inside the callback function it deschedules the\nfunction. To avoid this you can catch exceptions with ``try/except``.\n\n:param callback: Feidhm chun glaoch ag an eatramh a shol\u00e1thra\u00edtear. F\u00e1g ar l\u00e1r agus \u00e9 \u00e1 \u00fas\u00e1id mar mhaisitheoir.\n:param days: (laethanta) Socra\u00edonn s\u00e9 an marc lae don sceideal\u00fa.\n:param h: Socra\u00edonn s\u00e9 an marc uair an chloig don sceideal\u00fa.\n:param min: (\u00edos) Socra\u00edonn s\u00e9 an marc n\u00f3im\u00e9ad don sceideal\u00fa.\n:param s: Socraigh an dara marc don sceideal\u00fa.\n:param ms: Socra\u00edonn s\u00e9 an marc milleasoicind don sceideal\u00fa.\"\"\"\n\ndef panic(n: int) -> None:\n    \"\"\"T\u00e9igh isteach i m\u00f3d scaoill. (scaoll)\n\nExample: ``panic(127)``\n\n:param n: Sl\u00e1nuimhir treallach <= 255 chun st\u00e1das a l\u00e9iri\u00fa.\n\nRequires restart.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Atosaigh an bord. (athshocr\u00fa)\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[int, int]) -> int:\n    \"\"\"Athra\u00edonn luach \u00f3 raon go raon sl\u00e1nuimhir. (sc\u00e1la)\n\nExample: ``volume = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))``\n\nFor example, to convert an accelerometer X value to a speaker volume.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\n\n    temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))\n\n:param value: (luach) Uimhir le tiont\u00fa.\n:param from_: (\u00f3) A tuple a shainmh\u00edni\u00fa ar an raon a thiont\u00fa \u00f3.\n:param to: (chuig) A tuple a shainmh\u00edni\u00fa ar an raon a thiont\u00fa go.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[float, float]) -> float:\n    \"\"\"Athra\u00edonn luach \u00f3 raon go raon sn\u00e1mhphointe. (sc\u00e1la)\n\nExample: ``temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))``\n\nFor example, to convert temperature from a Celsius scale to Fahrenheit.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\nIf they are both integers (i.e ``10``), it will return an integer::\n\n    returns_int = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))\n\n:param value: (luach) Uimhir le tiont\u00fa.\n:param from_: (\u00f3) Tupla chun an raon le tiont\u00fa uaidh a shaini\u00fa.\n:param to: (chuig) Tupla chun an raon le tiont\u00fa chuige a shaini\u00fa.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\ndef sleep(n: float) -> None:\n    \"\"\"Fan le haghaidh milleasoicind\u00ed ``n`` . (codladh)\n\nExample: ``sleep(1000)``\n\n:param n: L\u00edon na milleasoicind\u00ed le fanacht\n\nOne second is 1000 milliseconds, so::\n\n    microbit.sleep(1000)\n\nwill pause the execution for one second.\"\"\"\n\ndef running_time() -> int:\n    \"\"\"Faigh am reatha an bhoird. (am reatha)\n\n:return: The number of milliseconds since the board was switched on or restarted.\"\"\"\n\ndef temperature() -> int:\n    \"\"\"Faigh teocht an micro:bit i gc\u00e9imeanna Celsius. (teocht)\"\"\"\n\ndef set_volume(v: int) -> None:\n    \"\"\"Socraigh an t-imleabhar. (socraigh an toirt)\n\nExample: ``set_volume(127)``\n\n:param v: luach idir 0 (\u00edseal) agus 255 (ard).\n\nOut of range values will be clamped to 0 or 255.\n\n**V2** only.\"\"\"\n    ...\n\nclass Button:\n    \"\"\"An rang do na cnaip\u00ed ``button_a`` agus ``button_b``. (cnaipe)\"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"Seice\u00e1il an bhfuil an cnaipe br\u00faite. (br\u00faite)\n\n:return: ``True`` if the specified button ``button`` is pressed, and ``False`` otherwise.\"\"\"\n        ...\n\n    def was_pressed(self) -> bool:\n        \"\"\"Seice\u00e1il ar br\u00fadh an cnaipe \u00f3 thosaigh an gl\u00e9as n\u00f3 an uair dheireanach a glaodh ar an modh seo. (br\u00fadh)\n\nCalling this method will clear the press state so\nthat the button must be pressed again before this method will return\n``True`` again.\n\n:return: ``True`` if the specified button ``button`` was pressed, and ``False`` otherwise\"\"\"\n        ...\n\n    def get_presses(self) -> int:\n        \"\"\"Faigh ioml\u00e1n reatha na gcnaip\u00ed, agus athshocra\u00edonn s\u00e9 an t-ioml\u00e1n seo\nn\u00e1id sula bhfillfidh t\u00fa. (faigh br\u00faiteanna)\n\n:return: The number of presses since the device started or the last time this method was called\"\"\"\n        ...\nbutton_a: Button\n\"\"\"An cnaipe ar chl\u00e9 ``Button`` r\u00e9ad. (cnaipe a)\"\"\"\nbutton_b: Button\n\"\"\"An cnaipe ceart ``Button`` r\u00e9ad. (cnaipe b)\"\"\"\n\nclass MicroBitDigitalPin:\n    \"\"\"Bior\u00e1n digiteach.\n\nSome pins support analog and touch features using the ``MicroBitAnalogDigitalPin`` and ``MicroBitTouchPin`` subclasses.\"\"\"\n    NO_PULL: int\n    PULL_UP: int\n    PULL_DOWN: int\n\n    def read_digital(self) -> int:\n        \"\"\"Faigh luach digiteach an bhior\u00e1in. (l\u00e9igh digiteach)\n\nExample: ``value = pin0.read_digital()``\n\n:return: 1 if the pin is high, and 0 if it's low.\"\"\"\n        ...\n\n    def write_digital(self, value: int) -> None:\n        \"\"\"Socraigh luach digiteach an bhior\u00e1in. (scr\u00edobh digiteach)\n\nExample: ``pin0.write_digital(1)``\n\n:param value: (luach) 1 chun an pionna a shocr\u00fa ard n\u00f3 0 chun an pionna a shocr\u00fa \u00edseal\"\"\"\n        ...\n\n    def set_pull(self, value: int) -> None:\n        \"\"\"Socraigh an staid tarraingthe go ceann de thr\u00ed luach f\u00e9ideartha: ``PULL_UP``, ``PULL_DOWN`` n\u00f3 ``NO_PULL``. (tarraingt socraithe)\n\nExample: ``pin0.set_pull(pin0.PULL_UP)``\n\n:param value: (luach) An staid tarraingthe \u00f3n bior\u00e1in \u00e1bhartha, m.sh. ``pin0.PULL_UP``.\"\"\"\n        ...\n\n    def get_pull(self) -> int:\n        \"\"\"Faigh an st\u00e1t tarraingt ar pionna. (faigh socraithe)\n\nExample: ``pin0.get_pull()``\n\n:return: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``\n\nThese are set using the ``set_pull()`` method or automatically configured\nwhen a pin mode requires it.\"\"\"\n        ...\n\n    def get_mode(self) -> str:\n        \"\"\"Filleann an modh pionna. (m\u00f3d faighte)\n\nExample: ``pin0.get_mode()``\n\nWhen a pin is used for a specific function, like\nwriting a digital value, or reading an analog value, the pin mode\nchanges.\n\n:return: ``\"unused\"``, ``\"analog\"``, ``\"read_digital\"``, ``\"write_digital\"``, ``\"display\"``, ``\"button\"``, ``\"music\"``, ``\"audio\"``, ``\"touch\"``, ``\"i2c\"``, or ``\"spi\"``\"\"\"\n        ...\n\n    def write_analog(self, value: int) -> None:\n        \"\"\"Aschuir comhartha PWM ar an bior\u00e1in, agus an timthriall dleachta comhr\u00e9ireach le ``value``. (scr\u00edobh anal\u00f3gach)\n\nExample: ``pin0.write_analog(254)``\n\n:param value: (luach) Sl\u00e1nuimhir n\u00f3 uimhir sn\u00e1mhphointe idir 0 (0% timthriall dleachta) agus 1023 (dleacht 100%).\"\"\"\n\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"Socraigh tr\u00e9imhse an chomhartha PWM at\u00e1 \u00e1 haschur go dt\u00ed ``period`` ina milleasoicind\u00ed. (socraigh tr\u00e9imhse anal\u00f3gach)\n\nExample: ``pin0.set_analog_period(10)``\n\n:param period: (tr\u00e9imhse) An tr\u00e9imhse ina milleasoicind\u00ed le luach bail\u00ed \u00edosta de 1ms.\"\"\"\n\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"Socraigh tr\u00e9imhse an chomhartha PWM at\u00e1 \u00e1 haschur go dt\u00ed ``period`` i micrishoicind\u00ed. (micreasoicind\u00ed tr\u00e9imhse anal\u00f3gacha a shocr\u00fa)\n\nExample: ``pin0.set_analog_period_microseconds(512)``\n\n:param period: (tr\u00e9imhse) An tr\u00e9imhse i micrishoicind\u00ed le \u00edosluach bail\u00ed de 256\u00b5s.\"\"\"\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    \"\"\"Bior\u00e1in le gn\u00e9ithe anal\u00f3gacha agus digiteacha.\"\"\"\n\n    def read_analog(self) -> int:\n        \"\"\"L\u00e9igh an voltas a chuirtear i bhfeidhm ar an bior\u00e1n. (l\u00e9igh anal\u00f3gach)\n\nExample: ``pin0.read_analog()``\n\n:return: An integer between 0 (meaning 0V) and 1023 (meaning 3.3V).\"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    \"\"\"Pionna le gn\u00e9ithe anal\u00f3gacha, digiteacha agus tadhaill.\"\"\"\n    CAPACITIVE: int\n    RESISTIVE: int\n\n    def is_touched(self) -> bool:\n        \"\"\"Seice\u00e1il an bhfuil teagmh\u00e1il \u00e1 d\u00e9anamh leis an bior\u00e1n. (i dteagmh\u00e1il)\n\nExample: ``pin0.is_touched()``\n\nThe default touch mode for the pins on the edge connector is ``resistive``.\nThe default for the logo pin **V2** is ``capacitive``.\n\n**Resistive touch**\nThis test is done by measuring how much resistance there is between the\npin and ground.  A low resistance gives a reading of ``True``.  To get\na reliable reading using a finger you may need to touch the ground pin\nwith another part of your body, for example your other hand.\n\n**Capacitive touch**\nThis test is done by interacting with the electric field of a capacitor\nusing a finger as a conductor. `Capacitive touch\n<https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_\ndoes not require you to make a ground connection as part of a circuit.\n\n:return: ``True`` if the pin is being touched with a finger, otherwise return ``False``.\"\"\"\n        ...\n\n    def set_touch_mode(self, value: int) -> None:\n        \"\"\"Socraigh an modh tadhaill don pionna. (socraigh m\u00f3d tadhaill)\n\nExample: ``pin0.set_touch_mode(pin0.CAPACITIVE)``\n\nThe default touch mode for the pins on the edge connector is\n``resistive``. The default for the logo pin **V2** is ``capacitive``.\n\n:param value: (luach) ``CAPACITIVE`` n\u00f3 ``RESISTIVE`` \u00f3n pionna \u00e1bhartha.\"\"\"\n        ...\npin0: MicroBitTouchPin\n\"\"\"Pionna le gn\u00e9ithe digiteacha, anal\u00f3gacha agus tadhaill. (bior\u00e1n0)\"\"\"\npin1: MicroBitTouchPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha, anal\u00f3gacha agus tadhaill. (bior\u00e1n1)\"\"\"\npin2: MicroBitTouchPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha, anal\u00f3gacha agus tadhaill. (bior\u00e1n2)\"\"\"\npin3: MicroBitAnalogDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha agus anal\u00f3gacha. (bior\u00e1n3)\"\"\"\npin4: MicroBitAnalogDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha agus anal\u00f3gacha. (bior\u00e1n4)\"\"\"\npin5: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n5)\"\"\"\npin6: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n6)\"\"\"\npin7: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n7)\"\"\"\npin8: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n8)\"\"\"\npin9: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n9)\"\"\"\npin10: MicroBitAnalogDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha agus anal\u00f3gacha. (bior\u00e1n10)\"\"\"\npin11: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n11)\"\"\"\npin12: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n12)\"\"\"\npin13: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n 13)\"\"\"\npin14: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n14)\"\"\"\npin15: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n15)\"\"\"\npin16: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n16)\"\"\"\npin19: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n19)\"\"\"\npin20: MicroBitDigitalPin\n\"\"\"Bior\u00e1in le gn\u00e9ithe digiteacha. (bior\u00e1n20)\"\"\"\npin_logo: MicroBitTouchPin\n\"\"\"Bior\u00e1n l\u00f3g\u00f3 \u00edogair do theagmh\u00e1il ar aghaidh an micro:bit, at\u00e1 socraithe de r\u00e9ir r\u00e9amhshocraithe go m\u00f3d tadhaill toilleasach. (l\u00f3g\u00f3 bior\u00e1in)\"\"\"\npin_speaker: MicroBitAnalogDigitalPin\n\"\"\"Bior\u00e1n chun an cainteoir micro:bit a sheoladh. (cainteoir bior\u00e1in)\n\nThis API is intended only for use in Pulse-Width Modulation pin operations e.g. pin_speaker.write_analog(128).\n\"\"\"\n\nclass Image:\n    \"\"\"\u00cdomh\u00e1 le taispe\u00e1int ar an taispe\u00e1int micro:bit LED. (\u00edomh\u00e1)\n\nGiven an image object it's possible to display it via the ``display`` API::\n\n    display.show(Image.HAPPY)\"\"\"\n    HEART: Image\n    \"\"\"\u00cdomh\u00e1 chro\u00ed. (cro\u00ed)\"\"\"\n    HEART_SMALL: Image\n    \"\"\"\u00cdomh\u00e1 bheag chro\u00ed. (cro\u00ed beag)\"\"\"\n    HAPPY: Image\n    \"\"\"\u00cdomh\u00e1 aghaidhe sona. (s\u00e1sta)\"\"\"\n    SMILE: Image\n    \"\"\"\u00cdomh\u00e1 b\u00e9il ag g\u00e1ire. (aoibh gh\u00e1ire)\"\"\"\n    SAD: Image\n    \"\"\"\u00cdomh\u00e1 aghaidhe br\u00f3nach. (br\u00f3nach)\"\"\"\n    CONFUSED: Image\n    \"\"\"\u00cdomh\u00e1 aghaidhe mearbhall. (mearbhall)\"\"\"\n    ANGRY: Image\n    \"\"\"\u00cdomh\u00e1 aghaidh feargach. (feargach)\"\"\"\n    ASLEEP: Image\n    \"\"\"\u00cdomh\u00e1 aghaidhe codlata. (ina chodladh)\"\"\"\n    SURPRISED: Image\n    \"\"\"\u00cdomh\u00e1 aghaidhe ionadh. (ionadh)\"\"\"\n    SILLY: Image\n    \"\"\"\u00cdomh\u00e1 aghaidh amaideach. (amaideach)\"\"\"\n    FABULOUS: Image\n    \"\"\"\u00cdomh\u00e1 aghaidhe sp\u00e9acla\u00ed gr\u00e9ine. (iontach)\"\"\"\n    MEH: Image\n    \"\"\"\u00cdomh\u00e1 aghaidhe neamhbhr\u00faite.\"\"\"\n    YES: Image\n    \"\"\"Cuir tic leis an \u00edomh\u00e1. (t\u00e1)\"\"\"\n    NO: Image\n    \"\"\"\u00cdomh\u00e1 croise. (n\u00edl)\"\"\"\n    CLOCK12: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe ar 12 a chlog. (clog12)\"\"\"\n    CLOCK11: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe ar 11 a chlog. (clog11)\"\"\"\n    CLOCK10: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe ar 10 a chlog. (clog10)\"\"\"\n    CLOCK9: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe go dt\u00ed 9 a chlog. (clog9)\"\"\"\n    CLOCK8: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe go dt\u00ed 8 a chlog. (clog8)\"\"\"\n    CLOCK7: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe go dt\u00ed 7 a chlog. (clog7)\"\"\"\n    CLOCK6: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne ag d\u00edri\u00fa go dt\u00ed 6 a chlog. (clog6)\"\"\"\n    CLOCK5: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe go dt\u00ed 5 a chlog. (clog5)\"\"\"\n    CLOCK4: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe go dt\u00ed 4 a chlog. (clog4)\"\"\"\n    CLOCK3: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne d\u00edrithe go dt\u00ed 3 a chlog. (clog3)\"\"\"\n    CLOCK2: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne ag d\u00edri\u00fa go dt\u00ed 2 a chlog. (clog2)\"\"\"\n    CLOCK1: Image\n    \"\"\"\u00cdomh\u00e1 le l\u00edne ag d\u00edri\u00fa go dt\u00ed 1 a chlog. (clog1)\"\"\"\n    ARROW_N: Image\n    \"\"\"\u00cdomh\u00e1 na saigheade d\u00edrithe \u00f3 thuaidh. (saighead n)\"\"\"\n    ARROW_NE: Image\n    \"\"\"\u00cdomh\u00e1 na saigheade d\u00edrithe soir \u00f3 thuaidh. (saighead ne)\"\"\"\n    ARROW_E: Image\n    \"\"\"\u00cdomh\u00e1 na saigheade d\u00edrithe ar an taobh thoir. (saighead e)\"\"\"\n    ARROW_SE: Image\n    \"\"\"\u00cdomh\u00e1 na saigheade d\u00edrithe soir \u00f3 dheas. (saighead se)\"\"\"\n    ARROW_S: Image\n    \"\"\"\u00cdomh\u00e1 na saigheade d\u00edrithe \u00f3 dheas. (saighead s)\"\"\"\n    ARROW_SW: Image\n    \"\"\"\u00cdomh\u00e1 na saigheade d\u00edrithe siar \u00f3 dheas. (saighead sw)\"\"\"\n    ARROW_W: Image\n    \"\"\"\u00cdomh\u00e1 den tsaighead at\u00e1 d\u00edrithe siar. (saighead w)\"\"\"\n    ARROW_NW: Image\n    \"\"\"\u00cdomh\u00e1 na saigheade d\u00edrithe siar \u00f3 thuaidh. (saighead nw)\"\"\"\n    TRIANGLE: Image\n    \"\"\"\u00cdomh\u00e1 de thriant\u00e1n ag pointe\u00e1il suas. (triant\u00e1n)\"\"\"\n    TRIANGLE_LEFT: Image\n    \"\"\"\u00cdomh\u00e1 de thriant\u00e1n sa ch\u00fainne ar chl\u00e9. (triant\u00e1n ar chl\u00e9)\"\"\"\n    CHESSBOARD: Image\n    \"\"\"Soilse LEDs malartacha i bpatr\u00fan cl\u00e1r fichille. (cl\u00e1r fichille)\"\"\"\n    DIAMOND: Image\n    \"\"\"\u00cdomh\u00e1 diamant. (diamant)\"\"\"\n    DIAMOND_SMALL: Image\n    \"\"\"\u00cdomh\u00e1 diamant beag. (diamant beag)\"\"\"\n    SQUARE: Image\n    \"\"\"\u00cdomh\u00e1 cearn\u00f3g. (cearn\u00f3g)\"\"\"\n    SQUARE_SMALL: Image\n    \"\"\"\u00cdomh\u00e1 beag cearnach. (cearnach beag)\"\"\"\n    RABBIT: Image\n    \"\"\"\u00cdomh\u00e1 coin\u00edn. (coin\u00edn)\"\"\"\n    COW: Image\n    \"\"\"\u00cdomh\u00e1 b\u00f3. (b\u00f3)\"\"\"\n    MUSIC_CROTCHET: Image\n    \"\"\"\u00cdomh\u00e1 n\u00f3ta cr\u00f3ise. (crois\u00e9ad ceoil)\"\"\"\n    MUSIC_QUAVER: Image\n    \"\"\"Creath\u00e1n n\u00f3ta \u00edomh\u00e1. (cuais cheoil)\"\"\"\n    MUSIC_QUAVERS: Image\n    \"\"\"\u00cdomh\u00e1 de n\u00f3ta\u00ed p\u00e9ire ocht\u00fa comhartha. (cuacha ceoil)\"\"\"\n    PITCHFORK: Image\n    \"\"\"\u00cdomh\u00e1 forc pice. (forc-pice)\"\"\"\n    XMAS: Image\n    \"\"\"\u00cdomh\u00e1 crann Nollag. (nollag)\"\"\"\n    PACMAN: Image\n    \"\"\"\u00cdomh\u00e1 carachtar stuara PAC-Man.\"\"\"\n    TARGET: Image\n    \"\"\"\u00cdomh\u00e1 sprice. (sprioc)\"\"\"\n    TSHIRT: Image\n    \"\"\"\u00cdomh\u00e1 T-l\u00e9ine. (l\u00e9ine-t)\"\"\"\n    ROLLERSKATE: Image\n    \"\"\"\u00cdomh\u00e1 sc\u00e1t\u00e1il-roll\u00e1la. (sc\u00e1t\u00e1il-roll\u00e1la)\"\"\"\n    DUCK: Image\n    \"\"\"\u00cdomh\u00e1 lacha. (lacha)\"\"\"\n    HOUSE: Image\n    \"\"\"\u00cdomh\u00e1 t\u00ed. (teach)\"\"\"\n    TORTOISE: Image\n    \"\"\"\u00cdomh\u00e1 turtar. (toirt\u00eds)\"\"\"\n    BUTTERFLY: Image\n    \"\"\"\u00cdomh\u00e1 f\u00e9ileac\u00e1n. (f\u00e9ileac\u00e1n)\"\"\"\n    STICKFIGURE: Image\n    \"\"\"Bata \u00edomh\u00e1 figi\u00far. (figi\u00far-maide)\"\"\"\n    GHOST: Image\n    \"\"\"\u00cdomh\u00e1 taibhse. (taibhse)\"\"\"\n    SWORD: Image\n    \"\"\"\u00cdomh\u00e1 chla\u00edomh. (cla\u00edomh)\"\"\"\n    GIRAFFE: Image\n    \"\"\"\u00cdomh\u00e1 sior\u00e1f. (sior\u00e1f)\"\"\"\n    SKULL: Image\n    \"\"\"\u00cdomh\u00e1 cloigeann. (cloigeann)\"\"\"\n    UMBRELLA: Image\n    \"\"\"\u00cdomh\u00e1 sc\u00e1th fearthainne. (sc\u00e1th fearthainne)\"\"\"\n    SNAKE: Image\n    \"\"\"\u00cdomh\u00e1 nathair. (nathair)\"\"\"\n    SCISSORS: Image\n    \"\"\"\u00cdomh\u00e1 sios\u00far. (sios\u00far)\"\"\"\n    ALL_CLOCKS: List[Image]\n    \"\"\"Liosta ina bhfuil na h\u00edomh\u00e1nna CLOCK_ go l\u00e9ir in ord. (gach clog)\"\"\"\n    ALL_ARROWS: List[Image]\n    \"\"\"Liosta ina bhfuil na h\u00edomh\u00e1nna ARROW_ go l\u00e9ir in ord. (gach saighead)\"\"\"\n\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"Cruthaigh \u00edomh\u00e1 \u00f3 theaghr\u00e1n ag cur s\u00edos ar na soilse at\u00e1 lasta.\n\n``string`` has to consist of digits 0-9 arranged into lines,\ndescribing the image, for example::\n\n    image = Image(\"90009:\"\n                  \"09090:\"\n                  \"00900:\"\n                  \"09090:\"\n                  \"90009\")\n\nwill create a 5\u00d75 image of an X. The end of a line is indicated by a\ncolon. It's also possible to use newlines (\\\\n) insead of the colons.\n\n:param string: (teaghr\u00e1n) An teaghr\u00e1n ag cur s\u00edos ar an \u00edomh\u00e1.\"\"\"\n        ...\n\n    @overload\n    def __init__(self, width: int=5, height: int=5, buffer: ReadableBuffer=None) -> None:\n        \"\"\"Cruthaigh \u00edomh\u00e1 fholamh le col\u00fain ``width`` agus sraitheanna ``height`` .\n\n:param width: (leithead) Leithead roghnach na h\u00edomh\u00e1\n:param height: (airde) Airde roghnach na h\u00edomh\u00e1\n:param buffer: (maol\u00e1n) Eagar roghnach n\u00f3 bearta de ``width``\u00d7``height`` sl\u00e1nuimhreacha i raon 0-9 chun an \u00edomh\u00e1 a th\u00fas\u00fa\n\nExamples::\n\n    Image(2, 2, b'\\x08\\x08\\x08\\x08')\n    Image(2, 2, bytearray([9,9,9,9]))\n\nThese create 2 x 2 pixel images at full brightness.\"\"\"\n        ...\n\n    def width(self) -> int:\n        \"\"\"Faigh l\u00edon na gcol\u00fan. (leithead)\n\n:return: The number of columns in the image\"\"\"\n        ...\n\n    def height(self) -> int:\n        \"\"\"Faigh l\u00edon na sraitheanna. (airde)\n\n:return: The number of rows in the image\"\"\"\n        ...\n\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"Socraigh gile picteil\u00edn. (socraigh picteil\u00edn)\n\nExample: ``my_image.set_pixel(0, 0, 9)``\n\n:param x: Uimhir an chol\u00fain\n:param y: Uimhir an r\u00f3\n:param value: (luach) An ghile mar shl\u00e1nuimhir idir 0 (dorcha) agus 9 (geal)\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"Faigh gile picteil\u00edn. (faigh picteil\u00edn)\n\nExample: ``my_image.get_pixel(0, 0)``\n\n:param x: Uimhir an chol\u00fain\n:param y: Uimhir na sraithe\n:return: The brightness as an integer between 0 and 9.\"\"\"\n        ...\n\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00edd an bpicti\u00far ar chl\u00e9 a athr\u00fa. (shift ar chl\u00e9)\n\nExample: ``Image.HEART_SMALL.shift_left(1)``\n\n:param n: L\u00edon na gcol\u00fan at\u00e1 le haistri\u00fa ag\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00edd an bpicti\u00far a athr\u00fa ar dheis. (shift ar dheis)\n\nExample: ``Image.HEART_SMALL.shift_right(1)``\n\n:param n: L\u00edon na gcol\u00fan le haistri\u00fa\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00edd an bpicti\u00far a athr\u00fa suas. (shift suas)\n\nExample: ``Image.HEART_SMALL.shift_up(1)``\n\n:param n: L\u00edon na r\u00f3nna le hathr\u00fa ag\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00edd an bpicti\u00far a aistri\u00fa s\u00edos. (shift s\u00edos)\n\nExample: ``Image.HEART_SMALL.shift_down(1)``\n\n:param n: L\u00edon na r\u00f3nna le haistri\u00fa\n:return: The shifted image\"\"\"\n        ...\n\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00edd an bpicti\u00far a bearradh. (barr)\n\nExample: ``Image.HEART.crop(1, 1, 3, 3)``\n\n:param x: An col\u00fan frith\u00e1ireamh barr\n:param y: An r\u00f3 frith\u00e1ireamh barr\n:param w: An leithead barr\n:param h: An airde barr\n:return: The new image\"\"\"\n        ...\n\n    def copy(self) -> Image:\n        \"\"\"Cruthaigh c\u00f3ip chruinn den \u00edomh\u00e1. (c\u00f3ip)\n\nExample: ``Image.HEART.copy()``\n\n:return: The new image\"\"\"\n        ...\n\n    def invert(self) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00ed ghile na bpicteil\u00edn\u00ed a inbh\u00e9art\u00fa sa\n\u00edomh\u00e1 foinseach. (inbh\u00e9artaithe)\n\nExample: ``Image.SMALL_HEART.invert()``\n\n:return: The new image.\"\"\"\n        ...\n\n    def fill(self, value: int) -> None:\n        \"\"\"Socraigh gile na bpicteil\u00edn\u00ed go l\u00e9ir san \u00edomh\u00e1. (l\u00edon)\n\nExample: ``my_image.fill(5)``\n\n:param value: (luach) An gile nua mar uimhir idir 0 (dorcha) agus 9 (geal).\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def blit(self, src: Image, x: int, y: int, w: int, h: int, xdest: int=0, ydest: int=0) -> None:\n        \"\"\"C\u00f3ipe\u00e1il limist\u00e9ar \u00f3 \u00edomh\u00e1 eile isteach san \u00edomh\u00e1 seo.\n\nExample: ``my_image.blit(Image.HEART, 1, 1, 3, 3, 1, 1)``\n\n:param src: An \u00edomh\u00e1 fhoinseach\n:param x: Frith\u00e1ireamh an chol\u00fain tosaigh san \u00edomh\u00e1 fhoinseach\n:param y: Frith\u00e1ireamh an r\u00f3 tosaigh san \u00edomh\u00e1 foinseach\n:param w: L\u00edon na gcol\u00fan le c\u00f3ipe\u00e1il\n:param h: L\u00edon na r\u00f3nna le c\u00f3ipe\u00e1il\n:param xdest: Frith\u00e1ireamh an chol\u00fain le mionathr\u00fa san \u00edomh\u00e1 seo\n:param ydest: Frith\u00e1ireamh an r\u00f3 le mionathr\u00fa san \u00edomh\u00e1 seo\n\nPixels outside the source image are treated as having a brightness of 0.\n\n``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\nand ``crop()`` can are all implemented by using ``blit()``.\n\nFor example, img.crop(x, y, w, h) can be implemented as::\n\n    def crop(self, x, y, w, h):\n        res = Image(w, h)\n        res.blit(self, x, y, w, h)\n        return res\"\"\"\n        ...\n\n    def __repr__(self) -> str:\n        \"\"\"Faigh l\u00e9iri\u00fa teaghr\u00e1n dl\u00fath ar an \u00edomh\u00e1.\"\"\"\n        ...\n\n    def __str__(self) -> str:\n        \"\"\"Faigh l\u00e9iri\u00fa teaghr\u00e1n inl\u00e9ite ar an \u00edomh\u00e1.\"\"\"\n        ...\n\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00ed na luachanna gile \u00f3n d\u00e1 cheann a chur leis\n\u00edomh\u00e1nna do gach picteil\u00edn. (suimigh)\n\nExample: ``Image.HEART + Image.HAPPY``\n\n:param other: (eile) An \u00edomh\u00e1 le cur leis.\"\"\"\n        ...\n\n    def __sub__(self, other: Image) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00ed luachanna gile an\n\u00edomh\u00e1 eile \u00f3n \u00edomh\u00e1 seo.\n\nExample: ``Image.HEART - Image.HEART_SMALL``\n\n:param other: (eile) An \u00edomh\u00e1 a dheal\u00fa.\"\"\"\n        ...\n\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00ed ghile gach picteil\u00edn a iolr\u00fa faoi\n``n``.\n\nExample: ``Image.HEART * 0.5``\n\n:param n: An luach a iolr\u00fa faoi.\"\"\"\n        ...\n\n    def __truediv__(self, n: float) -> Image:\n        \"\"\"Cruthaigh \u00edomh\u00e1 nua tr\u00ed ghile gach picteil\u00edn a roinnt ar\n``n``.\n\nExample: ``Image.HEART / 2``\n\n:param n: An luach a roinnt ar.\"\"\"\n        ...\n\nclass SoundEvent:\n    LOUD: SoundEvent\n    \"\"\"L\u00e9ir\u00edonn s\u00e9 aistri\u00fa imeachta\u00ed fuaime, \u00f3 ``quiet`` go ``loud`` cos\u00fail le bualadh n\u00f3 b\u00e9ic\u00edl. (ard)\"\"\"\n    QUIET: SoundEvent\n    \"\"\"L\u00e9ir\u00edonn s\u00e9 seo aistri\u00fa imeachta\u00ed fuaime, \u00f3 ``loud`` go ``quiet`` cos\u00fail le ceol labhartha n\u00f3 c\u00falra. (ci\u00fain)\"\"\"\n\nclass Sound:\n    \"\"\"Is f\u00e9idir na fuaimeanna t\u00f3gtha a ghlaoch ag baint \u00fas\u00e1ide as ``audio.play(Sound.NAME)``. (fuaim)\"\"\"\n    GIGGLE: Sound\n    \"\"\"Fuaim scig-gh\u00e1ire. (scig-gh\u00e1ire)\"\"\"\n    HAPPY: Sound\n    \"\"\"Fuaim shona. (s\u00e1sta)\"\"\"\n    HELLO: Sound\n    \"\"\"Fuaime beannacht. (dia duit)\"\"\"\n    MYSTERIOUS: Sound\n    \"\"\"Fuaim mhist\u00e9ireach. (mist\u00e9ireach)\"\"\"\n    SAD: Sound\n    \"\"\"Fuaim bhr\u00f3nach. (br\u00f3nach)\"\"\"\n    SLIDE: Sound\n    \"\"\"Fuaim sleamhn\u00e1in. (sleamhn\u00e1n)\"\"\"\n    SOARING: Sound\n    \"\"\"Fuaim t\u00e9agartha. (t\u00e9agartha)\"\"\"\n    SPRING: Sound\n    \"\"\"Fuaim an earraigh. (an t-earrach)\"\"\"\n    TWINKLE: Sound\n    \"\"\"Fuaim drithligh. (drithligh)\"\"\"\n    YAWN: Sound\n    \"\"\"Fuaim m\u00e9anfach. (m\u00e9anfach)\"\"\"",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"Tomhais luasgh\u00e9ar\u00fa an micro:bit agus aithin gotha\u00ed. (luasmh\u00e9adar)\"\"\"\nfrom typing import Tuple\n\ndef get_x() -> int:\n    \"\"\"Faigh an tomhas luasgh\u00e9araithe san ais ``x`` i milli-g. (faigh x)\n\nExample: ``accelerometer.get_x()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Faigh an tomhas luasgh\u00e9araithe san ais ``y`` i milli-g. (faigh y)\n\nExample: ``accelerometer.get_y()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Faigh an tomhas luasgh\u00e9araithe san ais ``z`` i milli-g. (faigh z)\n\nExample: ``accelerometer.get_z()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"Faigh na tomhais luasgh\u00e9araithe i ngach aiseanna ag an am c\u00e9anna mar tuple. (faigh luachanna)\n\nExample: ``x, y, z = accelerometer.get_values()``\n\n:return: a three-element tuple of integers ordered as X, Y, Z, each value a positive or negative integer depending on direction in the range +/- 2000mg\"\"\"\n    ...\n\ndef get_strength() -> int:\n    \"\"\"Faigh tomhas luasgh\u00e9araithe na n-aiseanna go l\u00e9ir le ch\u00e9ile, mar shl\u00e1nuimhir dhearfach. Is \u00e9 seo suim Pythagorean na n-aiseanna X, Y agus Z. (faigh neart)\n\nExample: ``accelerometer.get_strength()``\n\n:return: The combined acceleration strength of all the axes, in milli-g.\"\"\"\n    ...\n\ndef current_gesture() -> str:\n    \"\"\"Faigh ainm an chomhartha reatha. (gotha \\u200b\\u200breatha)\n\nExample: ``accelerometer.current_gesture()``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:return: The current gesture\"\"\"\n    ...\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"Seice\u00e1il an bhfuil an comhartha ainmnithe gn\u00edomhach faoi l\u00e1thair. (is gotha)\n\nExample: ``accelerometer.is_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (ainm) An t-ainm gotha.\n:return: ``True`` if the gesture is active, ``False`` otherwise.\"\"\"\n    ...\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"Seice\u00e1il an raibh an comhartha ainmnithe gn\u00edomhach \u00f3n nglao deireanach. (bh\u00ed gotha)\n\nExample: ``accelerometer.was_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: (ainm) Ainm an ghluaiseachta.\n:return: ``True`` if the gesture was active since the last call, ``False`` otherwise.\"\"\"\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Tabhair ar ais tuple de stair na gotha\u00ed. (faigh gotha\u00ed)\n\nExample: ``accelerometer.get_gestures()``\n\nClears the gesture history before returning.\n\nGestures are not updated in the background so there needs to be constant\ncalls to some accelerometer method to do the gesture detection. Usually\ngestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n\n:return: The history as a tuple, most recent last.\"\"\"\n    ...\n\ndef set_range(value: int) -> None:\n    \"\"\"Socraigh an raon \u00edogaireachta luasmh\u00e9adair, i g (domhantarraingt chaighde\u00e1nach), go dt\u00ed na luachanna is gaire a dtaca\u00edonn na crua-earra\u00ed leo, agus mar sin cruinn\u00edonn s\u00e9 le ``2``, ``4``, n\u00f3 ``8`` g. (socraigh raon)\n\nExample: ``accelerometer.set_range(8)``\n\n:param value: (luach) Raon nua don luasmh\u00e9adar, sl\u00e1nuimhir i ``g``.\"\"\"",
    "/typeshed/stdlib/microbit/audio.pyi": "\"\"\"Seinn fuaimeanna ag baint \u00fas\u00e1ide as an micro:bit (allmhairi\u00fa ``audio`` le haghaidh comhoiri\u00fanacht V1). (fuaime)\"\"\"\nfrom ..microbit import MicroBitDigitalPin, Sound, pin0\nfrom typing import ClassVar, Iterable, Union\n\ndef play(source: Union[Iterable[AudioFrame], Sound, SoundEffect], wait: bool=True, pin: MicroBitDigitalPin=pin0, return_pin: Union[MicroBitDigitalPin, None]=None) -> None:\n    \"\"\"Seinn fuaim-t\u00f3gtha i, \u00e9ifeacht fuaime n\u00f3 fr\u00e1ma\u00ed fuaime saincheaptha. (seinn)\n\nExample: ``audio.play(Sound.GIGGLE)``\n\n:param source: (foinse) ``Sound`` ionsuite amhail ``Sound.GIGGLE``, ``SoundEffect`` n\u00f3 sonra\u00ed samplacha mar athr\u00e1 ar r\u00e9ada ``AudioFrame``.\n:param wait: (fan) M\u00e1 t\u00e1 ``wait`` ``True``, bloc\u00e1lfaidh an fheidhm seo go dt\u00ed go mbeidh an fhuaim cr\u00edochnaithe.\n:param pin: (bior\u00e1n) Is f\u00e9idir arg\u00f3int roghnach chun an bior\u00e1in aschuir a shonr\u00fa a \u00fas\u00e1id chun mainneachtain ``pin0``a sh\u00e1r\u00fa. Mura dteasta\u00edonn aon fhuaim uainn is f\u00e9idir linn ``pin=None``a \u00fas\u00e1id.\n:param return_pin: (bior\u00e1n fillte) Sonra\u00edonn bior\u00e1in c\u00f3nascaire imeall difre\u00e1lach chun ceangal le cainteoir seachtrach in ionad na tal\u00fan. D\u00e9antar neamhaird air seo don athbhreithni\u00fa **V2**.\"\"\"\n\ndef is_playing() -> bool:\n    \"\"\"Seice\u00e1il an bhfuil fuaim \u00e1 seinm. (ag seinm)\n\nExample: ``audio.is_playing()``\n\n:return: ``True`` if audio is playing, otherwise ``False``.\"\"\"\n    ...\n\ndef stop() -> None:\n    \"\"\"Stop gach athsheinm fuaime. (stad)\n\nExample: ``audio.stop()``\"\"\"\n    ...\n\nclass SoundEffect:\n    \"\"\"\u00c9ifeacht fuaime, comhdh\u00e9anta ag sraith paraim\u00e9adar cumraithe tr\u00edd an cruthaitheoir n\u00f3 tr\u00e9ithe. (\u00e9ifeachtfuaime)\"\"\"\n    WAVEFORM_SINE: ClassVar[int]\n    \"\"\"Rogha tonn sine a \u00fas\u00e1idtear don pharaim\u00e9adar ``waveform`` . (tonnchruth s\u00edneas)\"\"\"\n    WAVEFORM_SAWTOOTH: ClassVar[int]\n    \"\"\"Rogha tonn fiacail s\u00e1bha a \u00fas\u00e1idtear don pharaim\u00e9adar ``waveform`` . (tonnfhad fiacail s\u00e1bha)\"\"\"\n    WAVEFORM_TRIANGLE: ClassVar[int]\n    \"\"\"Rogha tonn triant\u00e1in a \u00fas\u00e1idtear don pharaim\u00e9adar ``waveform`` . (triant\u00e1n tonnchrutha)\"\"\"\n    WAVEFORM_SQUARE: ClassVar[int]\n    \"\"\"Rogha tonn cearnach a \u00fas\u00e1idtear don pharaim\u00e9adar ``waveform`` . (cearn\u00f3g tonnfhoirme)\"\"\"\n    WAVEFORM_NOISE: ClassVar[int]\n    \"\"\"Rogha torainn a \u00fas\u00e1idtear don pharaim\u00e9adar ``waveform`` . (torann tonnfhoirme)\"\"\"\n    SHAPE_LINEAR: ClassVar[int]\n    \"\"\"Rogha idirshu\u00edomh l\u00edneach a \u00fas\u00e1idtear don pharaim\u00e9adar ``shape`` . (cruth l\u00edneach)\"\"\"\n    SHAPE_CURVE: ClassVar[int]\n    \"\"\"Rogha idirshu\u00edomh cuar a \u00fas\u00e1idtear don pharaim\u00e9adar ``shape`` . (cruth cuar)\"\"\"\n    SHAPE_LOG: ClassVar[int]\n    \"\"\"Rogha idirshu\u00edomh logartamach a \u00fas\u00e1idtear don pharaim\u00e9adar ``shape`` . (log cruth)\"\"\"\n    FX_NONE: ClassVar[int]\n    \"\"\"N\u00edl aon rogha \u00e9ifeachta in \u00fas\u00e1id don pharaim\u00e9adar ``fx`` . (fx aon cheann)\"\"\"\n    FX_TREMOLO: ClassVar[int]\n    \"\"\"Rogha \u00e9ifeachta Tremolo a \u00fas\u00e1idtear don pharaim\u00e9adar ``fx`` . (tremolo fx)\"\"\"\n    FX_VIBRATO: ClassVar[int]\n    \"\"\"Rogha \u00e9ifeachta Vibrato a \u00fas\u00e1idtear don pharaim\u00e9adar ``fx`` .\"\"\"\n    FX_WARBLE: ClassVar[int]\n    \"\"\"Rogha \u00e9ifeacht warble a \u00fas\u00e1idtear le haghaidh an paraim\u00e9adar ``fx`` .\"\"\"\n    freq_start: int\n    \"\"\"Tosaigh minic\u00edocht i Hertz (Hz), uimhir idir ``0`` agus ``9999`` (t\u00fas minic\u00edochta)\"\"\"\n    freq_end: int\n    \"\"\"Minic\u00edocht deiridh i Heirts (Hz), uimhir idir ``0`` agus ``9999`` (deireadh freq)\"\"\"\n    duration: int\n    \"\"\"Fad na fuaime i milleasoicind\u00ed, uimhir idir ``0`` agus ``9999`` (fad)\"\"\"\n    vol_start: int\n    \"\"\"Tosaigh luach toirte, uimhir idir ``0`` agus ``255`` (t\u00fas vol)\"\"\"\n    vol_end: int\n    \"\"\"Luach toirte deiridh, uimhir idir ``0`` agus ``255`` (deireadh imleabhair)\"\"\"\n    waveform: int\n    \"\"\"Cine\u00e1l cruth waveform, ceann de na luachanna seo: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (torann a ghintear go randamach) (tonnchruth)\"\"\"\n    fx: int\n    \"\"\"\u00c9ifeacht le cur leis an bhfuaim, ceann amh\u00e1in de na luachanna seo a leanas: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``, n\u00f3 ``FX_NONE``\"\"\"\n    shape: int\n    \"\"\"An cine\u00e1l cuar idirshu\u00edomh idir na minic\u00edochta\u00ed tosaigh agus deiridh, t\u00e1 cruthanna tonn \u00e9ags\u00fala r\u00e1ta\u00ed \u00e9ags\u00fala athraithe i minic\u00edocht. Ceann de na luachanna seo a leanas: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG`` (cruth)\"\"\"\n\n    def __init__(self, freq_start: int=500, freq_end: int=2500, duration: int=500, vol_start: int=255, vol_end: int=0, waveform: int=WAVEFORM_SQUARE, fx: int=FX_NONE, shape: int=SHAPE_LOG):\n        \"\"\"Cruthaigh \u00e9ifeacht fuaime nua.\n\nExample: ``my_effect = SoundEffect(duration=1000)``\n\nAll the parameters are optional, with default values as shown above, and\nthey can all be modified via attributes of the same name. For example, we\ncan first create an effect ``my_effect = SoundEffect(duration=1000)``,\nand then change its attributes ``my_effect.duration = 500``.\n\n:param freq_start: (t\u00fas minic\u00edochta) Tosaigh minic\u00edocht i Hertz (Hz), uimhir idir ``0`` agus ``9999``.\n:param freq_end: (deireadh minic\u00edochta) Minic\u00edocht deiridh i Hertz (Hz), uimhir idir ``0`` agus ``9999``.\n:param duration: (fad) Fad na fuaime i milleasoicind\u00ed, uimhir idir ``0`` agus ``9999``.\n:param vol_start: (t\u00fas toirte) Tosaigh luach toirte, uimhir idir ``0`` agus ``255``.\n:param vol_end: (deireadh an toirte) Luach deiridh an toirte, uimhir idir ``0`` agus ``255``.\n:param waveform: (tonnfhoirm) Cine\u00e1l cruth waveform, ceann de na luachanna seo: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (torann a ghintear go randamach).\n:param fx: \u00c9ifeacht le cur leis an bhfuaim, ceann amh\u00e1in de na luachanna seo a leanas: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE``, n\u00f3 ``FX_NONE``.\n:param shape: (cruth) An cine\u00e1l cuar idirshu\u00edomh idir na minic\u00edochta\u00ed tosaigh agus deiridh, t\u00e1 cruthanna tonn \u00e9ags\u00fala r\u00e1ta\u00ed \u00e9ags\u00fala athraithe i minic\u00edocht. Ceann de na luachanna seo a leanas: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``.\"\"\"\n\n    def copy(self) -> SoundEffect:\n        \"\"\"Cruthaigh c\u00f3ip den ``SoundEffect``seo. (c\u00f3ip)\n\nExample: ``sound_2 = sound_1.copy()``\n\n:return: A copy of the SoundEffect.\"\"\"\n\nclass AudioFrame:\n    \"\"\"Is \u00e9ard is r\u00e9ad ``AudioFrame`` ann n\u00e1 liosta de 32 sampla ar beart gan s\u00edni\u00fa gach ceann acu\n(sl\u00e1nuimhir idir 0 agus 255). (fr\u00e1ma fuaime)\n\nIt takes just over 4 ms to play a single frame.\n\nExample::\n\n    frame = AudioFrame()\n    for i in range(len(frame)):\n        frame[i] = 252 - i * 8\"\"\"\n\n    def copyfrom(self, other: AudioFrame) -> None:\n        \"\"\"Forscr\u00edobh na sonra\u00ed sa ``AudioFrame`` seo leis na sonra\u00ed \u00f3 shampla ``AudioFrame`` eile. (c\u00f3ipe\u00e1il \u00f3)\n\nExample: ``my_frame.copyfrom(source_frame)``\n\n:param other: (eile) ``AudioFrame`` \u00e1sc as ar f\u00e9idir na sonra\u00ed a ch\u00f3ipe\u00e1il.\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __setitem__(self, key: int, value: int) -> None:\n        ...\n\n    def __getitem__(self, key: int) -> int:\n        ...",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"Bain \u00fas\u00e1id as an comp\u00e1s t\u00f3gtha. (comp\u00e1s)\"\"\"\n\ndef calibrate() -> None:\n    \"\"\"Tosa\u00edonn seo an pr\u00f3iseas calabr\u00fach\u00e1in. (calabr\u00fa)\n\nExample: ``compass.calibrate()``\n\nAn instructive message will be scrolled to the user after which they will need\nto rotate the device in order to draw a circle on the LED display.\"\"\"\n    ...\n\ndef is_calibrated() -> bool:\n    \"\"\"Seice\u00e1il go bhfuil an comp\u00e1s calabraithe. (at\u00e1 calabraithe)\n\nExample: ``compass.is_calibrated()``\n\n:return: ``True`` if the compass has been successfully calibrated, ``False`` otherwise.\"\"\"\n    ...\n\ndef clear_calibration() -> None:\n    \"\"\"Cealaigh an calabr\u00fa, rud a fh\u00e1gann go bhfuil an comp\u00e1s neamhr\u00e1ite ar\u00eds. (calabr\u00fa soil\u00e9ir)\n\nExample: ``compass.clear_calibration()``\"\"\"\n    ...\n\ndef get_x() -> int:\n    \"\"\"Faigh neart an r\u00e9imse mhaighn\u00e9adaigh ar an ais ``x`` . (faigh x)\n\nExample: ``compass.get_x()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Faigh neart an r\u00e9imse mhaighn\u00e9adaigh ar an ais ``y`` . (faigh y)\n\nExample: ``compass.get_y()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Faigh neart an r\u00e9imse mhaighn\u00e9adaigh ar an ais ``z`` . (faigh z)\n\nExample: ``compass.get_z()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef heading() -> int:\n    \"\"\"Faigh ceannteideal an chomp\u00e1is. (ceannteideal)\n\nExample: ``compass.heading()``\n\n:return: An integer in the range from 0 to 360, representing the angle in degrees, clockwise, with north as 0.\"\"\"\n    ...\n\ndef get_field_strength() -> int:\n    \"\"\"Faigh m\u00e9id an r\u00e9imse maighn\u00e9adach timpeall an ghl\u00e9is.\n\nExample: ``compass.get_field_strength()``\n\n:return: An integer indication of the magnitude of the magnetic field in nano tesla.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"Taispe\u00e1in t\u00e9acs, \u00edomh\u00e1nna agus beochan ar an taispe\u00e1int LED 5\u00d75. (taispe\u00e1int)\"\"\"\nfrom ..microbit import Image\nfrom typing import Union, overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"Faigh gile an LED ag col\u00fan ``x`` agus as a ch\u00e9ile ``y``. (faigh picteil\u00edn)\n\nExample: ``display.get_pixel(0, 0)``\n\n:param x: An col\u00fan taispe\u00e1na (0..4)\n:param y: An tsraith taispe\u00e1na (0..4)\n:return: A number between 0 (off) and 9 (bright)\"\"\"\n    ...\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"Socraigh gile an LED ag col\u00fan ``x`` agus as a ch\u00e9ile ``y``. (socraigh picteil\u00edn)\n\nExample: ``display.set_pixel(0, 0, 9)``\n\n:param x: An col\u00fan taispe\u00e1na (0..4)\n:param y: An tsraith taispe\u00e1na (0..4)\n:param value: (luach) An ghile idir 0 (as) agus 9 (geal)\"\"\"\n    ...\n\ndef clear() -> None:\n    \"\"\"Socraigh gile na soilse go l\u00e9ir go 0 (as). (soil\u00e9ir)\n\nExample: ``display.clear()``\"\"\"\n    ...\n\ndef show(image: Union[str, float, int, Image, Iterable[Image]], delay: int=400, wait: bool=True, loop: bool=False, clear: bool=False) -> None:\n    \"\"\"Taispe\u00e1in \u00edomh\u00e1nna, litreacha n\u00f3 digit\u00ed ar an taispe\u00e1int LED. (taispe\u00e1in)\n\nExample: ``display.show(Image.HEART)``\n\nWhen ``image`` is an image or a list of images then each image is displayed in turn.\nIf ``image`` is a string or number, each letter or digit is displayed in turn.\n\n:param image: (\u00edomh\u00e1) Teaghr\u00e1n, uimhir, \u00edomh\u00e1 n\u00f3 liosta \u00edomh\u00e1nna le taispe\u00e1int.\n:param delay: (moill) Taispe\u00e1ntar gach litir, digit n\u00f3 \u00edomh\u00e1 le milleasoicind\u00ed ``delay`` eatarthu.\n:param wait: (fan) M\u00e1s ``wait`` \u00e9 ``True``, cuirfear bac ar an bhfeidhm seo go dt\u00ed go mbeidh an bheochan cr\u00edochnaithe, n\u00f3 tarl\u00f3idh an bheochan sa ch\u00falra.\n:param loop: (l\u00fab) M\u00e1 t\u00e1 ``loop`` ``True``, d\u00e9anfaidh an beochan ar\u00eds go deo.\n:param clear: (soil\u00e9ir) M\u00e1s ionann ``clear`` agus ``True``, glanfar an taispe\u00e1int tar \u00e9is don seicheamh a bheith cr\u00edochnaithe.\n\nThe ``wait``, ``loop`` and ``clear`` arguments must be specified using their keyword.\"\"\"\n    ...\n\ndef scroll(text: Union[str, float, int], delay: int=150, wait: bool=True, loop: bool=False, monospace: bool=False) -> None:\n    \"\"\"Scrollaigh uimhir n\u00f3 t\u00e9acs ar an taispe\u00e1int LED. (scrollaigh)\n\nExample: ``display.scroll('micro:bit')``\n\n:param text: (t\u00e9acs) An teaghr\u00e1n le scroll\u00fa. M\u00e1s sl\u00e1nuimhir n\u00f3 sn\u00e1mhphointe \u00e9 ``text`` tionta\u00edtear \u00e9 ar dt\u00fas go teaghr\u00e1n ag baint \u00fas\u00e1ide as ``str()``.\n:param delay: (moill) Riala\u00edonn an paraim\u00e9adar ``delay`` c\u00e9 chomh tapa is at\u00e1 an t\u00e9acs ag scroll\u00fa.\n:param wait: (fan) M\u00e1 t\u00e1 ``wait`` ``True``, bloc\u00e1lfaidh an fheidhm seo go dt\u00ed go mbeidh an beochan cr\u00edochnaithe, n\u00f3 tarl\u00f3idh an beochan sa ch\u00falra.\n:param loop: (l\u00fab) M\u00e1 t\u00e1 ``loop`` ``True``, d\u00e9anfaidh an beochan ar\u00eds go deo.\n:param monospace: (monasp\u00e1s) M\u00e1s ``monospace`` \u00e9 ``True``, t\u00f3gfaidh na carachtair go l\u00e9ir suas le 5 chol\u00fan picteil\u00edn ar leithead, n\u00f3 mura mbeidh go d\u00edreach 1 chol\u00fan b\u00e1n picteil\u00edn idir gach carachtar agus iad ag scroll\u00fa.\n\nThe ``wait``, ``loop`` and ``monospace`` arguments must be specified\nusing their keyword.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Cas ar an taispe\u00e1int LED. (ar)\n\nExample: ``display.on()``\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"M\u00fach an taispe\u00e1int LED (ceada\u00edonn an taispe\u00e1int a dh\u00edchumas\u00fa duit na bior\u00e1in GPIO a ath\u00fas\u00e1id chun cr\u00edocha eile). (as)\n\nExample: ``display.off()``\"\"\"\n    ...\n\ndef is_on() -> bool:\n    \"\"\"Seice\u00e1il an bhfuil an taispe\u00e1int LED cumasaithe. (at\u00e1 ar)\n\nExample: ``display.is_on()``\n\n:return: ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n    ...\n\ndef read_light_level() -> int:\n    \"\"\"L\u00e9igh leibh\u00e9al an tsolais. (l\u00e9igh leibh\u00e9al an tsolais)\n\nExample: ``display.read_light_level()``\n\nUses the display's LEDs in reverse-bias mode to sense the amount of light\nfalling on the display.\n\n:return: An integer between 0 and 255 representing the light level, with larger meaning more light.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"Cumars\u00e1id a dh\u00e9anamh le gl\u00e9asanna ag baint \u00fas\u00e1ide as pr\u00f3tacal bus I\u00b2C.\"\"\"\nfrom _typeshed import ReadableBuffer\nfrom ..microbit import MicroBitDigitalPin, pin19, pin20\nfrom typing import List\n\ndef init(freq: int=100000, sda: MicroBitDigitalPin=pin20, scl: MicroBitDigitalPin=pin19) -> None:\n    \"\"\"Ath-th\u00fasaigh forimeallach.\n\nExample: ``i2c.init()``\n\n:param freq: minic\u00edocht cloig\n:param sda: bior\u00e1n ``sda`` (r\u00e9amhshocr\u00fa 20)\n:param scl: bior\u00e1n ``scl`` (r\u00e9amhshocr\u00fa 19)\n\nOn a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\nthe accelerometer and compass stop working, as they are connected\ninternally to those pins. This warning does not apply to the **V2**\nrevision of the micro:bit as this has `separate I\u00b2C lines <https://tech.microbit.org/hardware/i2c/>`_\nfor the motion sensors and the edge connector.\"\"\"\n    ...\n\ndef scan() -> List[int]:\n    \"\"\"Scan an bus le haghaidh gl\u00e9asanna. (scanadh)\n\nExample: ``i2c.scan()``\n\n:return: A list of 7-bit addresses corresponding to those devices that responded to the scan.\"\"\"\n    ...\n\ndef read(addr: int, n: int, repeat: bool=False) -> bytes:\n    \"\"\"L\u00e9igh bearta \u00f3 ghl\u00e9as. (l\u00e9igh)\n\nExample: ``i2c.read(0x50, 64)``\n\n:param addr: Seoladh 7 ngiot\u00e1n an ghl\u00e9is\n:param n: L\u00edon na mbeart at\u00e1 le l\u00e9amh\n:param repeat: (athdh\u00e9anamh) M\u00e1 ``True``, n\u00ed sheolfar aon ghiot\u00e1n stad\n:return: The bytes read\"\"\"\n    ...\n\ndef write(addr: int, buf: ReadableBuffer, repeat: bool=False) -> None:\n    \"\"\"Scr\u00edobh bearta chuig gl\u00e9as. (scr\u00edobh)\n\nExample: ``i2c.write(0x50, bytes([1, 2, 3]))``\n\n:param addr: Seoladh 7 ngiot\u00e1n an ghl\u00e9is\n:param buf: Maol\u00e1n ina bhfuil na bearta le scr\u00edobh\n:param repeat: (athdh\u00e9anamh) M\u00e1 ``True``, n\u00ed sheolfar aon ghiot\u00e1n stad\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/microphone.pyi": "\"\"\"Freagair fuaim ag baint \u00fas\u00e1ide as an micreaf\u00f3n t\u00f3gtha (V2 amh\u00e1in). (micreaf\u00f3n)\"\"\"\nfrom typing import Optional, Tuple\nfrom ..microbit import SoundEvent\n\ndef current_event() -> Optional[SoundEvent]:\n    \"\"\"Faigh an teagmhas fuaime taifeadta is d\u00e9ana\u00ed (imeacht reatha)\n\nExample: ``microphone.current_event()``\n\n:return: The event, ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.\"\"\"\n    ...\n\ndef was_event(event: SoundEvent) -> bool:\n    \"\"\"Seice\u00e1il ar chualathas fuaim uair amh\u00e1in ar a laghad \u00f3n nglao deireanach. (ba imeacht \u00e9)\n\nExample: ``microphone.was_event(SoundEvent.LOUD)``\n\nThis call clears the sound history before returning.\n\n:param event: (imeacht) An \u00f3c\u00e1id le seice\u00e1il, mar shampla ``SoundEvent.LOUD`` n\u00f3 ``SoundEvent.QUIET``\n:return: ``True`` if sound was heard at least once since the last call, otherwise ``False``.\"\"\"\n    ...\n\ndef is_event(event: SoundEvent) -> bool:\n    \"\"\"Seice\u00e1il an teagmhas fuaime is d\u00e9ana\u00ed a braitheadh. (imeacht)\n\nExample: ``microphone.is_event(SoundEvent.LOUD)``\n\nThis call does not clear the sound event history.\n\n:param event: (imeacht) An \u00f3c\u00e1id le seice\u00e1il, mar shampla ``SoundEvent.LOUD`` n\u00f3 ``SoundEvent.QUIET``\n:return: ``True`` if sound was the most recent heard, ``False`` otherwise.\"\"\"\n    ...\n\ndef get_events() -> Tuple[SoundEvent, ...]:\n    \"\"\"Faigh stair na h\u00f3c\u00e1ide fuaime mar thuple. (faigh imeachta\u00ed)\n\nExample: ``microphone.get_events()``\n\nThis call clears the sound history before returning.\n\n:return: A tuple of the event history with the most recent event last.\"\"\"\n    ...\n\ndef set_threshold(event: SoundEvent, value: int) -> None:\n    \"\"\"Socraigh an tairseach le haghaidh teagmhas fuaime. (tairseach shocraithe)\n\nExample: ``microphone.set_threshold(SoundEvent.LOUD, 250)``\n\nA high threshold means the event will only trigger if the sound is very loud (>= 250 in the example).\n\n:param event: (imeacht) Imeacht fuaime, mar shampla ``SoundEvent.LOUD`` n\u00f3 ``SoundEvent.QUIET``.\n:param value: (luach) An leibh\u00e9al tairs\u00ed sa raon 0-255.\"\"\"\n    ...\n\ndef sound_level() -> int:\n    \"\"\"Faigh an leibh\u00e9al br\u00fa fuaime. (leibh\u00e9al fuaime)\n\nExample: ``microphone.sound_level()``\n\n:return: A representation of the sound pressure level in the range 0 to 255.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/speaker.pyi": "\"\"\"Rial\u00fa an cainteoir t\u00f3gtha i (V2 amh\u00e1in). (cainteoir)\"\"\"\n\ndef off() -> None:\n    \"\"\"M\u00fach an cainteoir. (as)\n\nExample: ``speaker.off()``\n\nThis does not disable sound output to an edge connector pin.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"Cas an cainteoir air. (ar)\n\nExample: ``speaker.on()``\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"Cumars\u00e1id a dh\u00e9anamh le gl\u00e9asanna ag baint \u00fas\u00e1ide as an gcomh\u00e9adan forimeallach sraitheach (SPI) bus.\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom ..microbit import pin13, pin14, pin15, MicroBitDigitalPin\n\ndef init(baudrate: int=1000000, bits: int=8, mode: int=0, sclk: MicroBitDigitalPin=pin13, mosi: MicroBitDigitalPin=pin15, miso: MicroBitDigitalPin=pin14) -> None:\n    \"\"\"T\u00fasaigh cumars\u00e1id SPI.\n\nExample: ``spi.init()``\n\nFor correct communication, the parameters have to be the same on both communicating devices.\n\n:param baudrate: (r\u00e1ta baud) Luas na cumars\u00e1ide.\n:param bits: (giot\u00e1in) An leithead i giot\u00e1n de gach aistri\u00fa. Faoi l\u00e1thair n\u00ed thaca\u00edtear ach le ``bits=8`` . Mar sin f\u00e9in, d'fh\u00e9adfadh s\u00e9 seo athr\u00fa amach anseo.\n:param mode: (m\u00f3d) Cinneann s\u00e9 an measc\u00e1n de polara\u00edocht clog agus c\u00e9im - 'f\u00e9ach t\u00e1bla ar l\u00edne <https://microbit-micropython.readthedocs.io/en/v2-docs/spi.html#microbit.spi.init>'_.\n:param sclk: bior\u00e1in sclk (r\u00e9amhshocr\u00fa 13)\n:param mosi: bior\u00e1in mosi (r\u00e9amhshocr\u00fa 15)\n:param miso: bior\u00e1n miso (r\u00e9amhshocraithe 14)\"\"\"\n    ...\n\ndef read(nbytes: int, out: int=0) -> bytes:\n    \"\"\"L\u00e9igh ar a mh\u00e9ad ``nbytes`` agus an beart aonair a thugann ``out``\u00e1 scr\u00edobh go lean\u00fanach. (l\u00e9amh)\n\nExample: ``spi.read(64)``\n\n:param nbytes: (nbeart) L\u00edon uasta na mbeart le l\u00e9amh.\n:param out: (amach) An luach beart le scr\u00edobh (r\u00e9amhshocr\u00fa 0).\n:return: The bytes read.\"\"\"\n    ...\n\ndef write(buffer: ReadableBuffer) -> None:\n    \"\"\"Scr\u00edobh bearta chuig an mbus. (scr\u00edobh)\n\nExample: ``spi.write(bytes([1, 2, 3]))``\n\n:param buffer: (maol\u00e1n) Maol\u00e1n chun sonra\u00ed a l\u00e9amh as.\"\"\"\n    ...\n\ndef write_readinto(out: WriteableBuffer, in_: ReadableBuffer) -> None:\n    \"\"\"Scr\u00edobh an maol\u00e1n ``out`` chuig an mbus agus l\u00e9igh aon fhreagra isteach sa mhaol\u00e1n ``in_`` . (scr\u00edobh readinto)\n\nExample: ``spi.write_readinto(out_buffer, in_buffer)``\n\nThe length of the buffers should be the same. The buffers can be the same object.\n\n:param out: (amach) An maol\u00e1n chun aon fhreagra a scr\u00edobh.\n:param in_: (i) An maol\u00e1n chun sonra\u00ed a l\u00e9amh as.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"Cumars\u00e1id a dh\u00e9anamh le gl\u00e9as ag baint \u00fas\u00e1ide as comh\u00e9adan sraitheach.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom ..microbit import MicroBitDigitalPin\nfrom typing import Optional, Union\nODD: int\n\"\"\"Paireacht chorr (corr)\"\"\"\nEVEN: int\n\"\"\"Paireacht fi\u00fa (fi\u00fa amh\u00e1in)\"\"\"\n\ndef init(baudrate: int=9600, bits: int=8, parity: Optional[int]=None, stop: int=1, tx: Optional[MicroBitDigitalPin]=None, rx: Optional[MicroBitDigitalPin]=None) -> None:\n    \"\"\"T\u00fasaigh cumars\u00e1id sraitheach.\n\nExample: ``uart.init(115200, tx=pin0, rx=pin1)``\n\n:param baudrate: Luas na cumars\u00e1ide.\n:param bits: M\u00e9id na mbeart at\u00e1 \u00e1 dtarchur. micro:bit: n\u00ed thaca\u00edonn giot\u00e1n ach le 8.\n:param parity: (paireacht) Conas a dh\u00e9antar paireacht a sheice\u00e1il, ``None``, ``uart.ODD`` n\u00f3 ``uart.EVEN``.\n:param stop: (stad) L\u00edon na ngiot\u00e1n stad, caithfidh s\u00e9 a bheith 1 le haghaidh micro:bit.\n:param tx: Bior\u00e1in a tharchur.\n:param rx: Bior\u00e1n glactha.\n\nInitializing the UART on external pins will cause the Python console on\nUSB to become unaccessible, as it uses the same hardware. To bring the\nconsole back you must reinitialize the UART without passing anything for\n``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\nthat calling ``uart.init(115200)`` is enough to restore the Python console.\n\nFor more details see `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/uart.html>`_.\"\"\"\n    ...\n\ndef any() -> bool:\n    \"\"\"Seice\u00e1il an bhfuil aon sonra\u00ed ag fanacht. (aon)\n\nExample: ``uart.any()``\n\n:return: ``True`` if any data is waiting, else ``False``.\"\"\"\n    ...\n\ndef read(nbytes: Optional[int]=None) -> Optional[bytes]:\n    \"\"\"L\u00e9igh bearta. (l\u00e9amh)\n\nExample: ``uart.read()``\n\n:param nbytes: M\u00e1 t\u00e1 ``nbytes`` sonraithe ansin l\u00e9igh ar a mh\u00e9ad go leor beart, n\u00f3 l\u00e9igh an oiread beart agus is f\u00e9idir\n:return: A bytes object or ``None`` on timeout\"\"\"\n    ...\n\ndef readinto(buf: WriteableBuffer, nbytes: Optional[int]=None) -> Optional[int]:\n    \"\"\"L\u00e9igh bearta isteach sa ``buf``.\n\nExample: ``uart.readinto(input_buffer)``\n\n:param buf: An maol\u00e1n le scr\u00edobh chuige.\n:param nbytes: M\u00e1 t\u00e1 ``nbytes`` sonraithe ansin l\u00e9igh ar a mh\u00e9ad go leor bearta, ar shl\u00ed eile a l\u00e9amh ``len(buf)`` bearta.\n:return: number of bytes read and stored into ``buf`` or ``None`` on timeout.\"\"\"\n    ...\n\ndef readline() -> Optional[bytes]:\n    \"\"\"L\u00e9igh l\u00edne, ag cr\u00edochn\u00fa i gcarachtar l\u00edne nua.\n\nExample: ``uart.readline()``\n\n:return: The line read or ``None`` on timeout. The newline character is included in the returned bytes.\"\"\"\n    ...\n\ndef write(buf: Union[bytes, str]) -> Optional[int]:\n    \"\"\"Scr\u00edobh maol\u00e1n ar an mbus. (scr\u00edobh)\n\nExample: ``uart.write('hello world')``\n\n:param buf: R\u00e9ad beart n\u00f3 teaghr\u00e1n.\n:return: The number of bytes written, or ``None`` on timeout.\n\nExamples::\n\n    uart.write('hello world')\n    uart.write(b'hello world')\n    uart.write(bytes([1, 2, 3]))\"\"\"\n    ...",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Optional,\n    Reversible,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n)\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}