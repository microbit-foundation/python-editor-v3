{
  "files": {
    "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 2.7-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 2.7 are ignored, so any module that was already\n# present in 2.7 will have \"2.7\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 (currently 3.5 and lower) are\n# generally accurate but we do not guarantee their correctness.\n\nantigravity: 3.0-\narray: 3.0-\naudio: 3.0-\nbuiltins: 3.0-\nerrno: 3.0-\ngc: 3.0-\nlove: 3.0-\nmachine: 3.0-\nmath: 3.0-\nmicrobit: 3.0-\nmicropython: 3.0-\nmusic: 3.0-\nneopixel: 3.0-\nos: 3.0-\nradio: 3.0-\nrandom: 3.0-\nspeech: 3.0-\nstruct: 3.0-\nsys: 3.0-\nthis: 3.0-\ntime: 3.0-\ntyping_extensions: 3.0-\ntyping: 3.0-\nuarray: 3.0-\nucollections: 3.0-\nuerrno: 3.0-\nuos: 3.0-\nurandom: 3.0-\nustruct: 3.0-\nusys: 3.0-\nutime: 3.0-",
    "/typeshed/stdlib/abc.pyi": "from _typeshed import SupportsWrite\nfrom typing import Any, Callable, Tuple, Type, TypeVar\n\n_T = TypeVar(\"_T\")\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], namespace: dict[str, Any]\n    ) -> None: ...\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> Any: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: Any) -> Any: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = ...) -> None: ...\n    def register(cls: ABCMeta, subclass: Type[_T]) -> Type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n\nclass abstractproperty(property): ...\n\n# These two are deprecated and not supported by mypy\ndef abstractstaticmethod(callable: _FuncT) -> _FuncT: ...\ndef abstractclassmethod(callable: _FuncT) -> _FuncT: ...\n\nclass ABC(metaclass=ABCMeta): ...\n\ndef get_cache_token() -> object: ...\n",
    "/typeshed/stdlib/antigravity.pyi": "",
    "/typeshed/stdlib/array.pyi": "from typing import Generic, Iterable, MutableSequence, TypeVar, Union, overload\nfrom typing_extensions import Literal\n\n_IntTypeCode = Literal[\"b\", \"B\", \"h\", \"H\", \"i\", \"I\", \"l\", \"L\", \"q\", \"Q\"]\n_FloatTypeCode = Literal[\"f\", \"d\"]\n_TypeCode = Union[_IntTypeCode, _FloatTypeCode]\n\n_T = TypeVar(\"_T\", int, float)\n\nclass array(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(\n        self: array[int],\n        typecode: _IntTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: array[float],\n        typecode: _FloatTypeCode,\n        __initializer: Union[bytes, Iterable[_T]] = ...,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self, typecode: str, __initializer: Union[bytes, Iterable[_T]] = ...\n    ) -> None: ...\n    def append(self, __v: _T) -> None: ...\n    def decode(self) -> str: ...\n    def extend(self, __bb: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> array[_T]: ...\n    @overload  # type: ignore  # Overrides MutableSequence\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: array[_T]) -> None: ...\n    def __add__(self, x: array[_T]) -> array[_T]: ...\n    def __iadd__(self, x: array[_T]) -> array[_T]: ...  # type: ignore  # Overrides MutableSequence\n\nArrayType = array\n",
    "/typeshed/stdlib/audio.pyi": "\"\"\"Play sounds using the micro:bit (import ``audio`` for V1 compatibility).\n\"\"\"\n\n# Re-export for V1 compatibility.\nfrom .microbit.audio import (\n    is_playing as is_playing,\n    play as play,\n    stop as stop,\n    AudioFrame as AudioFrame,\n    SoundEffect as SoundEffect,\n)\n",
    "/typeshed/stdlib/builtins.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenTextMode,\n    ReadableBuffer,\n    Self,\n    StrOrBytesPath,\n    SupportsDivMod,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsLessThan,\n    SupportsLessThanT,\n    SupportsRDivMod,\n    SupportsWrite,\n)\nfrom types import CodeType, TracebackType\nfrom typing import (\n    IO,\n    AbstractSet,\n    Any,\n    AsyncIterable,\n    AsyncIterator,\n    BinaryIO,\n    ByteString,\n    Callable,\n    FrozenSet,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    MutableSet,\n    NoReturn,\n    Protocol,\n    Reversible,\n    Sequence,\n    Set,\n    Sized,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsInt,\n    SupportsRound,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, SupportsIndex, final\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\nclass _SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_TT = TypeVar(\"_TT\", bound=\"type\")\n_TBE = TypeVar(\"_TBE\", bound=\"BaseException\")\n\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __slots__: str | Iterable[str]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self: _T) -> Type[_T]: ...\n    # Ignore errors about type mismatch between property getter and setter\n    @__class__.setter\n    def __class__(self, __type: Type[object]) -> None: ...  # type: ignore # noqa: F811\n    def __init__(self) -> None: ...\n    def __new__(cls: Type[_T]) -> _T: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __eq__(self, o: object) -> bool: ...\n    def __ne__(self, o: object) -> bool: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __delattr__(self, name: str) -> None: ...\n    def __sizeof__(self) -> int: ...\n    def __reduce__(self) -> str | Tuple[Any, ...]: ...\n    if sys.version_info >= (3, 8):\n        def __reduce_ex__(self, protocol: SupportsIndex) -> str | Tuple[Any, ...]: ...\n    else:\n        def __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n\nclass staticmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass classmethod(object):  # Special, only valid as a decorator.\n    __func__: Callable[..., Any]\n    __isabstractmethod__: bool\n    def __init__(self, f: Callable[..., Any]) -> None: ...\n    def __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n    def __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n\nclass type(object):\n    __base__: type\n    __bases__: Tuple[type, ...]\n    __basicsize__: int\n    __dict__: dict[str, Any]\n    __dictoffset__: int\n    __flags__: int\n    __itemsize__: int\n    __module__: str\n    __name__: str\n    __qualname__: str\n    __text_signature__: str | None\n    __weakrefoffset__: int\n    @overload\n    def __init__(self, o: object) -> None: ...\n    @overload\n    def __init__(\n        self, name: str, bases: Tuple[type, ...], dict: dict[str, Any], **kwds: Any\n    ) -> None: ...\n    @overload\n    def __new__(cls, o: object) -> type: ...\n    @overload\n    def __new__(\n        cls: Type[_TT],\n        name: str,\n        bases: Tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwds: Any,\n    ) -> _TT: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _TT) -> list[_TT]: ...\n    def __instancecheck__(self, instance: Any) -> bool: ...\n    def __subclasscheck__(self, subclass: type) -> bool: ...\n    @classmethod\n    def __prepare__(\n        metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any\n    ) -> Mapping[str, Any]: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, t: Any) -> types.UnionType: ...\n        def __ror__(self, t: Any) -> types.UnionType: ...\n\nclass super(object):\n    @overload\n    def __init__(self, t: Any, obj: Any) -> None: ...\n    @overload\n    def __init__(self, t: Any) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\nclass int:\n    @overload\n    def __new__(\n        cls: Type[_T],\n        x: str | bytes | SupportsInt | SupportsIndex | _SupportsTrunc = ...,\n    ) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], x: str | bytes | bytearray, base: SupportsIndex\n    ) -> _T: ...\n    def to_bytes(\n        self,\n        length: SupportsIndex,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> bytes: ...\n    @classmethod\n    def from_bytes(\n        cls,\n        bytes: Iterable[SupportsIndex] | SupportsBytes,\n        byteorder: Literal[\"little\", \"big\"],\n        *,\n        signed: bool = ...,\n    ) -> int: ...  # TODO buffer object argument\n    def __add__(self, x: int) -> int: ...\n    def __sub__(self, x: int) -> int: ...\n    def __mul__(self, x: int) -> int: ...\n    def __floordiv__(self, x: int) -> int: ...\n    def __truediv__(self, x: int) -> float: ...\n    def __mod__(self, x: int) -> int: ...\n    def __divmod__(self, x: int) -> Tuple[int, int]: ...\n    def __radd__(self, x: int) -> int: ...\n    def __rsub__(self, x: int) -> int: ...\n    def __rmul__(self, x: int) -> int: ...\n    def __rfloordiv__(self, x: int) -> int: ...\n    def __rtruediv__(self, x: int) -> float: ...\n    def __rmod__(self, x: int) -> int: ...\n    def __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n    @overload\n    def __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n    @overload\n    def __pow__(\n        self, __x: int, __modulo: int | None = ...\n    ) -> Any: ...  # Return type can be int or float, depending on x.\n    def __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n    def __and__(self, n: int) -> int: ...\n    def __or__(self, n: int) -> int: ...\n    def __xor__(self, n: int) -> int: ...\n    def __lshift__(self, n: int) -> int: ...\n    def __rshift__(self, n: int) -> int: ...\n    def __rand__(self, n: int) -> int: ...\n    def __ror__(self, n: int) -> int: ...\n    def __rxor__(self, n: int) -> int: ...\n    def __rlshift__(self, n: int) -> int: ...\n    def __rrshift__(self, n: int) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    def __round__(self, ndigits: SupportsIndex = ...) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: int) -> bool: ...\n    def __le__(self, x: int) -> bool: ...\n    def __gt__(self, x: int) -> bool: ...\n    def __ge__(self, x: int) -> bool: ...\n    def __str__(self) -> str: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n\nclass float:\n    def __new__(\n        cls: Type[_T], x: SupportsFloat | SupportsIndex | str | bytes | bytearray = ...\n    ) -> _T: ...\n    def __add__(self, x: float) -> float: ...\n    def __sub__(self, x: float) -> float: ...\n    def __mul__(self, x: float) -> float: ...\n    def __floordiv__(self, x: float) -> float: ...\n    def __truediv__(self, x: float) -> float: ...\n    def __mod__(self, x: float) -> float: ...\n    def __divmod__(self, x: float) -> Tuple[float, float]: ...\n    def __pow__(\n        self, x: float, mod: None = ...\n    ) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n    def __radd__(self, x: float) -> float: ...\n    def __rsub__(self, x: float) -> float: ...\n    def __rmul__(self, x: float) -> float: ...\n    def __rfloordiv__(self, x: float) -> float: ...\n    def __rtruediv__(self, x: float) -> float: ...\n    def __rmod__(self, x: float) -> float: ...\n    def __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n    def __rpow__(self, x: float, mod: None = ...) -> float: ...\n    def __getnewargs__(self) -> Tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    if sys.version_info >= (3, 9):\n        def __ceil__(self) -> int: ...\n        def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = ...) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex) -> float: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: float) -> bool: ...\n    def __le__(self, x: float) -> bool: ...\n    def __gt__(self, x: float) -> bool: ...\n    def __ge__(self, x: float) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __str__(self) -> str: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass complex:\n    @overload\n    def __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], real: str | SupportsComplex | SupportsIndex | complex\n    ) -> _T: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def __add__(self, x: complex) -> complex: ...\n    def __sub__(self, x: complex) -> complex: ...\n    def __mul__(self, x: complex) -> complex: ...\n    def __pow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __truediv__(self, x: complex) -> complex: ...\n    def __radd__(self, x: complex) -> complex: ...\n    def __rsub__(self, x: complex) -> complex: ...\n    def __rmul__(self, x: complex) -> complex: ...\n    def __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n    def __rtruediv__(self, x: complex) -> complex: ...\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __str__(self) -> str: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls: Type[_T], o: object = ...) -> _T: ...\n    @overload\n    def __new__(\n        cls: Type[_T], o: bytes, encoding: str = ..., errors: str = ...\n    ) -> _T: ...\n    def count(\n        self,\n        x: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...\n    def endswith(\n        self,\n        __suffix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def index(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable: Iterable[str]) -> str: ...\n    def lower(self) -> str: ...\n    def lstrip(self, __chars: str | None = ...) -> str: ...\n    def replace(self, __old: str, __new: str, __count: SupportsIndex = ...) -> str: ...\n    def rfind(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: str,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def rstrip(self, __chars: str | None = ...) -> str: ...\n    def split(\n        self, sep: str | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[str]: ...\n    def startswith(\n        self,\n        __prefix: str | Tuple[str, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __chars: str | None = ...) -> str: ...\n    def upper(self) -> str: ...\n    def __add__(self, s: str) -> str: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: str) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ge__(self, x: str) -> bool: ...\n    def __getitem__(self, i: int | slice) -> str: ...\n    def __gt__(self, x: str) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __iter__(self) -> Iterator[str]: ...\n    def __le__(self, x: str) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, x: str) -> bool: ...\n    def __mod__(self, x: Any) -> str: ...\n    def __mul__(self, n: SupportsIndex) -> str: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __repr__(self) -> str: ...\n    def __rmul__(self, n: SupportsIndex) -> str: ...\n    def __str__(self) -> str: ...\n    def __getnewargs__(self) -> Tuple[str]: ...\n\nclass bytes(ByteString):\n    @overload\n    def __new__(cls: Type[_T], ints: Iterable[SupportsIndex]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], string: str, encoding: str, errors: str = ...) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], length: SupportsIndex) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T]) -> _T: ...\n    @overload\n    def __new__(cls: Type[_T], o: SupportsBytes) -> _T: ...\n    def count(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def endswith(\n        self,\n        __suffix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def find(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def index(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, __iterable_of_bytes: Iterable[ByteString | memoryview]) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def replace(\n        self, __old: bytes, __new: bytes, __count: SupportsIndex = ...\n    ) -> bytes: ...\n    def rfind(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rindex(\n        self,\n        __sub: bytes | SupportsIndex,\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> int: ...\n    def rsplit(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def rstrip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def split(\n        self, sep: bytes | None = ..., maxsplit: SupportsIndex = ...\n    ) -> list[bytes]: ...\n    def startswith(\n        self,\n        __prefix: bytes | Tuple[bytes, ...],\n        __start: SupportsIndex | None = ...,\n        __end: SupportsIndex | None = ...,\n    ) -> bool: ...\n    def strip(self, __bytes: bytes | None = ...) -> bytes: ...\n    def upper(self) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytes: ...\n    def __add__(self, s: bytes) -> bytes: ...\n    def __mul__(self, n: SupportsIndex) -> bytes: ...\n    def __rmul__(self, n: SupportsIndex) -> bytes: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n    def __getnewargs__(self) -> Tuple[bytes]: ...\n\nclass bytearray:\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex]) -> None: ...\n    @overload\n    def __init__(self, string: str, encoding: str, errors: str = ...) -> None: ...\n    @overload\n    def __init__(self, length: SupportsIndex) -> None: ...\n    def append(self, __item: SupportsIndex) -> None: ...\n    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...\n    def extend(self, __iterable_of_ints: Iterable[SupportsIndex]) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> bytearray: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, x: SupportsIndex) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, x: Iterable[SupportsIndex] | bytes) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, s: bytes) -> bytearray: ...\n    def __iadd__(self, s: Iterable[int]) -> bytearray: ...\n    def __mul__(self, n: SupportsIndex) -> bytearray: ...\n    def __rmul__(self, n: SupportsIndex) -> bytearray: ...\n    def __imul__(self, n: SupportsIndex) -> bytearray: ...\n    def __mod__(self, value: Any) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, o: SupportsIndex | bytes) -> bool: ...  # type: ignore\n    def __eq__(self, x: object) -> bool: ...\n    def __ne__(self, x: object) -> bool: ...\n    def __lt__(self, x: bytes) -> bool: ...\n    def __le__(self, x: bytes) -> bool: ...\n    def __gt__(self, x: bytes) -> bool: ...\n    def __ge__(self, x: bytes) -> bool: ...\n\nclass memoryview(Sized, Sequence[int]):\n    def __init__(self, obj: ReadableBuffer) -> None: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> memoryview: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __setitem__(self, s: slice, o: bytes) -> None: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: SupportsIndex) -> None: ...\n\n@final\nclass bool(int):\n    def __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n    @overload\n    def __and__(self, x: bool) -> bool: ...\n    @overload\n    def __and__(self, x: int) -> int: ...\n    @overload\n    def __or__(self, x: bool) -> bool: ...\n    @overload\n    def __or__(self, x: int) -> int: ...\n    @overload\n    def __xor__(self, x: bool) -> bool: ...\n    @overload\n    def __xor__(self, x: int) -> int: ...\n    @overload\n    def __rand__(self, x: bool) -> bool: ...\n    @overload\n    def __rand__(self, x: int) -> int: ...\n    @overload\n    def __ror__(self, x: bool) -> bool: ...\n    @overload\n    def __ror__(self, x: int) -> int: ...\n    @overload\n    def __rxor__(self, x: bool) -> bool: ...\n    @overload\n    def __rxor__(self, x: int) -> int: ...\n    def __getnewargs__(self) -> Tuple[int]: ...\n\nclass slice(object):\n    start: Any\n    step: Any\n    stop: Any\n    __hash__: None  # type: ignore\n    def indices(self, len: SupportsIndex) -> Tuple[int, int, int]: ...\n\nclass tuple(Sequence[_T_co], Generic[_T_co]):\n    def __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    @overload\n    def __getitem__(self, x: int) -> _T_co: ...\n    @overload\n    def __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    def __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n    @overload\n    def __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, x: Tuple[_T, ...]) -> Tuple[_T_co | _T, ...]: ...\n    def __mul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def __rmul__(self, n: SupportsIndex) -> Tuple[_T_co, ...]: ...\n    def count(self, __value: Any) -> int: ...\n    def index(\n        self, __value: Any, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n\n# Can we remove this?\nclass function:\n    # TODO not defined in builtins!\n    __name__: str\n    __module__: str\n    __code__: CodeType\n    __qualname__: str\n    __annotations__: dict[str, Any]\n\nclass frozenset(AbstractSet[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls: type[Self]) -> Self: ...\n    @overload\n    def __new__(cls: type[Self], __iterable: Iterable[_T_co]) -> Self: ...\n    def copy(self) -> FrozenSet[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n    def issubset(self, s: Iterable[object]) -> bool: ...\n    def issuperset(self, s: Iterable[object]) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass list(MutableSequence[_T], Generic[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T]) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, __object: _T) -> None: ...\n    def extend(self, __iterable: Iterable[_T]) -> None: ...\n    def pop(self, __index: SupportsIndex = ...) -> _T: ...\n    def index(\n        self, __value: _T, __start: SupportsIndex = ..., __stop: SupportsIndex = ...\n    ) -> int: ...\n    def count(self, __value: _T) -> int: ...\n    def insert(self, __index: SupportsIndex, __object: _T) -> None: ...\n    def remove(self, __value: _T) -> None: ...\n    def reverse(self) -> None: ...\n    @overload\n    def sort(\n        self: list[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n    ) -> None: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[_T], SupportsLessThan], reverse: bool = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice) -> list[_T]: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, o: _T) -> None: ...\n    @overload\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, x: list[_T]) -> list[_T]: ...\n    def __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n    def __mul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __rmul__(self, n: SupportsIndex) -> list[_T]: ...\n    def __imul__(self: _S, n: SupportsIndex) -> _S: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, x: list[_T]) -> bool: ...\n    def __ge__(self, x: list[_T]) -> bool: ...\n    def __lt__(self, x: list[_T]) -> bool: ...\n    def __le__(self, x: list[_T]) -> bool: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n    @overload\n    def __init__(self: dict[_KT, _VT]) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def __init__(\n        self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    def __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n    def clear(self) -> None: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT]: ...\n    def items(self) -> ItemsView[_KT, _VT]: ...\n    @classmethod\n    @overload\n    def fromkeys(\n        cls, __iterable: Iterable[_T], __value: None = ...\n    ) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> dict[_T, _S]: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: _KT) -> _VT: ...\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    def __delitem__(self, v: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT]: ...\n    def __str__(self) -> str: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __or__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ror__(self, __value: Mapping[_T1, _T2]) -> dict[_KT | _T1, _VT | _T2]: ...\n        def __ior__(self, __value: Mapping[_KT, _VT]) -> dict[_KT, _VT]: ...  # type: ignore\n\nclass set(MutableSet[_T], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n    def add(self, element: _T) -> None: ...\n    def clear(self) -> None: ...\n    def copy(self) -> Set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any]) -> bool: ...\n    def issubset(self, s: Iterable[Any]) -> bool: ...\n    def issuperset(self, s: Iterable[Any]) -> bool: ...\n    def pop(self) -> _T: ...\n    def remove(self, element: _T) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n    def union(self, *s: Iterable[_T]) -> Set[_T]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __str__(self) -> str: ...\n    def __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n    def __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n    def __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n    def __le__(self, s: AbstractSet[object]) -> bool: ...\n    def __lt__(self, s: AbstractSet[object]) -> bool: ...\n    def __ge__(self, s: AbstractSet[object]) -> bool: ...\n    def __gt__(self, s: AbstractSet[object]) -> bool: ...\n    __hash__: None  # type: ignore\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n    def __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n    def __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n    def __next__(self) -> Tuple[int, _T]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass range(Sequence[int]):\n    start: int\n    stop: int\n    step: int\n    @overload\n    def __init__(self, stop: SupportsIndex) -> None: ...\n    @overload\n    def __init__(\n        self, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = ...\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> int: ...\n    @overload\n    def __getitem__(self, s: slice) -> range: ...\n    def __repr__(self) -> str: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\nclass property(object):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = ...,\n        fset: Callable[[Any, Any], None] | None = ...,\n        fdel: Callable[[Any], None] | None = ...,\n        doc: str | None = ...,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None]) -> property: ...\n    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n    def __set__(self, obj: Any, value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nclass _NotImplementedType(Any):  # type: ignore\n    # A little weird, but typing the __call__ as NotImplemented makes the error message\n    # for NotImplemented() much better\n    __call__: NotImplemented  # type: ignore\n\nNotImplemented: _NotImplementedType\n\ndef abs(__x: SupportsAbs[_T]) -> _T: ...\ndef all(__iterable: Iterable[object]) -> bool: ...\ndef any(__iterable: Iterable[object]) -> bool: ...\ndef bin(__number: int | SupportsIndex) -> str: ...\n\nif sys.version_info >= (3, 7):\n    def breakpoint(*args: Any, **kws: Any) -> None: ...\n\ndef callable(__obj: object) -> bool: ...\ndef chr(__i: int) -> str: ...\n\n# We define this here instead of using os.PathLike to avoid import cycle issues.\n# See https://github.com/python/typeshed/pull/991#issuecomment-288160993\n_AnyStr_co = TypeVar(\"_AnyStr_co\", str, bytes, covariant=True)\n\nclass _PathLike(Protocol[_AnyStr_co]):\n    def __fspath__(self) -> _AnyStr_co: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(__iterable: AsyncIterable[_T]) -> AsyncIterator[_T]: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T]) -> _T: ...\n    @overload\n    async def anext(__i: AsyncIterator[_T], default: _VT) -> _T | _VT: ...\n\ndef delattr(__obj: Any, __name: str) -> None: ...\ndef dir(__o: object = ...) -> list[str]: ...\n@overload\ndef divmod(__x: SupportsDivMod[_T_contra, _T_co], __y: _T_contra) -> _T_co: ...\n@overload\ndef divmod(__x: _T_contra, __y: SupportsRDivMod[_T_contra, _T_co]) -> _T_co: ...\ndef eval(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\ndef exec(\n    __source: str | bytes | CodeType,\n    __globals: dict[str, Any] | None = ...,\n    __locals: Mapping[str, Any] | None = ...,\n) -> Any: ...\n\nclass filter(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __function: None, __iterable: Iterable[_T | None]) -> None: ...\n    @overload\n    def __init__(\n        self, __function: Callable[[_T], Any], __iterable: Iterable[_T]\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\n@overload\ndef getattr(__o: object, name: str) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None and bool\n# help mypy out in some tricky situations involving type context (aka bidirectional inference)\n@overload\ndef getattr(__o: object, name: str, __default: None) -> Any | None: ...\n@overload\ndef getattr(__o: object, name: str, __default: bool) -> Any | bool: ...\n@overload\ndef getattr(__o: object, name: str, __default: _T) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(__obj: object, __name: str) -> bool: ...\ndef hash(__obj: object) -> int: ...\ndef help(*args: Any, **kwds: Any) -> None: ...\ndef hex(__number: int | SupportsIndex) -> str: ...\ndef id(__obj: object) -> int: ...\ndef input(__prompt: Any = ...) -> str: ...\n@overload\ndef iter(__iterable: Iterable[_T]) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T | None], __sentinel: None) -> Iterator[_T]: ...\n@overload\ndef iter(__function: Callable[[], _T], __sentinel: Any) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    def isinstance(\n        __obj: object,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n    def issubclass(\n        __cls: type,\n        __class_or_tuple: type\n        | types.UnionType\n        | Tuple[type | types.UnionType | Tuple[Any, ...], ...],\n    ) -> bool: ...\n\nelse:\n    def isinstance(\n        __obj: object, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n    def issubclass(\n        __cls: type, __class_or_tuple: type | Tuple[type | Tuple[Any, ...], ...]\n    ) -> bool: ...\n\ndef len(__obj: Sized) -> int: ...\ndef locals() -> dict[str, Any]: ...\n\nclass map(Iterator[_S], Generic[_S]):\n    @overload\n    def __init__(self, __func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> None: ...\n    @overload\n    def __init__(\n        self,\n        __func: Callable[..., _S],\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> None: ...\n    def __iter__(self) -> Iterator[_S]: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef max(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef max(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef max(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef max(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef min(\n    __arg1: SupportsLessThanT,\n    __arg2: SupportsLessThanT,\n    *_args: SupportsLessThanT,\n    key: None = ...,\n) -> SupportsLessThanT: ...\n@overload\ndef min(\n    __arg1: _T, __arg2: _T, *_args: _T, key: Callable[[_T], SupportsLessThan]\n) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ...\n) -> SupportsLessThanT: ...\n@overload\ndef min(__iterable: Iterable[_T], *, key: Callable[[_T], SupportsLessThan]) -> _T: ...\n@overload\ndef min(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., default: _T\n) -> SupportsLessThanT | _T: ...\n@overload\ndef min(\n    __iterable: Iterable[_T1], *, key: Callable[[_T1], SupportsLessThan], default: _T2\n) -> _T1 | _T2: ...\n@overload\ndef next(__i: Iterator[_T]) -> _T: ...\n@overload\ndef next(__i: Iterator[_T], default: _VT) -> _T | _VT: ...\ndef oct(__number: int | SupportsIndex) -> str: ...\n\n_OpenFile = Union[StrOrBytesPath, int]\n_Opener = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenTextMode = ...,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIO: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: _OpenFile,\n    mode: OpenBinaryMode,\n    buffering: int = ...,\n    encoding: None = ...,\n    errors: None = ...,\n    newline: None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: _OpenFile,\n    mode: str,\n    buffering: int = ...,\n    encoding: str | None = ...,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef ord(__c: str | bytes) -> int: ...\ndef print(\n    *values: object,\n    sep: str | None = ...,\n    end: str | None = ...,\n    file: SupportsWrite[str] | None = ...,\n    flush: bool = ...,\n) -> None: ...\n\n_E = TypeVar(\"_E\", contravariant=True)\n_M = TypeVar(\"_M\", contravariant=True)\n\nclass _SupportsPow2(Protocol[_E, _T_co]):\n    def __pow__(self, __other: _E) -> _T_co: ...\n\nclass _SupportsPow3(Protocol[_E, _M, _T_co]):\n    def __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def pow(\n        base: int, exp: int, mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(base: int, exp: int, mod: int) -> int: ...\n    @overload\n    def pow(base: float, exp: float, mod: None = ...) -> float: ...\n    @overload\n    def pow(base: _SupportsPow2[_E, _T_co], exp: _E) -> _T_co: ...\n    @overload\n    def pow(base: _SupportsPow3[_E, _M, _T_co], exp: _E, mod: _M) -> _T_co: ...\n\nelse:\n    @overload\n    def pow(\n        __base: int, __exp: int, __mod: None = ...\n    ) -> Any: ...  # returns int or float depending on whether exp is non-negative\n    @overload\n    def pow(__base: int, __exp: int, __mod: int) -> int: ...\n    @overload\n    def pow(__base: float, __exp: float, __mod: None = ...) -> float: ...\n    @overload\n    def pow(__base: _SupportsPow2[_E, _T_co], __exp: _E) -> _T_co: ...\n    @overload\n    def pow(__base: _SupportsPow3[_E, _M, _T_co], __exp: _E, __mod: _M) -> _T_co: ...\n\nclass reversed(Iterator[_T], Generic[_T]):\n    @overload\n    def __init__(self, __sequence: Reversible[_T]) -> None: ...\n    @overload\n    def __init__(self, __sequence: SupportsLenAndGetItem[_T]) -> None: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __next__(self) -> _T: ...\n\ndef repr(__obj: object) -> str: ...\n@overload\ndef round(number: SupportsRound[Any]) -> int: ...\n@overload\ndef round(number: SupportsRound[Any], ndigits: None) -> int: ...\n@overload\ndef round(number: SupportsRound[_T], ndigits: SupportsIndex) -> _T: ...\ndef setattr(__obj: object, __name: str, __value: Any) -> None: ...\n@overload\ndef sorted(\n    __iterable: Iterable[SupportsLessThanT], *, key: None = ..., reverse: bool = ...\n) -> list[SupportsLessThanT]: ...\n@overload\ndef sorted(\n    __iterable: Iterable[_T],\n    *,\n    key: Callable[[_T], SupportsLessThan],\n    reverse: bool = ...,\n) -> list[_T]: ...\n\nif sys.version_info >= (3, 8):\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], start: _S) -> _T | _S: ...\n\nelse:\n    @overload\n    def sum(__iterable: Iterable[_T]) -> _T | int: ...\n    @overload\n    def sum(__iterable: Iterable[_T], __start: _S) -> _T | _S: ...\n\nclass zip(Iterator[_T_co], Generic[_T_co]):\n    @overload\n    def __new__(cls, __iter1: Iterable[_T1]) -> zip[Tuple[_T1]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2]\n    ) -> zip[Tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(\n        cls, __iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3]\n    ) -> zip[Tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[_T1],\n        __iter2: Iterable[_T2],\n        __iter3: Iterable[_T3],\n        __iter4: Iterable[_T4],\n        __iter5: Iterable[_T5],\n    ) -> zip[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        __iter1: Iterable[Any],\n        __iter2: Iterable[Any],\n        __iter3: Iterable[Any],\n        __iter4: Iterable[Any],\n        __iter5: Iterable[Any],\n        __iter6: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -> zip[Tuple[Any, ...]]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __next__(self) -> _T_co: ...\n\ndef __import__(\n    name: str,\n    globals: Mapping[str, Any] | None = ...,\n    locals: Mapping[str, Any] | None = ...,\n    fromlist: Sequence[str] = ...,\n    level: int = ...,\n) -> Any: ...\n\n# Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n# not exposed anywhere under that name, we make it private here.\nclass ellipsis: ...\n\nEllipsis: ellipsis\n\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n\n_StandardError = Exception\n\nclass OSError(Exception):\n    errno: int\n    strerror: str\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(_StandardError): ...\nclass AssertionError(_StandardError): ...\n\nclass AttributeError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n        obj: object\n\nclass EOFError(_StandardError): ...\n\nclass ImportError(_StandardError):\n    def __init__(\n        self, *args: object, name: str | None = ..., path: str | None = ...\n    ) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n\nclass LookupError(_StandardError): ...\nclass MemoryError(_StandardError): ...\n\nclass NameError(_StandardError):\n    if sys.version_info >= (3, 10):\n        name: str\n\nclass RuntimeError(_StandardError): ...\n\nclass StopAsyncIteration(Exception):\n    value: Any\n\nclass SyntaxError(_StandardError):\n    msg: str\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    filename: str | None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\nclass TypeError(_StandardError): ...\nclass ValueError(_StandardError): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass NotImplementedError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\n",
    "/typeshed/stdlib/errno.pyi": "from typing import Mapping\n\nerrorcode: Mapping[int, str]\n\nEACCES: int\nEADDRINUSE: int\nEAGAIN: int\nEALREADY: int\nEBADF: int\nECONNABORTED: int\nECONNREFUSED: int\nECONNRESET: int\nEEXIST: int\nEHOSTUNREACH: int\nEINPROGRESS: int\nEINVAL: int\nEIO: int\nEISDIR: int\nENOBUFS: int\nENODEV: int\nENOENT: int\nENOMEM: int\nENOTCONN: int\nEOPNOTSUPP: int\nEPERM: int\nETIMEDOUT: int\n",
    "/typeshed/stdlib/gc.pyi": "\"\"\"Steruj zbieraniem \u015bmieci\"\"\"\nfrom typing import overload\n\ndef enable() -> None:\n    \"\"\"W\u0142\u0105cz automatyczne zbieranie \u015bmieci.\"\"\"\n    ...\n\ndef disable() -> None:\n    \"\"\"Wy\u0142\u0105cz automatyczne zbieranie \u015bmieci.\n\nHeap memory can still be allocated,\nand garbage collection can still be initiated manually using ``gc.collect``.\"\"\"\n\ndef collect() -> None:\n    \"\"\"Uruchom zbieranie \u015bmieci.\"\"\"\n    ...\n\ndef mem_alloc() -> int:\n    \"\"\"Znajd\u017a liczb\u0119 przydzielonych bajt\u00f3w sterty pami\u0119ci RAM.\n\n:return: The number of bytes allocated.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\ndef mem_free() -> int:\n    \"\"\"Znajd\u017a liczb\u0119 bajt\u00f3w dost\u0119pnej sterty pami\u0119ci RAM lub -1, je\u015bli ta liczba nie jest znana.\n\n:return: The number of bytes free.\n\nThis function is MicroPython extension.\"\"\"\n    ...\n\n@overload\ndef threshold() -> int:\n    \"\"\"Zapytanie o dodatkowy pr\u00f3g przydzia\u0142u GC.\n\n:return: The GC allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\"\"\"\n    ...\n\n@overload\ndef threshold(amount: int) -> None:\n    \"\"\"Ustaw pr\u00f3g dodatkowego przydzia\u0142u GC.\n\nNormally, a collection is triggered only when a new allocation\ncannot be satisfied, i.e. on an  out-of-memory (OOM) condition.\nIf this function is called, in addition to OOM, a collection\nwill be triggered each time after ``amount`` bytes have been\nallocated (in total, since the previous time such an amount of bytes\nhave been allocated). ``amount`` is usually specified as less than the\nfull heap size, with the intention to trigger a collection earlier than when the\nheap becomes exhausted, and in the hope that an early collection will prevent\nexcessive memory fragmentation. This is a heuristic measure, the effect\nof which will vary from application to application, as well as\nthe optimal value of the ``amount`` parameter.\n\nA value of -1 means a disabled allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.\n\n:param amount: Liczba bajt\u00f3w, po kt\u00f3rych powinno zosta\u0107 uruchomione zbieranie \u015bmieci.\"\"\"\n    ...",
    "/typeshed/stdlib/log.pyi": "\"\"\"Zaloguj dane do swojego micro:bita V2.\"\"\"\nfrom typing import Literal, Mapping, Optional, Union, overload\nMILLISECONDS = 1\n\"\"\"Format znacznika czasu w milisekundach.\"\"\"\nSECONDS = 10\n\"\"\"Format znacznika czasu w sekundach.\"\"\"\nMINUTES = 600\n\"\"\"Format znacznika czasu w minutach.\"\"\"\nHOURS = 36000\n\"\"\"Format znacznika czasu w godzinach.\"\"\"\nDAYS = 864000\n\"\"\"Format znacznika czasu w dniach.\"\"\"\n\ndef set_labels(*labels: str, timestamp: Optional[Literal[1, 10, 36000, 864000]]=SECONDS) -> None:\n    \"\"\"Ustaw nag\u0142\u00f3wek pliku dziennika.\n\nExample: ``log.set_labels('X', 'Y', 'Z', timestamp=log.MINUTES)``\n\nIdeally this function should be called a single time, before any data is\nlogged, to configure the data table header once.\n\nIf a log file already exists when the program starts, or if this function\nis called multiple times, it will check the labels already defined in the\nlog file. If this function call contains any new labels not already\npresent, it will generate a new header row with the additional columns.\n\nBy default the first column contains a timestamp for each row. The time\nunit can be selected via the timestamp argument.\n\n:param *labels: Dowolna liczba argument\u00f3w pozycyjnych, ka\u017cdy odpowiadaj\u0105cy wpisowi w nag\u0142\u00f3wku dziennika.\n:param timestamp: Wybierz jednostk\u0119 znacznika czasu, kt\u00f3ra b\u0119dzie automatycznie dodana jako pierwsza kolumna w ka\u017cdym wierszu. Warto\u015bci znacznika czasu mog\u0105 by\u0107 jedn\u0105 z ``log.MILLISECONDS``, ``log.SECONDS``, ``log.MINUTES``, ``log.HOURS``, ``log.DAYS`` lub ``None``, aby wy\u0142\u0105czy\u0107 znacznik czasu. Warto\u015bci\u0105 domy\u015bln\u0105 jest ``log.SECONDS``.\"\"\"\n    ...\n\n@overload\ndef add(data_dictionary: Optional[Mapping[str, Union[str, int, float]]]) -> None:\n    \"\"\"Dodaj wiersz danych do dziennika poprzez podanie s\u0142ownika nag\u0142\u00f3wk\u00f3w i warto\u015bci.\n\nExample: ``log.add({ 'temp': temperature() })``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\n\n:param data_dictionary: Dane do logowania jako s\u0142ownik z kluczem dla ka\u017cdego nag\u0142\u00f3wka.\"\"\"\n    ...\n\n@overload\ndef add(**kwargs: Union[str, int, float]) -> None:\n    \"\"\"Dodaj wiersz danych do dziennika u\u017cywaj\u0105c argument\u00f3w s\u0142\u00f3w kluczowych. (dodaj)\n\nExample: ``log.add(temp=temperature())``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\"\"\"\n    ...\n\ndef delete(full=False):\n    \"\"\"Usuwa zawarto\u015b\u0107 wpisu, w tym nag\u0142\u00f3wki.\n\nExample: ``log.delete()``\n\nTo add the log headers again the ``set_labels`` function should to be called after this function.\n\nThere are two erase modes; \u201cfull\u201d completely removes the data from the physical storage,\nand \u201cfast\u201d invalidates the data without removing it.\n\n:param full: ``True`` wybiera usuni\u0119cie \"pe\u0142ne\" i ``False`` wybiera metod\u0119 \"szybkiego\" usuni\u0119cia.\"\"\"\n    ...\n\ndef set_mirroring(serial: bool):\n    \"\"\"Skonfiguruj lustrzane odbicie logowania danych do wyj\u015bcia szeregowego.\n\nExample: ``log.set_mirroring(True)``\n\nSerial mirroring is disabled by default. When enabled, it will print to serial each row logged into the log file.\n\n:param serial: ``True`` umo\u017cliwia odbicie lustrzane danych na szeregowe wyj\u015bcie.\"\"\"\n    ...",
    "/typeshed/stdlib/love.pyi": "def badaboom() -> None: ...\n",
    "/typeshed/stdlib/machine.pyi": "\"\"\"Narz\u0119dzia niskiego poziomu.\"\"\"\nfrom typing import Any\nfrom .microbit import MicroBitDigitalPin\n\ndef unique_id() -> bytes:\n    \"\"\"Pobierz ci\u0105g bajt\u00f3w z unikatowym identyfikatorem p\u0142ytki.\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Zresetuj urz\u0105dzenie w spos\u00f3b podobny do naci\u015bni\u0119cia zewn\u0119trznego przycisku RESET.\n\nExample: ``machine.reset()``\"\"\"\n    ...\n\ndef freq() -> int:\n    \"\"\"Uzyskaj cz\u0119stotliwo\u015b\u0107 procesora w hercach\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.\"\"\"\n    ...\n\ndef disable_irq() -> Any:\n    \"\"\"Wy\u0142\u0105cz \u017c\u0105dania przerwa\u0144.\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.\"\"\"\n    ...\n\ndef enable_irq(state: Any) -> None:\n    \"\"\"Ponownie w\u0142\u0105cz \u017c\u0105dania przerwa\u0144.\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: Warto\u015b\u0107, kt\u00f3ra zosta\u0142a zwr\u00f3cona z ostatniego wywo\u0142ania funkcji ``disable_irq``.\"\"\"\n    ...\n\ndef time_pulse_us(pin: MicroBitDigitalPin, pulse_level: int, timeout_us: int=1000000) -> int:\n    \"\"\"Czas pulsowania na pinie.\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: Pin do u\u017cycia\n:param pulse_level: 0 do czasu niskiego pulsu lub 1 do czasu wysokiego pulsu\n:param timeout_us: Mikrosekundowy limit czasu\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end\"\"\"\n    ...\n\nclass mem:\n    \"\"\"Klasa dla widok\u00f3w pami\u0119ci ``mem8``, ``mem16`` i ``mem32``.\"\"\"\n\n    def __getitem__(self, address: int) -> int:\n        \"\"\"Uzyskaj dost\u0119p do warto\u015bci z pami\u0119ci.\n\n:param address: Adres pami\u0119ci.\n:return: The value at that address as an integer.\"\"\"\n        ...\n\n    def __setitem__(self, address: int, value: int) -> None:\n        \"\"\"Ustaw warto\u015b\u0107 dla podanego adresu.\n\n:param address: Adres pami\u0119ci.\n:param value: Warto\u015b\u0107 ca\u0142kowita do ustawiania.\"\"\"\n        ...\nmem8: mem\n\"\"\"8-bitowy widok pami\u0119ci.\"\"\"\nmem16: mem\n\"\"\"16-bitowy widok pami\u0119ci.\"\"\"\nmem32: mem\n\"\"\"32-bitowy widok pami\u0119ci.\"\"\"",
    "/typeshed/stdlib/math.pyi": "\"\"\"Funkcje matematyczne.\"\"\"\nfrom typing import Tuple\n\ndef acos(x: float) -> float:\n    \"\"\"Obliczy\u0107 odwrotno\u015b\u0107 cosinusa.\n\nExample: ``math.acos(1)``\n\n:param x: Liczba\n:return: The inverse cosine of ``x``\"\"\"\n    ...\n\ndef asin(x: float) -> float:\n    \"\"\"Obliczy\u0107 odwrotno\u015b\u0107 sinusa.\n\nExample: ``math.asin(0)``\n\n:param x: Liczba\n:return: The inverse sine of ``x``\"\"\"\n    ...\n\ndef atan(x: float) -> float:\n    \"\"\"Oblicz odwrotno\u015b\u0107 tangensa.\n\nExample: ``math.atan(0)``\n\n:param x: Liczba\n:return: The inverse tangent of ``x``\"\"\"\n    ...\n\ndef atan2(y: float, x: float) -> float:\n    \"\"\"Oblicz warto\u015b\u0107 g\u0142\u00f3wn\u0105 odwrotno\u015bci tangensa ``y/x``.\n\nExample: ``math.atan2(0, -1)``\n\n:param y: Liczba\n:param x: Liczba\n:return: The principal value of the inverse tangent of ``y/x``\"\"\"\n    ...\n\ndef ceil(x: float) -> float:\n    \"\"\"Zaokr\u0105glij liczb\u0119 w kierunku dodatniej niesko\u0144czono\u015bci.\n\nExample: ``math.ceil(0.1)``\n\n:param x: Liczba\n:return: ``x`` rounded towards positive infinity.\"\"\"\n    ...\n\ndef copysign(x: float, y: float) -> float:\n    \"\"\"Oblicz ``x`` ze znakiem ``y``.\n\nExample: ``math.copysign(1, -1)``\n\n:param x: Liczba\n:param y: \u0179r\u00f3d\u0142o znaku dla warto\u015bci zwracanej\n:return: ``x`` with the sign of ``y``\"\"\"\n    ...\n\ndef cos(x: float) -> float:\n    \"\"\"Oblicz cosinus ``x``.\n\nExample: ``math.cos(0)``\n\n:param x: Liczba\n:return: The cosine of ``x``\"\"\"\n    ...\n\ndef degrees(x: float) -> float:\n    \"\"\"Konwertuj radiany na stopnie.\n\nExample: ``math.degrees(2 * math.pi)``\n\n:param x: Warto\u015b\u0107 w radianach\n:return: The value converted to degrees\"\"\"\n    ...\n\ndef exp(x: float) -> float:\n    \"\"\"Oblicz pot\u0119g\u0119 ``x``.\n\nExample: ``math.exp(1)``\n\n:param x: Liczba\n:return: The exponential of ``x``.\"\"\"\n    ...\n\ndef fabs(x: float) -> float:\n    \"\"\"Zwr\u00f3\u0107 warto\u015b\u0107 bezwzgl\u0119dn\u0105 ``x``.\n\nExample: ``math.fabs(-0.1)``\n\n:param x: Liczba\n:return: The absolute value of ``x``\"\"\"\n    ...\n\ndef floor(x: float) -> int:\n    \"\"\"Zaokr\u0105glij liczb\u0119 w kierunku ujemnej niesko\u0144czono\u015bci.\n\nExample: ``math.floor(0.9)``\n\n:param x: Liczba\n:return: ``x`` rounded towards negative infinity.\"\"\"\n    ...\n\ndef fmod(x: float, y: float) -> float:\n    \"\"\"Oblicz reszt\u0119 z ``x/y``.\n\nExample: ``math.fmod(10, 3)``\n\n:param x: Licznik\n:param y: Mianownik\"\"\"\n    ...\n\ndef frexp(x: float) -> Tuple[float, int]:\n    \"\"\"Rozk\u0142ada liczb\u0119 zmiennopozycyjn\u0105 na mantys\u0119 i wyk\u0142adnik.\n\nExample: ``mantissa, exponent = math.frexp(2)``\n\nThe returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\nexactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\nthe relation ``0.5 <= abs(m) < 1`` holds.\n\n:param x: Liczba zmiennopozycyjna\n:return: A tuple of length two containing its mantissa then exponent\"\"\"\n    ...\n\ndef isfinite(x: float) -> bool:\n    \"\"\"Sprawd\u017a, czy warto\u015b\u0107 jest sko\u0144czona.\n\nExample: ``math.isfinite(float('inf'))``\n\n:param x: Liczba.\n:return: ``True`` if ``x`` is finite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isinf(x: float) -> bool:\n    \"\"\"Sprawd\u017a, czy warto\u015b\u0107 jest niesko\u0144czona.\n\nExample: ``math.isinf(float('-inf'))``\n\n:param x: Liczba.\n:return: ``True`` if ``x`` is infinite, ``False`` otherwise.\"\"\"\n    ...\n\ndef isnan(x: float) -> bool:\n    \"\"\"Sprawd\u017a, czy warto\u015b\u0107 nie jest liczb\u0105 (NaN).\n\nExample: ``math.isnan(float('nan'))``\n\n:param x: Liczba\n:return: ``True`` if ``x`` is not-a-number (NaN), ``False`` otherwise.\"\"\"\n    ...\n\ndef ldexp(x: float, exp: int) -> float:\n    \"\"\"Oblicz ``x * (2**exp)``.\n\nExample: ``math.ldexp(0.5, 2)``\n\n:param x: Liczba\n:param exp: Wyk\u0142adnik ca\u0142kowity\n:return: ``x * (2**exp)``\"\"\"\n    ...\n\ndef log(x: float, base: float=e) -> float:\n    \"\"\"Oblicz logarytm z ``x`` przy podanej podstawie (domy\u015blnie loggorytm naturalny).\n\nExample: ``math.log(math.e)``\n\nWith one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as ``log(x)/log(base)``.\n\n:param x: Liczba\n:param base: Podstawa do u\u017cycia\n:return: The natural logarithm of ``x``\"\"\"\n    ...\n\ndef modf(x: float) -> Tuple[float, float]:\n    \"\"\"Oblicz cz\u0119\u015b\u0107 u\u0142amkow\u0105 i ca\u0142kowit\u0105 z ``x``.\n\nExample: ``fractional, integral = math.modf(1.5)``\n\n:param x: Liczba\n:return: A tuple of two floats representing the fractional then integral parts of ``x``.\n\nBoth the fractional and integral values have the same sign as ``x``.\"\"\"\n    ...\n\ndef pow(x: float, y: float) -> float:\n    \"\"\"Zwraca ``x`` do pot\u0119gi ``y``.\n\nExample: ``math.pow(4, 0.5)``\n\n:param x: Liczba\n:param y: Wyk\u0142adnik\n:return: ``x`` to the power of ``y``\"\"\"\n    ...\n\ndef radians(x: float) -> float:\n    \"\"\"Konwertuj stopnie na radiany.\n\nExample: ``math.radians(360)``\n\n:param x: Warto\u015b\u0107 w stopniach\n:return: The value converted to radians\"\"\"\n    ...\n\ndef sin(x: float) -> float:\n    \"\"\"Oblicz sinus ``x``.\n\nExample: ``math.sin(math.pi/2)``\n\n:param x: Liczba\n:return: The sine of ``x``\"\"\"\n    ...\n\ndef sqrt(x: float) -> float:\n    \"\"\"Oblicz pierwiastek kwadratowy z ``x``.\n\nExample: ``math.sqrt(4)``\n\n:param x: Liczba\n:return: The square root of ``x``\"\"\"\n    ...\n\ndef tan(x: float) -> float:\n    \"\"\"Oblicz tangens z ``x``.\n\nExample: ``math.tan(0)``\n\n:param x: Liczba\n:return: The tangent of ``x``.\"\"\"\n    ...\n\ndef trunc(x: float) -> int:\n    \"\"\"Zaokr\u0105glij liczb\u0119 w kierunku 0.\n\nExample: ``math.trunc(-0.9)``\n\n:param x: Liczba\n:return: ``x`` rounded towards zero.\"\"\"\n    ...\ne: float\n\"\"\"Podstawa logarytmu naturalnego\"\"\"\npi: float\n\"\"\"Stosunek obwodu okr\u0119gu do jego \u015brednicy\"\"\"",
    "/typeshed/stdlib/micropython.pyi": "\"\"\"Wewn\u0105trz MicroPythona. (microPython)\"\"\"\nfrom typing import Any, TypeVar, overload\n_T = TypeVar('_T')\n\ndef const(expr: _T) -> _T:\n    \"\"\"S\u0142u\u017cy do zadeklarowania, \u017ce wyra\u017cenie jest sta\u0142\u0105 tak, \u017ce kompilator mo\u017ce\nje zoptymalizowa\u0107.\n\nThe use of this function should be as follows::\n\n    from micropython import const\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\nConstants declared this way are still accessible as global variables from\noutside the module they are declared in. On the other hand, if a constant\nbegins with an underscore then it is hidden, it is not available as a\nglobal variable, and does not take up any memory during execution.\n\n:param expr: Wyra\u017cenie sta\u0142e.\"\"\"\n    ...\n\n@overload\ndef opt_level() -> int:\n    \"\"\"Uzyskaj obecny poziom optymalizacji dla kompilacji skrypt\u00f3w.\n\nExample: ``micropython.opt_level()``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\n:return: An integer representing the current level.\"\"\"\n    ...\n\n@overload\ndef opt_level(level: int) -> None:\n    \"\"\"Ustawia poziom optymalizacji dla p\u00f3\u017aniejszej kompilacji skrypt\u00f3w.\n\nExample: ``micropython.opt_level(1)``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\nThe default optimisation level is usually level 0.\n\n:param level: Poziom optymalizacji ca\u0142kowity.\"\"\"\n    ...\n\ndef mem_info(verbose: Any=None) -> None:\n    \"\"\"Drukuj informacje o aktualnie u\u017cywanej pami\u0119ci.\n\nExample: ``micropython.mem_info()``\n\n:param verbose: Je\u015bli dany jest argument ``verbose``, drukowane s\u0105 dodatkowe informacje.\"\"\"\n    ...\n\ndef qstr_info(verbose: Any=None) -> None:\n    \"\"\"Drukuj informacje o aktualnie internowanych \u0142a\u0144cuchach.\n\nExample: ``micropython.qstr_info()``\n\n:param verbose: Je\u015bli dany jest argument ``verbose``, drukowane s\u0105 dodatkowe informacje.\n\nThe information that is printed is implementation dependent, but currently\nincludes the number of interned strings and the amount of RAM they use.  In\nverbose mode it prints out the names of all RAM-interned strings.\"\"\"\n    ...\n\ndef stack_use() -> int:\n    \"\"\"Zwr\u00f3\u0107 liczb\u0119 ca\u0142kowit\u0105 reprezentuj\u0105c\u0105 aktualn\u0105 wielko\u015b\u0107 u\u017cywanego stosu\n\nExample: ``micropython.stack_use()``\n\nThe absolute value of this is not particularly useful, rather it\nshould be used to compute differences in stack usage at different points.\n\n:return: An integer representing current stack use.\"\"\"\n    ...\n\ndef heap_lock() -> None:\n    \"\"\"Zablokuj stos.\n\nExample: ``micropython.heap_lock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef heap_unlock() -> None:\n    \"\"\"Odblokuj stos.\n\nExample: ``micropython.heap_unlock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.\"\"\"\n    ...\n\ndef kbd_intr(chr: int) -> None:\n    \"\"\"Ustaw znak, kt\u00f3ry zg\u0142osi wyj\u0105tek ``KeyboardInterrupt``.\n\nExample: ``micropython.kbd_intr(-1)``\n\n:param chr: Kod znaku, aby zwi\u0119kszy\u0107 przerw\u0119 lub -1, aby wy\u0142\u0105czy\u0107 przechwytywanie Ctrl-C.\n\nBy default this is set to 3 during script execution, corresponding to Ctrl-C.\nPassing -1 to this function will disable capture of Ctrl-C, and passing 3\nwill restore it.\n\nThis function can be used to prevent the capturing of Ctrl-C on the\nincoming stream of characters that is usually used for the REPL, in case\nthat stream is used for other purposes.\"\"\"\n    ...",
    "/typeshed/stdlib/music.pyi": "\"\"\"Tw\u00f3rz i graj w melodie.\"\"\"\nfrom typing import Optional, Tuple, Union, List\nfrom .microbit import MicroBitDigitalPin, pin0\nDADADADUM: Tuple[str, ...]\n\"\"\"Melodia: otwarcie 5. symfonii Beethovena w C minor\"\"\"\nENTERTAINER: Tuple[str, ...]\n\"\"\"Melodia: fragment otwieraj\u0105cy klasyczny Scott Joplin Ragtime \"The Entertainer\".\"\"\"\nPRELUDE: Tuple[str, ...]\n\"\"\"Melodia: otwarcie pierwszego Preludium w C Major, 48 preludi\u00f3w i Fug J.S.Bacha.\"\"\"\nODE: Tuple[str, ...]\n\"\"\"Melodia: motyw Ody do rado\u015bci z 9. Symfonii Beethovena w D minor.\"\"\"\nNYAN: Tuple[str, ...]\n\"\"\"Melodia: motyw Nyan Kot (http://www.nyan.cat/).\n\nThe composer is unknown. This is fair use for educational porpoises (as they say in New York).\"\"\"\nRINGTONE: Tuple[str, ...]\n\"\"\"Melodia: co\u015b, co brzmi jak dzwonek telefonu kom\u00f3rkowego.\n\nTo be used to indicate an incoming message.\n\"\"\"\nFUNK: Tuple[str, ...]\n\"\"\"Melody: funkowa linia basu dla tajnych agent\u00f3w i geniuszy kryminalnych.\"\"\"\nBLUES: Tuple[str, ...]\n\"\"\"Melodia: 12-taktowy bluesowy chodz\u0105cy bas w stylu boogie-woogie.\"\"\"\nBIRTHDAY: Tuple[str, ...]\n\"\"\"Melodia: \"Wszystkiego najlepszego\u2026\"\n\nFor copyright status see: http://www.bbc.co.uk/news/world-us-canada-34332853\n\"\"\"\nWEDDING: Tuple[str, ...]\n\"\"\"Melodia: ch\u00f3r panny m\u0142odej z opery Wagnera \u201eLohengrin\u201d. (\u015blub)\"\"\"\nFUNERAL: Tuple[str, ...]\n\"\"\"Melodia: \u00bbMarsz pogrzebowy\u00ab znany jako Sonata Fortepianowa No. 2 w B\u266d minor, Op. 35 Fryderyka Chopina. (pogrzeb)\"\"\"\nPUNCHLINE: Tuple[str, ...]\n\"\"\"Melodia: zabawny fragment oznaczaj\u0105cy, \u017ce za\u017cartowano.\"\"\"\nPYTHON: Tuple[str, ...]\n\"\"\"Melodia: Marsz John Philip Sousa \u201eLiberty Bell\u201d aka, motyw \u201eMonty Python Flating Circus\u201d (po kt\u00f3rym nazwano j\u0119zyk programowania Pythona).\"\"\"\nBADDY: Tuple[str, ...]\n\"\"\"Melodia: wej\u015bcie z\u0142ego cz\u0142owieka do ery kina niemego.\"\"\"\nCHASE: Tuple[str, ...]\n\"\"\"Melodia: scena po\u015bcigu z epoki kina niemego.\"\"\"\nBA_DING: Tuple[str, ...]\n\"\"\"Melodia: kr\u00f3tki sygna\u0142 informuj\u0105cy, \u017ce co\u015b si\u0119 wydarzy\u0142o.\"\"\"\nWAWAWAWAA: Tuple[str, ...]\n\"\"\"Melodia: bardzo smutny puzon.\"\"\"\nJUMP_UP: Tuple[str, ...]\n\"\"\"Melodia: do u\u017cytku w grze, wskazuj\u0105cy ruch w g\u00f3r\u0119.\"\"\"\nJUMP_DOWN: Tuple[str, ...]\n\"\"\"Melodia: do u\u017cytku w grze, wskazuj\u0105cy ruch w g\u00f3r\u0119.\"\"\"\nPOWER_UP: Tuple[str, ...]\n\"\"\"Melodia: fanfara oznaczaj\u0105ca odblokowanie osi\u0105gni\u0119cia.\"\"\"\nPOWER_DOWN: Tuple[str, ...]\n\"\"\"Melodia: smutna fanfara oznaczaj\u0105ca utracenie osi\u0105gni\u0119cia.\"\"\"\n\ndef set_tempo(ticks: int=4, bpm: int=120) -> None:\n    \"\"\"Ustawia przybli\u017cone tempo dla odtwarzania.\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: Liczba takt\u00f3w sk\u0142adaj\u0105cych si\u0119 na uderzenie.\n:param bpm: Liczba ca\u0142kowita okre\u015blaj\u0105ca liczb\u0119 uderze\u0144 na minut\u0119.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.\"\"\"\n    ...\n\ndef get_tempo() -> Tuple[int, int]:\n    \"\"\"Pobiera bie\u017c\u0105ce tempo jako par\u0119 liczb ca\u0142kowitych: ``(ticks, bpm)``.\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.\"\"\"\n    ...\n\ndef play(music: Union[str, List[str], Tuple[str, ...]], pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True, loop: bool=False) -> None:\n    \"\"\"Odtwarzaj muzyk\u0119.\n\nExample: ``music.play(music.NYAN)``\n\n:param music: muzyka okre\u015blona w `specjalnej notacji <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: pin wyj\u015bciowy do u\u017cycia z zewn\u0119trznym g\u0142o\u015bnikiem (domy\u015blnie ``pin0``), ``None`` dla braku d\u017awi\u0119ku.\n:param wait: Je\u015bli ``wait`` jest ustawiony na ``True``, ta funkcja jest blokowana.\n:param loop: Je\u015bli ``loop`` jest ustawiony na ``True``, melodia powtarza si\u0119, a\u017c ``stop`` jest wywo\u0142ana lub po\u0142\u0105czenie blokuj\u0105ce zostanie przerwane.\n\nMany built-in melodies are defined in this module.\"\"\"\n    ...\n\ndef pitch(frequency: int, duration: int=-1, pin: Optional[MicroBitDigitalPin]=pin0, wait: bool=True) -> None:\n    \"\"\"Zagraj nut\u0119.\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: Cz\u0119stotliwo\u015b\u0107 ca\u0142kowitoliczbowa\n:param duration: Czas trwania w milisekundach. Je\u015bli ujemny, to d\u017awi\u0119k jest ci\u0105g\u0142y a\u017c do nast\u0119pnego po\u0142\u0105czenia lub po\u0142\u0105czenia z ``stop``.\n:param pin: Opcjonalny pin wyj\u015bciowy (domy\u015blny ``pin0``).\n:param wait: Je\u015bli ``wait`` jest ustawiony na ``True``, ta funkcja jest blokowana.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.\"\"\"\n    ...\n\ndef stop(pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Zatrzymuje odtwarzanie muzyki na wbudowanym g\u0142o\u015bniku i jakimkolwiek pinie wyj\u015bciowym d\u017awi\u0119ku.\n\nExample: ``music.stop()``\n\n:param pin: Opcjonalny argument mo\u017ce by\u0107 podany do okre\u015blenia pinu, np. ``music.stop(pin1)``.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Resetuje takty, bpm, czas trwania i oktaw\u0119 do ich warto\u015bci domy\u015blnych.\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``\"\"\"\n    ...",
    "/typeshed/stdlib/neopixel.pyi": "\"\"\"Indywidualnie adresowalne paski LED RGB i RGBW.\"\"\"\nfrom .microbit import MicroBitDigitalPin\nfrom typing import Tuple\n\nclass NeoPixel:\n\n    def __init__(self, pin: MicroBitDigitalPin, n: int, bpp: int=3) -> None:\n        \"\"\"Zainicjuj nowy pasek neopikselowych diod LED sterowanych za pomoc\u0105 pinu.\n\nExample: ``np = neopixel.NeoPixel(pin0, 8)``\n\nTo support RGBW neopixels, a third argument can be passed to\n``NeoPixel`` to indicate the number of bytes per pixel (``bpp``).\nFor RGBW, this is is 4 rather than the default of 3 for RGB and GRB.\n\nEach pixel is addressed by a position (starting from 0). Neopixels are\ngiven RGB (red, green, blue) / RGBW (red, green, blue, white) values\nbetween 0-255 as a tuple. For example, in RGB, ``(255,255,255)`` is\nwhite. In RGBW, ``(255,255,255,0)`` or ``(0,0,0,255)`` is white.\n\nSee `the online docs <https://microbit-micropython.readthedocs.io/en/v2-docs/neopixel.html>`_ for warnings and other advice.\n\n:param pin: Pin kontroluj\u0105cy pasek neopikseli.\n:param n: Liczba neopikseli w pasku.\n:param bpp: Bajty na piksel. W przypadku obs\u0142ugi neopikseli RGBW nale\u017cy przekaza\u0107 4 zamiast domy\u015blnych 3 dla RGB i GRB.\"\"\"\n        ...\n\n    def clear(self) -> None:\n        \"\"\"Wyczy\u015b\u0107 wszystkie piksele.\n\nExample: ``np.clear()``\"\"\"\n        ...\n\n    def show(self) -> None:\n        \"\"\"Poka\u017c piksele.\n\nExample: ``np.show()``\n\nMust be called for any updates to become visible.\"\"\"\n        ...\n\n    def write(self) -> None:\n        \"\"\"Poka\u017c piksele (tylko micro:bit V2).\n\nExample: ``np.write()``\n\nMust be called for any updates to become visible.\n\nEquivalent to ``show``.\"\"\"\n        ...\n\n    def fill(self, colour: Tuple[int, ...]) -> None:\n        \"\"\"Pokoloruj wszystkie piksele okre\u015blon\u0105 warto\u015bci\u0105 RGB/RGBW (tylko micro:bit V2).\n\nExample: ``np.fill((0, 0, 255))``\n\n:param colour: Krotka o takiej samej d\u0142ugo\u015bci jak liczba bajt\u00f3w na piksel (bpp).\n\nUse in conjunction with ``show()`` to update the neopixels.\"\"\"\n        ...\n\n    def __setitem__(self, key: int, value: Tuple[int, ...]) -> None:\n        \"\"\"Ustaw kolor pikseli.\n\nExample: ``np[0] = (255, 0, 0)``\n\n:param key: Liczba pikseli.\n:param value: Kolor\"\"\"\n\n    def __getitem__(self, key: int) -> Tuple[int, ...]:\n        \"\"\"Uzyskaj kolor piksela.\n\nExample: ``r, g, b = np[0]``\n\n:param key: Liczba pikseli.\n:return: The colour tuple.\"\"\"\n\n    def __len__(self) -> int:\n        \"\"\"Uzyskaj d\u0142ugo\u015b\u0107 tego paska pikseli.\n\nExample: ``len(np)``\"\"\"",
    "/typeshed/stdlib/os.pyi": "\"\"\"Uzyskaj dost\u0119p do systemu plik\u00f3w.\"\"\"\nfrom typing import Tuple\nfrom typing import List\n\ndef listdir() -> List[str]:\n    \"\"\"Lista plik\u00f3w.\n\nExample: ``os.listdir()``\n\n:return: A list of the names of all the files contained within the local\npersistent on-device file system.\"\"\"\n    ...\n\ndef remove(filename: str) -> None:\n    \"\"\"Usu\u0144 (usu\u0144) plik.\n\nExample: ``os.remove('data.txt')``\n\n:param filename: Plik do usuni\u0119cia.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n    ...\n\ndef size(filename: str) -> int:\n    \"\"\"Zwraca rozmiar pliku.\n\nExample: ``os.size('data.txt')``\n\n:param filename: Plik\n:return: The size in bytes.\n\nIf the file does not exist an ``OSError`` exception will occur.\"\"\"\n\nclass uname_result(Tuple[str, str, str, str, str]):\n    \"\"\"Wynik ``os.uname()``\"\"\"\n    sysname: str\n    \"\"\"Nazwa systemu operacyjnego.\"\"\"\n    nodename: str\n    \"\"\"Nazwa maszyny w sieci (zdefiniowana w implementacji).\"\"\"\n    release: str\n    \"\"\"Wydanie systemu operacyjnego.\"\"\"\n    version: str\n    \"\"\"Wersja systemu operacyjnego\"\"\"\n    machine: str\n    \"\"\"Identyfikator sprz\u0119tu.\"\"\"\n\ndef uname() -> uname_result:\n    \"\"\"Zwraca informacje identyfikuj\u0105ce bie\u017c\u0105cy system operacyjny.\n\nExample: ``os.uname()``\n\nThe return value is an object with five attributes:\n\n- ``sysname`` - operating system name\n- ``nodename`` - name of machine on network (implementation-defined)\n- ``release`` - operating system release\n- ``version`` - operating system version\n- ``machine`` - hardware identifier\n\nThere is no underlying operating system in MicroPython. As a result the\ninformation returned by the ``uname`` function is mostly useful for\nversioning details.\"\"\"\n    ...",
    "/typeshed/stdlib/power.pyi": "\"\"\"Manage the power modes of the micro:bit (V2 only).\n\"\"\"\n\nfrom microbit import MicroBitDigitalPin, Button\nfrom typing import Optional, Tuple, Union\n\ndef off() -> None:\n    \"\"\"Power down the board to the lowest possible power mode.\n\n    Example: ``power.off()``\n\n    This is the equivalent to pressing the reset button for a few seconds,\n    to set the board in \"Off mode\".\n\n    The micro:bit will only wake up if the reset button is pressed or,\n    if on battery power, when a USB cable is connected.\n\n    When the board wakes up it will start for a reset state, so your program\n    will start running from the beginning.\n    \"\"\"\n    ...\n\ndef deep_sleep(\n    ms: Optional[int] = None,\n    wake_on: Optional[\n        Union[MicroBitDigitalPin, Button] | Tuple[MicroBitDigitalPin | Button, ...]\n    ] = None,\n    run_every: bool = True,\n) -> None:\n    \"\"\"Set the micro:bit into a low power mode where it can wake up and continue operation.\n\n    Example: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\n    The program state is preserved and when it wakes up it will resume\n    operation where it left off.\n\n    Deep Sleep mode will consume more battery power than Off mode.\n\n    The wake up sources are configured via arguments.\n\n    The board will always wake up when receiving UART data, when the reset\n    button is pressed (which resets the board) or, in battery power,\n    when the USB cable is inserted.\n\n    When the ``run_every`` parameter is set to ``True`` (the default), any\n    function scheduled with ``run_every`` will momentarily wake up the board\n    to run and when it finishes it will go back to sleep.\n\n    :param ms: A time in milliseconds to wait before it wakes up.\n    :param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n    :param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.\n    \"\"\"\n    ...\n",
    "/typeshed/stdlib/radio.pyi": "\"\"\"Komunikuj si\u0119 pomi\u0119dzy micro:bitami za pomoc\u0105 wbudowanego radia.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom typing import Optional, Tuple\nRATE_1MBIT: int\n\"\"\"Sta\u0142a u\u017cywana do wskazania przepustowo\u015bci 1 MBit na sekund\u0119.\"\"\"\nRATE_2MBIT: int\n\"\"\"Sta\u0142a u\u017cywana do wskazania przepustowo\u015bci 2 MBit na sekund\u0119.\"\"\"\n\ndef on() -> None:\n    \"\"\"W\u0142\u0105cza radio\n\nExample: ``radio.on()``\n\nThis needs to be explicitly called since the radio draws power and takes\nup memory that you may otherwise need.\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Wy\u0142\u0105cza radio, oszcz\u0119dzaj\u0105c energi\u0119 i pami\u0119\u0107.\n\nExample: ``radio.off()``\"\"\"\n    ...\n\ndef config(length: int=32, queue: int=3, channel: int=7, power: int=6, address: int=1969383796, group: int=0, data_rate: int=RATE_1MBIT) -> None:\n    \"\"\"Konfiguruje radio.\n\nExample: ``radio.config(group=42)``\n\nThe default configuration is suitable for most use.\n\n:param length: (default=32) definiuje maksymaln\u0105 d\u0142ugo\u015b\u0107 w bajtach wiadomo\u015bci wysy\u0142anej przez radio.\nMo\u017ce mie\u0107 d\u0142ugo\u015b\u0107 do 251 bajt\u00f3w (254 - 3 bajty dla S0, LENGTH i S1).\n:param queue: (default=3) okre\u015bla liczb\u0119 wiadomo\u015bci, kt\u00f3re mog\u0105 by\u0107 przechowywane w kolejce przychodz\u0105cych wiadomo\u015bci.\nJe\u015bli w kolejce na wiadomo\u015bci przychodz\u0105ce nie ma ju\u017c wolnych miejsc, wiadomo\u015b\u0107 przychodz\u0105ca jest odrzucana.\n:param channel: (default=7) warto\u015b\u0107 ca\u0142kowita od 0 do 83 (w\u0142\u0105cznie), kt\u00f3ra definiuje dowolny \u201ekana\u0142\u201d, do kt\u00f3rego dostrojone jest radio.\nWiadomo\u015bci b\u0119d\u0105 wysy\u0142ane za po\u015brednictwem tego kana\u0142u i tylko wiadomo\u015bci otrzymane za po\u015brednictwem tego kana\u0142u zostan\u0105 umieszczone w kolejce wiadomo\u015bci przychodz\u0105cych. Ka\u017cdy stopie\u0144 ma szeroko\u015b\u0107 1 MHz w oparciu o cz\u0119stotliwo\u015b\u0107 2400 MHz.\n:param power: (default=6) jest liczb ca\u0142kowit\u0105 od 0 do 7 (w\u0142\u0105cznie) do oznaczenia si\u0142y sygna\u0142u u\u017cywanego podczas nadawania wiadomo\u015bci.\nIm wy\u017csza warto\u015b\u0107, tym silniejszy jest sygna\u0142, ale tym wi\u0119ksza moc jest zu\u017cywana przez urz\u0105dzenie. Numeracja przek\u0142ada si\u0119 na pozycje w nast\u0119puj\u0105cym wykazie warto\u015bci dBm (decybel miliwat): -30, -20, -16, -12, -8, -4, 0, 4.\n:param address: (default=0x75626974) dowolna nazwa wyra\u017cona jako 32-bitowy adres, u\u017cywana do filtrowania przychodz\u0105cych pakiet\u00f3w na poziomie sprz\u0119towym, zatrzymuj\u0105c tylko te, kt\u00f3re odpowiadaj\u0105 ustawionemu adresowi.\nDomy\u015blnym ustawieniem u\u017cywanym przez inne platformy powi\u0105zane z micro:bitem jest ustawienie domy\u015blne u\u017cywane tutaj.\n:param group: (default=0) 8-bitowa warto\u015b\u0107 (0-255) u\u017cywana wraz z ``address`` podczas filtrowania wiadomo\u015bci.\nKoncepcyjnie, \"adres\" jest jak adres domu/biura, a \"grupa\" jest jak osoba pod tym adresem, na kt\u00f3ry chcesz wys\u0142a\u0107 swoj\u0105 wiadomo\u015b\u0107.\n:param data_rate: (default=``radio.RATE_1MBIT``) wskazuje pr\u0119dko\u015b\u0107, z jak\u0105 odbywa si\u0119 przesy\u0142anie danych.\nMo\u017ce by\u0107 jedn\u0105 z nast\u0119puj\u0105cych sta\u0142ych zdefiniowanych w module ``radio``:``RATE_250KBIT``, ``RATE_1MBIT`` lub ``RATE_2MBIT``.\n\nIf ``config`` is not called then the defaults described above are assumed.\"\"\"\n    ...\n\ndef reset() -> None:\n    \"\"\"Resetuj ustawienia do ich warto\u015bci domy\u015blnych.\n\nExample: ``radio.reset()``\n\nThe defaults as as per the ``config`` function above.\"\"\"\n    ...\n\ndef send_bytes(message: bytes) -> None:\n    \"\"\"Wysy\u0142a wiadomo\u015b\u0107 zawieraj\u0105c\u0105 bajty.\n\nExample: ``radio.send_bytes(b'hello')``\n\n:param message: Bajty do wys\u0142ania.\"\"\"\n    ...\n\ndef receive_bytes() -> Optional[bytes]:\n    \"\"\"Otrzymuj nast\u0119pn\u0105 przychodz\u0105c\u0105 wiadomo\u015b\u0107 w kolejce wiadomo\u015bci.\n\nExample: ``radio.receive_bytes()``\n\n:return: The message bytes if any, otherwise ``None``.\"\"\"\n    ...\n\ndef receive_bytes_into(buffer: WriteableBuffer) -> Optional[int]:\n    \"\"\"Skopiuj nast\u0119pn\u0105 wiadomo\u015b\u0107 przychodz\u0105c\u0105 do kolejki wiadomo\u015bci w buforze.\n\nExample: ``radio.receive_bytes_info(buffer)``\n\n:param buffer: Bufor docelowy. Wiadomo\u015b\u0107 jest obcinana, je\u015bli jest wi\u0119ksza ni\u017c bufor.\n:return: ``None`` if there are no pending messages, otherwise it returns the length of the message (which might be more than the length of the buffer).\"\"\"\n    ...\n\ndef send(message: str) -> None:\n    \"\"\"Wysy\u0142a \u0142a\u0144cuch wiadomo\u015bci.\n\nExample: ``radio.send('hello')``\n\nThis is the equivalent of ``radio.send_bytes(bytes(message, 'utf8'))`` but with ``b'\\x01\\x00\\x01'``\nprepended to the front (to make it compatible with other platforms that target the micro:bit).\n\n:param message: \u0141a\u0144cuch do wys\u0142ania.\"\"\"\n    ...\n\ndef receive() -> Optional[str]:\n    \"\"\"Dzia\u0142a dok\u0142adnie w taki sam spos\u00f3b, jak ``receive_bytes``, ale zwraca cokolwiek zosta\u0142o wys\u0142ane. (odbierz)\n\nExample: ``radio.receive()``\n\nEquivalent to ``str(receive_bytes(), 'utf8')`` but with a check that the the first\nthree bytes are ``b'\\x01\\x00\\x01'`` (to make it compatible with other platforms that\nmay target the micro:bit).\n\n:return: The message with the prepended bytes stripped and converted to a string.\n\nA ``ValueError`` exception is raised if conversion to string fails.\"\"\"\n    ...\n\ndef receive_full() -> Optional[Tuple[bytes, int, int]]:\n    \"\"\"Zwraca krotk\u0119 zawieraj\u0105c\u0105 trzy warto\u015bci reprezentuj\u0105ce nast\u0119pn\u0105 wiadomo\u015b\u0107 przychodz\u0105c\u0105 do kolejki wiadomo\u015bci.\n\nExample: ``radio.receive_full()``\n\nIf there are no pending messages then ``None`` is returned.\n\nThe three values in the tuple represent:\n\n- the next incoming message on the message queue as bytes.\n- the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n- a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\nFor example::\n\n    details = radio.receive_full()\n    if details:\n        msg, rssi, timestamp = details\n\nThis function is useful for providing information needed for triangulation\nand/or trilateration with other micro:bit devices.\n\n:return: ``None`` if there is no message, otherwise a tuple of length three with the bytes, strength and timestamp values.\"\"\"\n    ...",
    "/typeshed/stdlib/random.pyi": "\"\"\"Generuj liczb losowe. (losowy)\"\"\"\nfrom typing import TypeVar, Sequence, Union, overload\n\ndef getrandbits(n: int) -> int:\n    \"\"\"Wygeneruj liczb\u0119 ca\u0142kowit\u0105 z ``n`` losowymi bitami.\n\nExample: ``random.getrandbits(1)``\n\n:param n: Warto\u015b\u0107 mi\u0119dzy 1\u201330 (w\u0142\u0105cznie).\"\"\"\n    ...\n\ndef seed(n: int) -> None:\n    \"\"\"Zainicjuj generator liczb losowych.\n\nExample: ``random.seed(0)``\n\n:param n: Ca\u0142kowity zarodek\n\nThis will give you reproducibly deterministic randomness from a given starting\nstate (``n``).\"\"\"\n    ...\n\ndef randint(a: int, b: int) -> int:\n    \"\"\"Wybierz losow\u0105 liczb\u0119 ca\u0142kowit\u0105 pomi\u0119dzy ``a`` i ``b`` w\u0142\u0105cznie.\n\nExample: ``random.randint(0, 9)``\n\n:param a: Warto\u015b\u0107 pocz\u0105tkowa dla zakresu (w\u0142\u0105cznie)\n:param b: Warto\u015b\u0107 ko\u0144cowa dla zakresu (wy\u0142\u0105cznie)\n\nAlias for ``randrange(a, b + 1)``.\"\"\"\n    ...\n\n@overload\ndef randrange(stop: int) -> int:\n    \"\"\"Wybierz losowo wybran\u0105 liczb\u0119 ca\u0142kowit\u0105 mi\u0119dzy zero a\u017c do (ale nie\nw\u0142\u0105cznie) ``stop``.\n\nExample: ``random.randrange(10)``\n\n:param stop: Warto\u015b\u0107 ko\u0144cowa zakresu (wy\u0142\u0105cznie)\"\"\"\n    ...\n\n@overload\ndef randrange(start: int, stop: int, step: int=1) -> int:\n    \"\"\"Wybierz losowo wybrany element z ``range(start, stop, step)``.\n\nExample: ``random.randrange(0, 10)``\n\n:param start: Pocz\u0105tek zakresu (w\u0142\u0105cznie)\n:param stop: Koniec zakresu (wy\u0142\u0105cznie)\n:param step: Krok\"\"\"\n    ...\n_T = TypeVar('_T')\n\ndef choice(seq: Sequence[_T]) -> _T:\n    \"\"\"Wybierz losowy element z niepustego cigu ``seq``.\n\nExample: ``random.choice([Image.HAPPY, Image.SAD])``\n\n:param seq: Cig.\n\nIf ``seq`` is  empty, raises ``IndexError``.\"\"\"\n    ...\n\ndef random() -> float:\n    \"\"\"Wygeneruj losow\u0105 liczb\u0119 zmiennopozycyjn\u0105 w zakresie [0.0, 1.0).\n\nExample: ``random.random()``\n\n:return: The random floating point number\"\"\"\n    ...\n\ndef uniform(a: float, b: float) -> float:\n    \"\"\"Zwr\u00f3\u0107 losow\u0105 liczb\u0119 zmiennopozycyjn\u0142\u0105 mi\u0119dzy ``a`` i ``b``.\n\nExample: ``random.uniform(0, 9)``\n\n:param a: Warto\u015b\u0107 pocz\u0105tkowa dla zakresu (w\u0142\u0105cznie)\n:param b: Warto\u015b\u0107 ko\u0144cowa dla zakresu (wy\u0142\u0105cznie)\"\"\"\n    ...",
    "/typeshed/stdlib/speech.pyi": "\"\"\"Spraw, by micro:bit m\u00f3wi\u0142, \u015bpiewa\u0142 i tworzy\u0142 inne d\u017awi\u0119ki podobne do mowy.\"\"\"\nfrom typing import Optional\nfrom .microbit import MicroBitDigitalPin, pin0\n\ndef translate(words: str) -> str:\n    \"\"\"T\u0142umacz angielskie s\u0142owa na fonemy.\n\nExample: ``speech.translate('hello world')``\n\n:param words: \u0141a\u0144cuch s\u0142\u00f3w angielskich.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef pronounce(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: Optional[MicroBitDigitalPin]=pin0) -> None:\n    \"\"\"Wym\u00f3w fonemy.\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: \u0141a\u0144cuch fonem\u00f3w do wym\u00f3wienia\n:param pitch: Liczba reprezentuj\u0105ca wysoko\u015b\u0107 g\u0142osu\n:param speed: Liczba reprezentuj\u0105ca szybko\u015b\u0107 g\u0142osu\n:param mouth: Liczba reprezentuj\u0105ca usta g\u0142osu\n:param throat: Liczba reprezentuj\u0105ca gard\u0142o g\u0142osu\n:param pin: Opcjonalny argument do okre\u015blenia pinu wyj\u015bciowego mo\u017ce by\u0107 u\u017cyty do nadpisania domy\u015blnej warto\u015bci ``pin0``.\nJe\u015bli nie chcemy, aby jakikolwiek d\u017awi\u0119k wydobywa\u0142 si\u0119 z pin\u00f3w, mo\u017cemy u\u017cy\u0107 ``pin=None``. Tylko micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef say(words: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Powiedz angielskie s\u0142owa.\n\nExample: ``speech.say('hello world')``\n\n:param words: \u0141a\u0144cuch s\u0142\u00f3w do powiedzenia.\n:param pitch: Liczba reprezentuj\u0105ca wysoko\u015b\u0107 g\u0142osu\n:param speed: Liczba reprezentuj\u0105ca szybko\u015b\u0107 g\u0142osu\n:param mouth: Liczba reprezentuj\u0105ca usta g\u0142osu\n:param throat: Liczba reprezentuj\u0105ca gard\u0142o g\u0142osu\n:param pin: Opcjonalny argument do okre\u015blenia pinu wyj\u015bciowego mo\u017ce by\u0107 u\u017cyty do nadpisania domy\u015blnej warto\u015bci ``pin0``.\nJe\u015bli nie chcemy, aby jakikolwiek d\u017awi\u0119k wydobywa\u0142 si\u0119 z pin\u00f3w, mo\u017cemy u\u017cy\u0107 ``pin=None``. Tylko micro:bit V2.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...\n\ndef sing(phonemes: str, pitch: int=64, speed: int=72, mouth: int=128, throat: int=128, pin: MicroBitDigitalPin=pin0) -> None:\n    \"\"\"Za\u015bpiewaj fonemy.\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: \u0141a\u0144cuch s\u0142\u00f3w do za\u015bpiewania.\n:param pitch: Liczba reprezentuj\u0105ca wysoko\u015b\u0107 g\u0142osu\n:param speed: Liczba reprezentuj\u0105ca szybko\u015b\u0107 g\u0142osu\n:param mouth: Liczba reprezentuj\u0105ca usta g\u0142osu\n:param throat: Liczba reprezentuj\u0105ca gard\u0142o g\u0142osu\n:param pin: Opcjonalny argument do okre\u015blenia pinu wyj\u015bciowego mo\u017ce by\u0107 u\u017cyty do nadpisania domy\u015blnej warto\u015bci ``pin0``.\nJe\u015bli nie chcemy, aby jakikolwiek d\u017awi\u0119k wydobywa\u0142 si\u0119 z pin\u00f3w, mo\u017cemy u\u017cy\u0107 ``pin=None``. Tylko micro:bit V2.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.\"\"\"\n    ...",
    "/typeshed/stdlib/struct.pyi": "\"\"\"Pakuj i rozpakowuj prymitywne typy danych.\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom typing import Any, Tuple, Union\n\ndef calcsize(fmt: str) -> int:\n    \"\"\"Uzyskaj liczb\u0119 bajt\u00f3w potrzebnych do przechowywania podanego ``fmt``.\n\nExample: ``struct.calcsize('hf')``\n\n:param fmt: \u0141a\u0144cuch formatu.\n:return The number of bytes needed to store such a value.\"\"\"\n    ...\n\ndef pack(fmt: str, v1: Any, *vn: Any) -> bytes:\n    \"\"\"Upakuj warto\u015bci zgodnie z \u0142\u0144cuchem formatu.\n\nExample: ``struct.pack('hf', 1, 3.1415)``\n\n:param fmt: \u0141a\u0144cuch formatu.\n:param v1: Pierwsza warto\u015b\u0107.\n:param *vn: Pozosta\u0142e warto\u015bci.\n:return A bytes object encoding the values.\"\"\"\n    ...\n\ndef pack_into(fmt: str, buffer: WriteableBuffer, offset: int, v1: Any, *vn: Any) -> None:\n    \"\"\"Upakuj warto\u015bci zgodnie z \u0142\u0144cuchem formatu.\n\nExample: ``struct.pack_info('hf', buffer, 1, 3.1415)``\n\n:param fmt: \u0141a\u0144cuch formatu.\n:param buffer: Bufor docelowy do zapisu.\n:param offset: Przesuni\u0119cie do bufora. Warto\u015b\u0107 ujemna mo\u017ce by\u0107 liczona od ko\u0144ca bufora.\n:param v1: (w1) Pierwsza warto\u015b\u0107.\n:param *vn: Pozosta\u0142e warto\u015bci.\"\"\"\n    ...\n\ndef unpack(fmt: str, data: ReadableBuffer) -> Tuple[Any, ...]:\n    \"\"\"Rozpakuj dane zgodnie z \u0142a\u0144cuchem formatu.\n\nExample: ``v1, v2 = struct.unpack('hf', buffer)``\n\n:param fmt: \u0141a\u0144cuch formatu.\n:param data: Dane\n:return: A tuple of the unpacked values.\"\"\"\n    ...\n\ndef unpack_from(fmt: str, buffer: ReadableBuffer, offset: int=0) -> Tuple:\n    \"\"\"Rozpakuj dane z buforu zgodnie z \u0142a\u0144cuchem formatu.\n\nExample: ``v1, v2 = struct.unpack_from('hf', buffer)``\n\n:param fmt: \u0141a\u0144cuch formatu.\n:param buffer: Bufor \u017ar\u00f3d\u0142owy do odczytu.\n:param offset: Przesuni\u0119cie do bufora. Warto\u015b\u0107 ujemna mo\u017ce by\u0107 liczona od ko\u0144ca bufora.\n:return: A tuple of the unpacked values.\"\"\"\n    ...",
    "/typeshed/stdlib/sys.pyi": "\"\"\"Funkcje specyficzne dla systemu\"\"\"\nfrom typing import Any, Dict, List, NoReturn, TextIO, Tuple\n\ndef exit(retval: object=...) -> NoReturn:\n    \"\"\"Zako\u0144cz bie\u017c\u0105cy program z podanym kodem wyj\u015bcia.\n\nExample: ``sys.exit(1)``\n\nThis function raises a ``SystemExit`` exception. If an argument is given, its\nvalue given as an argument to ``SystemExit``.\n\n:param retval: Kod lub wiadomo\u015b\u0107 wyj\u015bciowa.\"\"\"\n    ...\n\ndef print_exception(exc: Exception) -> None:\n    \"\"\"Wydrukuj wyj\u0105tek ze \u015bledzeniem.\n\nExample: ``sys.print_exception(e)``\n\n:param exc: Wyj\u0105tek do wydrukowania\n\nThis is simplified version of a function which appears in the\n``traceback`` module in CPython.\"\"\"\nargv: List[str]\n\"\"\"Zmienna lista argument\u00f3w, od kt\u00f3rych uruchomiono bie\u017c\u0105cy program.\"\"\"\nbyteorder: str\n\"\"\"Kolejno\u015b\u0107 bajt\u00f3w systemu (``\"little\"`` lub ``\"big\"``).\"\"\"\n\nclass _implementation:\n    name: str\n    version: Tuple[int, int, int]\nimplementation: _implementation\n\"\"\"Obiekt z informacjami o bie\u017c\u0105cej implementacji Pythona.\n\nFor MicroPython, it has following attributes:\n\n- ``name`` - string \"micropython\"\n- ``version`` - tuple (major, minor, micro), e.g. (1, 7, 0)\n\nThis object is the recommended way to distinguish MicroPython from other\nPython implementations (note that it still may not exist in the very\nminimal ports).\n\nCPython mandates more attributes for this object, but the actual useful\nbare minimum is implemented in MicroPython.\n\"\"\"\nmaxsize: int\n\"\"\"\nMaksymalna warto\u015b\u0107, jak\u0105 mo\u017ce przechowywa\u0107 natywny typ ca\u0142kowity na bie\u017c\u0105cej platformie,\nlub maksymalna warto\u015b\u0107 reprezentowana przez typ ca\u0142kowity MicroPythona, je\u015bli jest mniejsza\nni\u017c maksymalna warto\u015b\u0107 platformy (tak jest w przypadku port\u00f3w MicroPython bez\nwsparcia long int).\n\nThis attribute is useful for detecting \"bitness\" of a platform (32-bit vs\n64-bit, etc.). It's recommended to not compare this attribute to some\nvalue directly, but instead count number of bits in it::\n\n    bits = 0\n    v = sys.maxsize\n    while v:\n        bits += 1\n        v >>= 1\n    if bits > 32:\n        # 64-bit (or more) platform\n        ...\n    else:\n        # 32-bit (or less) platform\n        # Note that on 32-bit platform, value of bits may be less than 32\n        # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n        # \"> 32\", \"> 64\" style of comparisons.\n\"\"\"\nmodules: Dict[str, Any]\n\"\"\"S\u0142ownik za\u0142adowanych modu\u0142\u00f3w. \n\nOn some ports, it may not include builtin modules.\"\"\"\npath: List[str]\n\"\"\"Zmienna lista katalog\u00f3w do wyszukiwania importowanych modu\u0142\u00f3w.\"\"\"\nplatform: str\n\"\"\"Platforma na kt\u00f3rej dzia\u0142a MicroPython. \n\nFor OS/RTOS ports, this is usually an identifier of the OS, e.g. ``\"linux\"``.\nFor baremetal ports it is an identifier of a board, e.g. ``\"pyboard\"`` for \nthe original MicroPython reference board. It thus can be used to\ndistinguish one board from another.\n\nIf you need to check whether your program runs on MicroPython (vs other\nPython implementation), use ``sys.implementation`` instead.\n\"\"\"\nversion: str\n\"\"\"Wersja Pythona, z kt\u00f3r\u0105 ta implementacja jest zgodna, jako \u0142a\u0144cuch.\"\"\"\nversion_info: Tuple[int, int, int]\n\"\"\"Wersja Pythona, z kt\u00f3r\u0105 ta implementacja jest zgodna, jako krotka typu int.\n\nOnly the first three version numbers (major, minor, micro) are supported and\nthey can be referenced only by index, not by name.\n\"\"\"",
    "/typeshed/stdlib/this.pyi": "def authors() -> str: ...\n",
    "/typeshed/stdlib/time.pyi": "\"\"\"Zmierz czas i dodaj op\u00f3\u017anienia do program\u00f3w.\"\"\"\nfrom typing import Union\n\ndef sleep(seconds: Union[int, float]) -> None:\n    \"\"\"Op\u00f3\u017anij kilka sekund.\n\nExample: ``time.sleep(1)``\n\n:param seconds: Liczba sekund snu.\nU\u017cyj liczby zmiennopozycyjnej, aby spa\u0107 przez u\u0142amkow\u0105 cz\u0119\u015b\u0107 sekund.\"\"\"\n    ...\n\ndef sleep_ms(ms: int) -> None:\n    \"\"\"Op\u00f3\u017anij o podan\u0105 liczb\u0119 milisekund.\n\nExample: ``time.sleep_ms(1_000_000)``\n\n:param ms: Liczba milisekund op\u00f3\u017anienia (>= 0).\"\"\"\n    ...\n\ndef sleep_us(us: int) -> None:\n    \"\"\"Op\u00f3\u017anij o podan\u0105 liczb\u0119 milisekund.\n\nExample: ``time.sleep_us(1000)``\n\n:param us: Liczba milisekund op\u00f3\u017anienia (>= 0).\"\"\"\n    ...\n\ndef ticks_ms() -> int:\n    \"\"\"Uzyskaj rosn\u0105cy licznik milisekundowy z dowolnym punktem odniesienia,\nkt\u00f3ry zawija si\u0119 po pewnej warto\u015bci.\n\nExample: ``time.ticks_ms()``\n\n:return: The counter value in milliseconds.\"\"\"\n    ...\n\ndef ticks_us() -> int:\n    \"\"\"Uzyskaj rosn\u0105cy licznik milisekundowy z dowolnym punktem odniesienia,\nkt\u00f3ry zawija si\u0119 po pewnej warto\u015bci.\n\nExample: ``time.ticks_us()``\n\n:return: The counter value in microseconds.\"\"\"\n    ...\n\ndef ticks_add(ticks: int, delta: int) -> int:\n    \"\"\"Przesuni\u0119cie zaznacza warto\u015b\u0107 o podan\u0105 liczb\u0119, kt\u00f3ra mo\u017ce by\u0107 dodatnia lub\nnegatywny.\n.\n\nExample: ``time.ticks_add(time.ticks_ms(), 200)``\n\nGiven a ticks value, this function allows to calculate ticks\nvalue delta ticks before or after it, following modular-arithmetic\ndefinition of tick values.\n\n:param ticks: Warto\u015b\u0107 tick\u00f3w\n:param delta: Przesuni\u0119cie o liczb\u0119 ca\u0142kowit\u0105\n\nExample::\n\n    # Find out what ticks value there was 100ms ago\n    print(ticks_add(time.ticks_ms(), -100))\n\n    # Calculate deadline for operation and test for it\n    deadline = ticks_add(time.ticks_ms(), 200)\n    while ticks_diff(deadline, time.ticks_ms()) > 0:\n        do_a_little_of_something()\n\n    # Find out TICKS_MAX used by this port\n    print(ticks_add(0, -1))\"\"\"\n    ...\n\ndef ticks_diff(ticks1: int, ticks2: int) -> int:\n    \"\"\"Zmierz r\u00f3\u017cnic\u0119 tick\u00f3w mi\u0119dzy warto\u015bciami zwr\u00f3conymi z\n``time.ticks_ms()`` lub ``ticks_us()``, jako warto\u015b\u0107 ze znakiem, \nkt\u00f3ra mo\u017ce si\u0119 zawija\u0107.\n\nExample: ``time.ticks_diff(scheduled_time, now)``\n\n:param ticks1: Warto\u015b\u0107 do odejmowania od\n:param ticks2: Warto\u015b\u0107 do odejmowania\n\nThe argument order is the same as for subtraction operator,\n``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n``ticks_diff()`` is designed to accommodate various usage\npatterns, among them:\n\nPolling with timeout. In this case, the order of events is known, and you\nwill deal only with positive results of :func:`time.ticks_diff()`::\n\n    # Wait for GPIO pin to be asserted, but at most 500us\n    start = time.ticks_us()\n    while pin.value() == 0:\n        if time.ticks_diff(time.ticks_us(), start) > 500:\n            raise TimeoutError\n\n\nScheduling events. In this case, :func:`time.ticks_diff()` result may be\nnegative if an event is overdue::\n\n    # This code snippet is not optimized\n    now = time.ticks_ms()\n    scheduled_time = task.scheduled_time()\n    if ticks_diff(scheduled_time, now) > 0:\n        print(\"Too early, let's nap\")\n        sleep_ms(ticks_diff(scheduled_time, now))\n        task.run()\n    elif ticks_diff(scheduled_time, now) == 0:\n        print(\"Right at time!\")\n        task.run()\n    elif ticks_diff(scheduled_time, now) < 0:\n        print(\"Oops, running late, tell task to run faster!\")\n        task.run(run_faster=True)\"\"\"\n    ...",
    "/typeshed/stdlib/types.pyi": "import sys\nfrom typing import (\n    Any,\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Generator,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    Tuple,\n    Type,\n    TypeVar,\n    ValuesView,\n    overload,\n)\nfrom typing_extensions import Literal, final\n\n# Note, all classes \"defined\" here require special handling.\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_KT = TypeVar(\"_KT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_V_co = TypeVar(\"_V_co\", covariant=True)\n\n@final\nclass _Cell:\n    __hash__: None  # type: ignore\n    cell_contents: Any\n\n@final\nclass FunctionType:\n    __closure__: Tuple[_Cell, ...] | None\n    __code__: CodeType\n    __defaults__: Tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    __globals__: dict[str, Any]\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, Any]\n    __kwdefaults__: dict[str, Any]\n    def __init__(\n        self,\n        code: CodeType,\n        globals: dict[str, Any],\n        name: str | None = ...,\n        argdefs: Tuple[object, ...] | None = ...,\n        closure: Tuple[_Cell, ...] | None = ...,\n    ) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, obj: object | None, type: type | None) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    \"\"\"Create a code object.  Not for the faint of heart.\"\"\"\n\n    co_argcount: int\n    if sys.version_info >= (3, 8):\n        co_posonlyargcount: int\n    co_kwonlyargcount: int\n    co_nlocals: int\n    co_stacksize: int\n    co_flags: int\n    co_code: bytes\n    co_consts: Tuple[Any, ...]\n    co_names: Tuple[str, ...]\n    co_varnames: Tuple[str, ...]\n    co_filename: str\n    co_name: str\n    co_firstlineno: int\n    co_lnotab: bytes\n    co_freevars: Tuple[str, ...]\n    co_cellvars: Tuple[str, ...]\n    if sys.version_info >= (3, 8):\n        def __init__(\n            self,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            argcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: Tuple[Any, ...],\n            names: Tuple[str, ...],\n            varnames: Tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: Tuple[str, ...] = ...,\n            cellvars: Tuple[str, ...] = ...,\n        ) -> None: ...\n    if sys.version_info >= (3, 8):\n        def replace(\n            self,\n            *,\n            co_argcount: int = ...,\n            co_posonlyargcount: int = ...,\n            co_kwonlyargcount: int = ...,\n            co_nlocals: int = ...,\n            co_stacksize: int = ...,\n            co_flags: int = ...,\n            co_firstlineno: int = ...,\n            co_code: bytes = ...,\n            co_consts: Tuple[Any, ...] = ...,\n            co_names: Tuple[str, ...] = ...,\n            co_varnames: Tuple[str, ...] = ...,\n            co_freevars: Tuple[str, ...] = ...,\n            co_cellvars: Tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> CodeType: ...\n\n@final\nclass MappingProxyType(Mapping[_KT, _VT_co], Generic[_KT, _VT_co]):\n    __hash__: None  # type: ignore\n    def __init__(self, mapping: Mapping[_KT, _VT_co]) -> None: ...\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def copy(self) -> dict[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n        def __reversed__(self) -> Iterator[_KT]: ...\n        def __or__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n        def __ror__(\n            self, __value: Mapping[_T1, _T2]\n        ) -> dict[_KT | _T1, _VT_co | _T2]: ...\n\nclass SimpleNamespace:\n    __hash__: None  # type: ignore\n    def __init__(self, **kwargs: Any) -> None: ...\n    def __getattribute__(self, name: str) -> Any: ...\n    def __setattr__(self, name: str, value: Any) -> None: ...\n    def __delattr__(self, name: str) -> None: ...\n\nclass ModuleType:\n    __name__: str\n    __file__: str\n    __dict__: dict[str, Any]\n    __package__: str | None\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n\n@final\nclass GeneratorType(Generator[_T_co, _T_contra, _V_co]):\n    gi_code: CodeType\n    gi_frame: FrameType\n    gi_running: bool\n    gi_yieldfrom: GeneratorType[_T_co, _T_contra, Any] | None\n    def __iter__(self) -> GeneratorType[_T_co, _T_contra, _V_co]: ...\n    def __next__(self) -> _T_co: ...\n    def close(self) -> None: ...\n    def send(self, __arg: _T_contra) -> _T_co: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> _T_co: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> _T_co: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_T_co, _T_contra]):\n    ag_await: Awaitable[Any] | None\n    ag_frame: FrameType\n    ag_running: bool\n    ag_code: CodeType\n    def __aiter__(self) -> AsyncGeneratorType[_T_co, _T_contra]: ...\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def asend(self, __val: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    def athrow(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Awaitable[_T_co]: ...\n    def aclose(self) -> Awaitable[None]: ...\n\n@final\nclass CoroutineType:\n    cr_await: Any | None\n    cr_code: CodeType\n    cr_frame: FrameType\n    cr_running: bool\n    def close(self) -> None: ...\n    def send(self, __arg: Any) -> Any: ...\n    @overload\n    def throw(\n        self,\n        __typ: Type[BaseException],\n        __val: BaseException | object = ...,\n        __tb: TracebackType | None = ...,\n    ) -> Any: ...\n    @overload\n    def throw(\n        self, __typ: BaseException, __val: None = ..., __tb: TracebackType | None = ...\n    ) -> Any: ...\n\nclass _StaticFunctionType:\n    \"\"\"Fictional type to correct the type of MethodType.__func__.\n\n    FunctionType is a descriptor, so mypy follows the descriptor protocol and\n    converts MethodType.__func__ back to MethodType (the return type of\n    FunctionType.__get__). But this is actually a special case; MethodType is\n    implemented in C and its attribute access doesn't go through\n    __getattribute__.\n\n    By wrapping FunctionType in _StaticFunctionType, we get the right result;\n    similar to wrapping a function in staticmethod() at runtime to prevent it\n    being bound as a method.\n    \"\"\"\n\n    def __get__(self, obj: object | None, type: type | None) -> FunctionType: ...\n\n@final\nclass MethodType:\n    __closure__: Tuple[_Cell, ...] | None  # inherited from the added function\n    __defaults__: Tuple[Any, ...] | None  # inherited from the added function\n    __func__: _StaticFunctionType\n    __self__: object\n    __name__: str  # inherited from the added function\n    __qualname__: str  # inherited from the added function\n    def __init__(self, func: Callable[..., Any], obj: object) -> None: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n@final\nclass BuiltinFunctionType:\n    __self__: object | ModuleType\n    __name__: str\n    __qualname__: str\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\nif sys.version_info >= (3, 7):\n    @final\n    class WrapperDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class MethodWrapperType:\n        __self__: object\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __ne__(self, other: Any) -> bool: ...\n    @final\n    class MethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n    @final\n    class ClassMethodDescriptorType:\n        __name__: str\n        __qualname__: str\n        __objclass__: type\n        def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n        def __get__(self, obj: Any, type: type = ...) -> Any: ...\n\n@final\nclass TracebackType:\n    if sys.version_info >= (3, 7):\n        def __init__(\n            self,\n            tb_next: TracebackType | None,\n            tb_frame: FrameType,\n            tb_lasti: int,\n            tb_lineno: int,\n        ) -> None: ...\n        tb_next: TracebackType | None\n    else:\n        @property\n        def tb_next(self) -> TracebackType | None: ...\n    # the rest are read-only even in 3.7\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    f_back: FrameType | None\n    f_builtins: dict[str, Any]\n    f_code: CodeType\n    f_globals: dict[str, Any]\n    f_lasti: int\n    f_lineno: int\n    f_locals: dict[str, Any]\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    if sys.version_info >= (3, 7):\n        f_trace_lines: bool\n        f_trace_opcodes: bool\n    def clear(self) -> None: ...\n\n@final\nclass GetSetDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    __name__: str\n    __objclass__: type\n    def __get__(self, __obj: Any, __type: type = ...) -> Any: ...\n    def __set__(self, __instance: Any, __value: Any) -> None: ...\n    def __delete__(self, obj: Any) -> None: ...\n\nif sys.version_info >= (3, 7):\n    def new_class(\n        name: str,\n        bases: Iterable[object] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n    def resolve_bases(bases: Iterable[object]) -> Tuple[Any, ...]: ...\n\nelse:\n    def new_class(\n        name: str,\n        bases: Tuple[type, ...] = ...,\n        kwds: dict[str, Any] | None = ...,\n        exec_body: Callable[[dict[str, Any]], None] | None = ...,\n    ) -> type: ...\n\ndef prepare_class(\n    name: str, bases: Tuple[type, ...] = ..., kwds: dict[str, Any] | None = ...\n) -> Tuple[type, dict[str, Any], dict[str, Any]]: ...\n\n# Actually a different type, but `property` is special and we want that too.\nDynamicClassAttribute = property\n\ndef coroutine(func: Callable[..., Any]) -> CoroutineType: ...\n\nif sys.version_info >= (3, 8):\n    CellType = _Cell\n\nif sys.version_info >= (3, 9):\n    class GenericAlias:\n        __origin__: type\n        __args__: Tuple[Any, ...]\n        __parameters__: Tuple[Any, ...]\n        def __init__(self, origin: type, args: Any) -> None: ...\n        def __getattr__(self, name: str) -> Any: ...  # incomplete\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n    EllipsisType = ellipsis  # noqa F811 from builtins\n    from builtins import _NotImplementedType\n\n    NotImplementedType = _NotImplementedType  # noqa F811 from builtins\n    @final\n    class UnionType:\n        __args__: Tuple[Any, ...]\n        def __or__(self, obj: Any) -> UnionType: ...\n        def __ror__(self, obj: Any) -> UnionType: ...\n",
    "/typeshed/stdlib/typing.pyi": "import collections  # Needed by aliases like DefaultDict, see mypy issue 2986\nimport sys\nfrom abc import ABCMeta, abstractmethod\nfrom types import BuiltinFunctionType, CodeType, FrameType, FunctionType, MethodType, ModuleType, TracebackType\nfrom typing_extensions import Literal as _Literal\n\nif sys.version_info >= (3, 7):\n    from types import MethodDescriptorType, MethodWrapperType, WrapperDescriptorType\n\nif sys.version_info >= (3, 9):\n    from types import GenericAlias\n\n# Definitions of special type checking related constructs.  Their definitions\n# are not used, so their value does not matter.\n\nAny = object()\n\nclass TypeVar:\n    __name__: str\n    __bound__: Optional[Type[Any]]\n    __constraints__: Tuple[Type[Any], ...]\n    __covariant__: bool\n    __contravariant__: bool\n    def __init__(\n        self,\n        name: str,\n        *constraints: Type[Any],\n        bound: Union[None, Type[Any], str] = ...,\n        covariant: bool = ...,\n        contravariant: bool = ...,\n    ) -> None: ...\n\n_promote = object()\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> object: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef overload(func: _F) -> _F: ...\n\nUnion: _SpecialForm = ...\nOptional: _SpecialForm = ...\nTuple: _SpecialForm = ...\nGeneric: _SpecialForm = ...\n# Protocol is only present in 3.8 and later, but mypy needs it unconditionally\nProtocol: _SpecialForm = ...\nCallable: _SpecialForm = ...\nType: _SpecialForm = ...\nClassVar: _SpecialForm = ...\nif sys.version_info >= (3, 8):\n    Final: _SpecialForm = ...\n    def final(f: _F) -> _F: ...\n    Literal: _SpecialForm = ...\n    # TypedDict is a (non-subscriptable) special form.\n    TypedDict: object\n\nif sys.version_info < (3, 7):\n    class GenericMeta(type): ...\n\nif sys.version_info >= (3, 10):\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Optional[Type[Any]]\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: Union[None, Type[Any], str] = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n\n# Return type that indicates a function does not return.\n# This type is equivalent to the None type, but the no-op Union is necessary to\n# distinguish the None type from the None value.\nNoReturn = Union[None]\n\n# These type variables are used by the container types.\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_V_co = TypeVar(\"_V_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)  # Ditto contravariant.\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\ndef no_type_check(arg: _F) -> _F: ...\ndef no_type_check_decorator(decorator: _F) -> _F: ...\n\n# Type aliases and type constructors\n\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nif sys.version_info >= (3, 7):\n    OrderedDict = _Alias()\n\nif sys.version_info >= (3, 9):\n    Annotated: _SpecialForm = ...\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\nif sys.version_info >= (3, 8):\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=ABCMeta):\n        @abstractmethod\n        def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _V_co]):\n    def __next__(self) -> _T_co: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    def close(self) -> None: ...\n    def __iter__(self) -> Generator[_T_co, _T_contra, _V_co]: ...\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Optional[Generator[Any, Any, Any]]: ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, None, _T_co]: ...\n\nclass Coroutine(Awaitable[_V_co], Generic[_T_co, _T_contra, _V_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Optional[Any]: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    @property\n    def cr_frame(self) -> FrameType: ...\n    @property\n    def cr_running(self) -> bool: ...\n    @abstractmethod\n    def send(self, __value: _T_contra) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> _T_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484.\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_V_co], Generator[_T_co, _T_contra, _V_co], Generic[_T_co, _T_contra, _V_co, _S], metaclass=ABCMeta\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\nclass AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def asend(self, __value: _T_contra) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, __typ: Type[BaseException], __val: Union[BaseException, object] = ..., __tb: Optional[TracebackType] = ...\n    ) -> Awaitable[_T_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(self, __typ: BaseException, __val: None = ..., __tb: Optional[TracebackType] = ...) -> Awaitable[_T_co]: ...\n    @abstractmethod\n    def aclose(self) -> Awaitable[None]: ...\n    @abstractmethod\n    def __aiter__(self) -> AsyncGenerator[_T_co, _T_contra]: ...\n    @property\n    def ag_await(self) -> Any: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    @abstractmethod\n    def __contains__(self, __x: object) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n_Collection = Collection[_T_co]\n\nclass Sequence(_Collection[_T_co], Reversible[_T_co], Generic[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, x: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T], Generic[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, i: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, s: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, i: int, o: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, i: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = ...) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, x: Iterable[_T]) -> MutableSequence[_T]: ...\n\nclass AbstractSet(_Collection[_T_co], Generic[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    # Mixin methods\n    def __le__(self, s: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, s: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, s: AbstractSet[Any]) -> bool: ...\n    def __and__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def __sub__(self, s: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, s: AbstractSet[_T]) -> AbstractSet[Union[_T_co, _T]]: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T], Generic[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __iand__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n    def __ixor__(self, s: AbstractSet[_S]) -> MutableSet[Union[_T, _S]]: ...\n    def __isub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...\n\nclass MappingView(Sized):\n    def __init__(self, mapping: Mapping[Any, Any]) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[Tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[Tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[Tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[Tuple[_KT_co, _VT_co], _T]]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co], Generic[_KT_co]):\n    def __init__(self, mapping: Mapping[_KT_co, Any]) -> None: ...  # undocumented\n    def __and__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rand__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __ror__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __sub__(self, o: Iterable[Any]) -> Set[_KT_co]: ...\n    def __rsub__(self, o: Iterable[_T]) -> Set[_T]: ...\n    def __xor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n    def __rxor__(self, o: Iterable[_T]) -> Set[Union[_KT_co, _T]]: ...\n\nclass ValuesView(MappingView, Iterable[_VT_co], Generic[_VT_co]):\n    def __init__(self, mapping: Mapping[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, o: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n    if sys.version_info >= (3, 8):\n        def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@runtime_checkable\nclass ContextManager(Protocol[_T_co]):\n    def __enter__(self) -> _T_co: ...\n    def __exit__(\n        self,\n        __exc_type: Optional[Type[BaseException]],\n        __exc_value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> Optional[bool]: ...\n\n@runtime_checkable\nclass AsyncContextManager(Protocol[_T_co]):\n    def __aenter__(self) -> Awaitable[_T_co]: ...\n    def __aexit__(\n        self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Awaitable[Optional[bool]]: ...\n\nclass Mapping(_Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https: //github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, k: _KT) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT) -> Optional[_VT_co]: ...\n    @overload\n    def get(self, key: _KT, default: Union[_VT_co, _T]) -> Union[_VT_co, _T]: ...\n    def items(self) -> AbstractSet[Tuple[_KT, _VT_co]]: ...\n    def keys(self) -> AbstractSet[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, o: object) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT], Generic[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, k: _KT, v: _VT) -> None: ...\n    @abstractmethod\n    def __delitem__(self, v: _KT) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: Union[_VT, _T] = ...) -> Union[_VT, _T]: ...\n    def popitem(self) -> Tuple[_KT, _VT]: ...\n    def setdefault(self, key: _KT, default: _VT = ...) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[Tuple[_KT, _VT], W] is a subclass of Iterable[Tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and Tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    @overload\n    def update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING = True\n\nclass IO(Iterator[AnyStr], Generic[AnyStr]):\n    # TODO use abstract properties\n    @property\n    def mode(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = ...) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = ...) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = ...) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: Optional[int] = ...) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    def write(self, s: AnyStr) -> int: ...\n    @abstractmethod\n    def writelines(self, lines: Iterable[AnyStr]) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[TracebackType]\n    ) -> Optional[bool]: ...\n\nclass BinaryIO(IO[bytes]):\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # TODO use abstractproperty\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> Optional[str]: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nclass ByteString(Sequence[int], metaclass=ABCMeta): ...\n\nclass Match(Generic[AnyStr]):\n    pos: int\n    endpos: int\n    lastindex: Optional[int]\n    lastgroup: Optional[AnyStr]\n    string: AnyStr\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    re: Pattern[AnyStr]\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, __group: _Literal[0] = ...) -> AnyStr: ...\n    @overload\n    def group(self, __group: str | int) -> AnyStr | Any: ...\n    @overload\n    def group(self, __group1: str | int, __group2: str | int, *groups: str | int) -> Tuple[AnyStr | Any, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> Tuple[AnyStr | Any, ...]: ...\n    @overload\n    def groups(self, default: _T) -> Tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | Any]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, __group: Union[int, str] = ...) -> int: ...\n    def end(self, __group: Union[int, str] = ...) -> int: ...\n    def span(self, __group: Union[int, str] = ...) -> Tuple[int, int]: ...\n    @property\n    def regs(self) -> Tuple[Tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, __key: _Literal[0]) -> AnyStr: ...\n    @overload\n    def __getitem__(self, __key: int | str) -> AnyStr | Any: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\nclass Pattern(Generic[AnyStr]):\n    flags: int\n    groupindex: Mapping[str, int]\n    groups: int\n    pattern: AnyStr\n    def search(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def match(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def fullmatch(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Optional[Match[AnyStr]]: ...\n    def split(self, string: AnyStr, maxsplit: int = ...) -> list[AnyStr]: ...\n    def findall(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> list[Any]: ...\n    def finditer(self, string: AnyStr, pos: int = ..., endpos: int = ...) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self, repl: AnyStr, string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def sub(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> AnyStr: ...\n    @overload\n    def subn(self, repl: AnyStr, string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    @overload\n    def subn(self, repl: Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = ...) -> Tuple[AnyStr, int]: ...\n    if sys.version_info >= (3, 9):\n        def __class_getitem__(cls, item: Any) -> GenericAlias: ...\n\n# Functions\n\nif sys.version_info >= (3, 7):\n    _get_type_hints_obj_allowed_types = Union[\n        object,\n        Callable[..., Any],\n        FunctionType,\n        BuiltinFunctionType,\n        MethodType,\n        ModuleType,\n        WrapperDescriptorType,\n        MethodWrapperType,\n        MethodDescriptorType,\n    ]\nelse:\n    _get_type_hints_obj_allowed_types = Union[\n        object, Callable[..., Any], FunctionType, BuiltinFunctionType, MethodType, ModuleType,\n    ]\n\nif sys.version_info >= (3, 9):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: Optional[Dict[str, Any]] = ...,\n        localns: Optional[Dict[str, Any]] = ...,\n        include_extras: bool = ...,\n    ) -> Dict[str, Any]: ...\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types, globalns: Optional[Dict[str, Any]] = ..., localns: Optional[Dict[str, Any]] = ...\n    ) -> Dict[str, Any]: ...\n\nif sys.version_info >= (3, 8):\n    def get_origin(tp: Any) -> Optional[Any]: ...\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n\n@overload\ndef cast(typ: Type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\n# Type constructors\n\n# NamedTuple is special-cased in the type checker\nclass NamedTuple(Tuple[Any, ...]):\n    _field_types: collections.OrderedDict[str, Type[Any]]\n    _field_defaults: Dict[str, Any] = ...\n    _fields: Tuple[str, ...]\n    _source: str\n    def __init__(self, typename: str, fields: Iterable[Tuple[str, Any]] = ..., **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls: Type[_T], iterable: Iterable[Any]) -> _T: ...\n    if sys.version_info >= (3, 8):\n        def _asdict(self) -> Dict[str, Any]: ...\n    else:\n        def _asdict(self) -> collections.OrderedDict[str, Any]: ...\n    def _replace(self: _T, **kwargs: Any) -> _T: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __or__(self: _T, __value: _T) -> _T: ...\n    def __ior__(self: _T, __value: _T) -> _T: ...\n\ndef NewType(name: str, tp: Type[_T]) -> Type[_T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _F) -> _F: ...\n\nif sys.version_info >= (3, 7):\n    class ForwardRef:\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Optional[Any]\n        __forward_is_argument__: bool\n        def __init__(self, arg: str, is_argument: bool = ...) -> None: ...\n        def _evaluate(self, globalns: Optional[Dict[str, Any]], localns: Optional[Dict[str, Any]]) -> Optional[Any]: ...\n        def __eq__(self, other: Any) -> bool: ...\n        def __hash__(self) -> int: ...\n        def __repr__(self) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: Any) -> bool: ...\n",
    "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport sys\nfrom typing import (\n    TYPE_CHECKING as TYPE_CHECKING,\n    Any,\n    AsyncContextManager as AsyncContextManager,\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    ContextManager as ContextManager,\n    Coroutine as Coroutine,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    ItemsView,\n    KeysView,\n    Mapping,\n    NewType as NewType,\n    NoReturn as NoReturn,\n    Text as Text,\n    Tuple,\n    Type as Type,\n    TypeVar,\n    ValuesView,\n    _Alias,\n    overload as overload,\n)\n\n_T = TypeVar(\"_T\")\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = TypeVar(\"_TC\", bound=Type[object])\n\nclass _SpecialForm:\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nProtocol: _SpecialForm = ...\nFinal: _SpecialForm = ...\n\ndef final(f: _F) -> _F: ...\n\nLiteral: _SpecialForm = ...\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    def copy(self: _T) -> _T: ...\n    # Using NoReturn so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: NoReturn, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: NoReturn, default: _T = ...) -> object: ...  # type: ignore\n    def update(self: _T, __m: _T) -> None: ...\n    def items(self) -> ItemsView[str, object]: ...\n    def keys(self) -> KeysView[str]: ...\n    def values(self) -> ValuesView[object]: ...\n    def __delitem__(self, k: NoReturn) -> None: ...\n\n# TypedDict is a (non-subscriptable) special form.\nTypedDict: object = ...\n\nOrderedDict = _Alias()\n\ndef get_type_hints(\n    obj: Callable[..., Any],\n    globalns: dict[str, Any] | None = ...,\n    localns: dict[str, Any] | None = ...,\n    include_extras: bool = ...,\n) -> dict[str, Any]: ...\n\nif sys.version_info >= (3, 7):\n    def get_args(tp: Any) -> Tuple[Any, ...]: ...\n    def get_origin(tp: Any) -> Any | None: ...\n\nAnnotated: _SpecialForm = ...\n_AnnotatedAlias: Any = ...  # undocumented\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __index__(self) -> int: ...\n\n# PEP 612 support for Python < 3.9\nif sys.version_info >= (3, 10):\n    from typing import Concatenate as Concatenate, ParamSpec as ParamSpec, TypeAlias as TypeAlias, TypeGuard as TypeGuard\nelse:\n    class ParamSpecArgs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpecKwargs:\n        __origin__: ParamSpec\n        def __init__(self, origin: ParamSpec) -> None: ...\n    class ParamSpec:\n        __name__: str\n        __bound__: Type[Any] | None\n        __covariant__: bool\n        __contravariant__: bool\n        def __init__(\n            self, name: str, *, bound: None | Type[Any] | str = ..., contravariant: bool = ..., covariant: bool = ...\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n    Concatenate: _SpecialForm = ...\n    TypeAlias: _SpecialForm = ...\n    TypeGuard: _SpecialForm = ...\n",
    "/typeshed/stdlib/uarray.pyi": "from array import *\n",
    "/typeshed/stdlib/ucollections.pyi": "from collections import *\n",
    "/typeshed/stdlib/uerrno.pyi": "from errno import *\n",
    "/typeshed/stdlib/urandom.pyi": "from random import *\n",
    "/typeshed/stdlib/ustruct.pyi": "from struct import *\n",
    "/typeshed/stdlib/usys.pyi": "from sys import *\n",
    "/typeshed/stdlib/utime.pyi": "from time import *\n",
    "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport array\nimport sys\nfrom os import PathLike\nfrom typing import AbstractSet, Any, Container, Iterable, Protocol, Tuple, TypeVar, Union\nfrom typing_extensions import Literal, final\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Use for \"self\" annotations:\n#   def __enter__(self: Self) -> Self: ...\nSelf = TypeVar(\"Self\")  # noqa Y001\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, __x: _T) -> _T: ...\n\nclass SupportsLessThan(Protocol):\n    def __lt__(self, __other: Any) -> bool: ...\n\nSupportsLessThanT = TypeVar(\"SupportsLessThanT\", bound=SupportsLessThan)  # noqa: Y001\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, __other: _T_contra) -> _T_co: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, __k: int) -> _T_co: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[Tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, __k: _KT) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Container[_KT_contra], Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, __k: _KT_contra) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(SupportsGetItem[_KT_contra, _VT], Protocol[_KT_contra, _VT]):\n    def __setitem__(self, __k: _KT_contra, __v: _VT) -> None: ...\n    def __delitem__(self, __v: _KT_contra) -> None: ...\n\n# These aliases are simple strings in Python 2.\nStrPath = Union[str, PathLike[str]]  # stable\nBytesPath = Union[bytes, PathLike[bytes]]  # stable\nStrOrBytesPath = Union[str, bytes, PathLike[str], PathLike[bytes]]  # stable\n\nOpenTextModeUpdating = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode = Union[OpenTextModeUpdating, OpenTextModeWriting, OpenTextModeReading]\nOpenBinaryModeUpdating = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode = Union[OpenBinaryModeUpdating, OpenBinaryModeReading, OpenBinaryModeWriting]\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor = int  # stable\nFileDescriptorLike = Union[int, HasFileno]  # stable\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, __length: int = ...) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, __s: _T_contra) -> Any: ...\n\nReadableBuffer = Union[bytes, bytearray, memoryview, array.array[Any]]  # stable\nWriteableBuffer = Union[bytearray, memoryview, array.array[Any]]  # stable\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n",
    "/typeshed/stdlib/microbit/__init__.pyi": "\"\"\"Piny, obrazy, d\u017awi\u0119ki, temperatura i g\u0142o\u015bno\u015b\u0107.\"\"\"\nfrom typing import Any, Callable, List, Optional, Tuple, Union, overload\nfrom _typeshed import ReadableBuffer\nfrom . import accelerometer as accelerometer\nfrom . import audio as audio\nfrom . import compass as compass\nfrom . import display as display\nfrom . import i2c as i2c\nfrom . import microphone as microphone\nfrom . import speaker as speaker\nfrom . import spi as spi\nfrom . import uart as uart\n\ndef run_every(callback: Optional[Callable[[], None]]=None, days: int=0, h: int=0, min: int=0, s: int=0, ms: int=0) -> Callable[[Callable[[], None]], Callable[[], None]]:\n    \"\"\"Zaplanuj uruchomienie funkcji w przedziale okre\u015blonym przez argumenty czasu **tylko V2**.\n\nExample: ``run_every(my_logging, min=5)``\n\n``run_every`` can be used in two ways:\n\nAs a Decorator - placed on top of the function to schedule. For example::\n\n    @run_every(h=1, min=20, s=30, ms=50)\n    def my_function():\n        # Do something here\n\nAs a Function - passing the callback as a positional argument. For example::\n\n    def my_function():\n        # Do something here\n    run_every(my_function, s=30)\n\nEach argument corresponds to a different time unit and they are additive.\nSo ``run_every(min=1, s=30)`` schedules the callback every minute and a half.\n\nWhen an exception is thrown inside the callback function it deschedules the\nfunction. To avoid this you can catch exceptions with ``try/except``.\n\n:param callback: Funkcja wywo\u0142ywana w podanym przedziale. Pomi\u0144, je\u015bli u\u017cywasz jako dekorator.\n:param days: Ustawia oznaczenie dnia dla harmonogramu.\n:param h: Ustawia znak godziny dla harmonogramu.\n:param min: Ustawia znak minuty dla harmonogramu.\n:param s: Ustawia znak sekundy dla harmonogramu.\n:param ms: Ustawia znak milisekundy dla harmonogramu.\"\"\"\n\ndef panic(n: int) -> None:\n    \"\"\"Wejd\u017a w tryb paniki.\n\nExample: ``panic(127)``\n\n:param n: Dowolna liczba ca\u0142kowita <= 255 dla wskazania statusu.\n\nRequires restart.\"\"\"\n\ndef reset() -> None:\n    \"\"\"Uruchom ponownie p\u0142ytk\u0119.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[int, int]) -> int:\n    \"\"\"Konwertuje warto\u015b\u0107 z zakresu do zakresu liczb ca\u0142kowitych.\n\nExample: ``volume = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))``\n\nFor example, to convert an accelerometer X value to a speaker volume.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\n\n    temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))\n\n:param value: Liczba do konwersji.\n:param from_: Krotka do zdefiniowania zakresu dla konwersji z.\n:param to: Krotka do zdefiniowania zakresu dla konwersji do.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\n@overload\ndef scale(value: float, from_: Tuple[float, float], to: Tuple[float, float]) -> float:\n    \"\"\"Konwertuje warto\u015b\u0107 z zakresu do zakresu o zmiennopozycyjnego.\n\nExample: ``temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))``\n\nFor example, to convert temperature from a Celsius scale to Fahrenheit.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\nIf they are both integers (i.e ``10``), it will return an integer::\n\n    returns_int = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))\n\n:param value: Liczba do konwersji.\n:param from_: Krotka do zdefiniowania zakresu dla konwersji z.\n:param to: Krotka do zdefiniowania zakresu, na jaki konwertowa\u0107.\n:return: The ``value`` converted to the ``to`` range.\"\"\"\n\ndef sleep(n: float) -> None:\n    \"\"\"Poczekaj ``n`` milisekund.\n\nExample: ``sleep(1000)``\n\n:param n: Liczba milisekund oczekiwania\n\nOne second is 1000 milliseconds, so::\n\n    microbit.sleep(1000)\n\nwill pause the execution for one second.\"\"\"\n\ndef running_time() -> int:\n    \"\"\"Uzyskaj czas pracy p\u0142ytki.\n\n:return: The number of milliseconds since the board was switched on or restarted.\"\"\"\n\ndef temperature() -> int:\n    \"\"\"Uzyskaj temperatur\u0119 micro:bita w stopniach Celsjusza.\"\"\"\n\ndef set_volume(v: int) -> None:\n    \"\"\"Ustawia g\u0142o\u015bno\u015b\u0107.\n\nExample: ``set_volume(127)``\n\n:param v: warto\u015b\u0107 mi\u0119dzy 0 (niska) a 255 (wysoka).\n\nOut of range values will be clamped to 0 or 255.\n\n**V2** only.\"\"\"\n    ...\n\nclass Button:\n    \"\"\"Klasa dla przycisk\u00f3w ``button_a`` i ``button_b``.\"\"\"\n\n    def is_pressed(self) -> bool:\n        \"\"\"Sprawd\u017a, czy przycisk jest naci\u015bni\u0119ty.\n\n:return: ``True`` if the specified button ``button`` is pressed, and ``False`` otherwise.\"\"\"\n        ...\n\n    def was_pressed(self) -> bool:\n        \"\"\"Sprawd\u017a, czy przycisk zosta\u0142 naci\u015bni\u0119ty od momentu uruchomienia urz\u0105dzenia lub kiedy ta metoda zosta\u0142a wywo\u0142ana.\n\nCalling this method will clear the press state so\nthat the button must be pressed again before this method will return\n``True`` again.\n\n:return: ``True`` if the specified button ``button`` was pressed, and ``False`` otherwise\"\"\"\n        ...\n\n    def get_presses(self) -> int:\n        \"\"\"Pobierz sum\u0119 naci\u015bni\u0119\u0107 przycisk\u00f3w i zresetuje t\u0119 sum\u0119\ndo zera przed powrotem.\n\n:return: The number of presses since the device started or the last time this method was called\"\"\"\n        ...\nbutton_a: Button\n\"\"\"Lewy przycisk ``Button`` obiekt.\"\"\"\nbutton_b: Button\n\"\"\"Prawy przycisk ``Button`` obiekt.\"\"\"\n\nclass MicroBitDigitalPin:\n    \"\"\"Cyfrowy pin.\n\nSome pins support analog and touch features using the ``MicroBitAnalogDigitalPin`` and ``MicroBitTouchPin`` subclasses.\"\"\"\n    NO_PULL: int\n    PULL_UP: int\n    PULL_DOWN: int\n\n    def read_digital(self) -> int:\n        \"\"\"Uzyskaj cyfrow\u0105 warto\u015b\u0107 pinu.\n\nExample: ``value = pin0.read_digital()``\n\n:return: 1 if the pin is high, and 0 if it's low.\"\"\"\n        ...\n\n    def write_digital(self, value: int) -> None:\n        \"\"\"Ustaw cyfrow\u0105 warto\u015b\u0107 pinu.\n\nExample: ``pin0.write_digital(1)``\n\n:param value: 1, aby ustawi\u0107 wysok\u0105 warto\u015b\u0107 pinu lub 0, aby ustawi\u0107 nisk\u0105 warto\u015b\u0107 pinu\"\"\"\n        ...\n\n    def set_pull(self, value: int) -> None:\n        \"\"\"Ustaw stan ci\u0105gni\u0119cia na jedn\u0105 z trzech mo\u017cliwych warto\u015bci: ``PULL_UP``, ``PULL_DOWN`` lub ``NO_PULL``.\n\nExample: ``pin0.set_pull(pin0.PULL_UP)``\n\n:param value: Stan ci\u0105gni\u0119cia z odpowiedniego pinu, np. ``pin0.PULL_UP``.\"\"\"\n        ...\n\n    def get_pull(self) -> int:\n        \"\"\"Uzyskaj stan cigni\u0119cia na pinie.\n\nExample: ``pin0.get_pull()``\n\n:return: ``NO_PULL``, ``PULL_DOWN``, or ``PULL_UP``\n\nThese are set using the ``set_pull()`` method or automatically configured\nwhen a pin mode requires it.\"\"\"\n        ...\n\n    def get_mode(self) -> str:\n        \"\"\"Zwraca tryb pinu.\n\nExample: ``pin0.get_mode()``\n\nWhen a pin is used for a specific function, like\nwriting a digital value, or reading an analog value, the pin mode\nchanges.\n\n:return: ``\"unused\"``, ``\"analog\"``, ``\"read_digital\"``, ``\"write_digital\"``, ``\"display\"``, ``\"button\"``, ``\"music\"``, ``\"audio\"``, ``\"touch\"``, ``\"i2c\"``, or ``\"spi\"``\"\"\"\n        ...\n\n    def write_analog(self, value: int) -> None:\n        \"\"\"Wysy\u0142aj sygna\u0142 PWM na pin, z cyklem pracy proporcjonalnym do ``value``.\n\nExample: ``pin0.write_analog(254)``\n\n:param value: Liczba ca\u0142kowita lub liczba zmiennopozycyjna mi\u0119dzy 0 (0% cyklu pracy) a 1023 (100% cyklu pracy).\"\"\"\n\n    def set_analog_period(self, period: int) -> None:\n        \"\"\"Ustaw okres wyj\u015bcia sygna\u0142u PWM na ``period`` w milisekundach.\n\nExample: ``pin0.set_analog_period(10)``\n\n:param period: Okres w milisekundach z minimaln\u0105 poprawn\u0105 warto\u015bci\u0105 1 ms.\"\"\"\n\n    def set_analog_period_microseconds(self, period: int) -> None:\n        \"\"\"Ustaw okres wyj\u015bcia sygna\u0142u PWM na ``period`` w mikrosekundach. (ustaw mikrosekundy okresu analogowego)\n\nExample: ``pin0.set_analog_period_microseconds(512)``\n\n:param period: Okres w mikrosekundach z minimaln\u0105 poprawn\u0105 warto\u015bci\u0105 256\u00b5s.\"\"\"\n\nclass MicroBitAnalogDigitalPin(MicroBitDigitalPin):\n    \"\"\"Pin z funkcjami analogowymi i cyfrowymi.\"\"\"\n\n    def read_analog(self) -> int:\n        \"\"\"Odczytaj napi\u0119cie przy\u0142o\u017cone do pinu.\n\nExample: ``pin0.read_analog()``\n\n:return: An integer between 0 (meaning 0V) and 1023 (meaning 3.3V).\"\"\"\n\nclass MicroBitTouchPin(MicroBitAnalogDigitalPin):\n    \"\"\"Pin z funkcjami analogowymi, cyfrowymi i dotykowymi.\"\"\"\n    CAPACITIVE: int\n    RESISTIVE: int\n\n    def is_touched(self) -> bool:\n        \"\"\"Sprawd\u017a, czy pin zosta\u0142 dotkni\u0119ty.\n\nExample: ``pin0.is_touched()``\n\nThe default touch mode for the pins on the edge connector is ``resistive``.\nThe default for the logo pin **V2** is ``capacitive``.\n\n**Resistive touch**\nThis test is done by measuring how much resistance there is between the\npin and ground.  A low resistance gives a reading of ``True``.  To get\na reliable reading using a finger you may need to touch the ground pin\nwith another part of your body, for example your other hand.\n\n**Capacitive touch**\nThis test is done by interacting with the electric field of a capacitor\nusing a finger as a conductor. `Capacitive touch\n<https://www.allaboutcircuits.com/technical-articles/introduction-to-capacitive-touch-sensing>`_\ndoes not require you to make a ground connection as part of a circuit.\n\n:return: ``True`` if the pin is being touched with a finger, otherwise return ``False``.\"\"\"\n        ...\n\n    def set_touch_mode(self, value: int) -> None:\n        \"\"\"Ustaw tryb dotykowy dla pinu.\n\nExample: ``pin0.set_touch_mode(pin0.CAPACITIVE)``\n\nThe default touch mode for the pins on the edge connector is\n``resistive``. The default for the logo pin **V2** is ``capacitive``.\n\n:param value: ``CAPACITIVE`` lub ``RESISTIVE`` z odpowiedniego pinu.\"\"\"\n        ...\npin0: MicroBitTouchPin\n\"\"\"Pin z funkcjami cyfrow\u0105, analogow\u0105 i dotykow\u0105.\"\"\"\npin1: MicroBitTouchPin\n\"\"\"Pin z funkcjami cyfrow\u0105, analogow\u0105 i dotykow\u0105.\"\"\"\npin2: MicroBitTouchPin\n\"\"\"Pin z funkcjami cyfrow\u0105, analogow\u0105 i dotykow\u0105.\"\"\"\npin3: MicroBitAnalogDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi i analogowymi.\"\"\"\npin4: MicroBitAnalogDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi i analogowymi.\"\"\"\npin5: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin6: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin7: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin8: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin9: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin10: MicroBitAnalogDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi i analogowymi.\"\"\"\npin11: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin12: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin13: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin14: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin15: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin16: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin19: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin20: MicroBitDigitalPin\n\"\"\"Pin z funkcjami cyfrowymi.\"\"\"\npin_logo: MicroBitTouchPin\n\"\"\"Wra\u017cliwy na dotyk pin z logo z przodu micro:bita, kt\u00f3ry domy\u015blnie jest ustawiony na pojemno\u015bciowy tryb dotykowy.\"\"\"\npin_speaker: MicroBitAnalogDigitalPin\n\"\"\"Pin adresuj\u0105cy g\u0142o\u015bnik micro:bita.\n\nThis API is intended only for use in Pulse-Width Modulation pin operations e.g. pin_speaker.write_analog(128).\n\"\"\"\n\nclass Image:\n    \"\"\"Obraz wy\u015bwietlany na wy\u015bwietlaczu LED micro:bita.\n\nGiven an image object it's possible to display it via the ``display`` API::\n\n    display.show(Image.HAPPY)\"\"\"\n    HEART: Image\n    \"\"\"Obraz serca.\"\"\"\n    HEART_SMALL: Image\n    \"\"\"Obraz ma\u0142ego serca.\"\"\"\n    HAPPY: Image\n    \"\"\"Obraz szcz\u0119\u015bliwej twarzy.\"\"\"\n    SMILE: Image\n    \"\"\"Obraz u\u015bmiechni\u0119tej twarzy.\"\"\"\n    SAD: Image\n    \"\"\"Obraz smutnej twarzy.\"\"\"\n    CONFUSED: Image\n    \"\"\"Obraz zmieszanej twarzy.\"\"\"\n    ANGRY: Image\n    \"\"\"Obraz z\u0142ej twarzy.\"\"\"\n    ASLEEP: Image\n    \"\"\"Obraz \u015bpi\u0105cej twarzy.\"\"\"\n    SURPRISED: Image\n    \"\"\"Obraz zaskoczonej twarzy.\"\"\"\n    SILLY: Image\n    \"\"\"Obraz g\u0142upiej twarzy.\"\"\"\n    FABULOUS: Image\n    \"\"\"Obraz twarzy w okularach przeciws\u0142onecznych.\"\"\"\n    MEH: Image\n    \"\"\"Obraz niewzruszonej twarzy.\"\"\"\n    YES: Image\n    \"\"\"Haczyk na TAK.\"\"\"\n    NO: Image\n    \"\"\"Krzy\u017cyk na NIE.\"\"\"\n    CLOCK12: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 12.\"\"\"\n    CLOCK11: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 11.\"\"\"\n    CLOCK10: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 10.\"\"\"\n    CLOCK9: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 9.\"\"\"\n    CLOCK8: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 8.\"\"\"\n    CLOCK7: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 7.\"\"\"\n    CLOCK6: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 6.\"\"\"\n    CLOCK5: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 5.\"\"\"\n    CLOCK4: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 4.\"\"\"\n    CLOCK3: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 3.\"\"\"\n    CLOCK2: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 2.\"\"\"\n    CLOCK1: Image\n    \"\"\"Obraz z lini\u0105 wskazuj\u0105c\u0105 na godzin\u0119 1.\"\"\"\n    ARROW_N: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej p\u00f3\u0142noc.\"\"\"\n    ARROW_NE: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej p\u00f3\u0142nocny wsch\u00f3d.\"\"\"\n    ARROW_E: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej wsch\u00f3d.\"\"\"\n    ARROW_SE: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej po\u0142udniowy wsch\u00f3d.\"\"\"\n    ARROW_S: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej po\u0142udnie.\"\"\"\n    ARROW_SW: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej po\u0142udniowy zach\u00f3d.\"\"\"\n    ARROW_W: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej zach\u00f3d.\"\"\"\n    ARROW_NW: Image\n    \"\"\"Obraz strza\u0142ki wskazuj\u0105cej p\u00f3\u0142nocny zach\u00f3d.\"\"\"\n    TRIANGLE: Image\n    \"\"\"Obraz tr\u00f3jk\u0105ta skierowanego do g\u00f3ry.\"\"\"\n    TRIANGLE_LEFT: Image\n    \"\"\"Obraz tr\u00f3jk\u0105ta w lewym rogu.\"\"\"\n    CHESSBOARD: Image\n    \"\"\"Diody LED \u015bwiec\u0105 naprzemiennie w uk\u0142adzie szachownicy.\"\"\"\n    DIAMOND: Image\n    \"\"\"Obraz diamentu.\"\"\"\n    DIAMOND_SMALL: Image\n    \"\"\"Obraz ma\u0142ego diamentu.\"\"\"\n    SQUARE: Image\n    \"\"\"Obraz kwadratu.\"\"\"\n    SQUARE_SMALL: Image\n    \"\"\"Obraz ma\u0142ego kwadratu.\"\"\"\n    RABBIT: Image\n    \"\"\"Obraz kr\u00f3lika.\"\"\"\n    COW: Image\n    \"\"\"Obraz krowy.\"\"\"\n    MUSIC_CROTCHET: Image\n    \"\"\"Obraz \u0107wier\u0107nuty.\"\"\"\n    MUSIC_QUAVER: Image\n    \"\"\"Obraz nuty \u00f3semki.\"\"\"\n    MUSIC_QUAVERS: Image\n    \"\"\"Obraz pary nut \u00f3semek.\"\"\"\n    PITCHFORK: Image\n    \"\"\"Obraz kamertonu.\"\"\"\n    XMAS: Image\n    \"\"\"Obraz choinki.\"\"\"\n    PACMAN: Image\n    \"\"\"Obrazek postaci arcade Pac-Man\"\"\"\n    TARGET: Image\n    \"\"\"Obraz celu.\"\"\"\n    TSHIRT: Image\n    \"\"\"Obraz t-shirt.\"\"\"\n    ROLLERSKATE: Image\n    \"\"\"Obraz Rollerskate.\"\"\"\n    DUCK: Image\n    \"\"\"Obraz kaczki.\"\"\"\n    HOUSE: Image\n    \"\"\"Obraz domu.\"\"\"\n    TORTOISE: Image\n    \"\"\"Obraz \u017c\u00f3\u0142wia.\"\"\"\n    BUTTERFLY: Image\n    \"\"\"Obraz motyla.\"\"\"\n    STICKFIGURE: Image\n    \"\"\"Obraz przyklejonej figury.\"\"\"\n    GHOST: Image\n    \"\"\"Obraz ducha.\"\"\"\n    SWORD: Image\n    \"\"\"Obraz miecza.\"\"\"\n    GIRAFFE: Image\n    \"\"\"Obraz \u017cyrafy.\"\"\"\n    SKULL: Image\n    \"\"\"Obraz czaszki.\"\"\"\n    UMBRELLA: Image\n    \"\"\"Obraz parasola.\"\"\"\n    SNAKE: Image\n    \"\"\"Obraz w\u0119\u017ca.\"\"\"\n    SCISSORS: Image\n    \"\"\"Obraz no\u017cyczek.\"\"\"\n    ALL_CLOCKS: List[Image]\n    \"\"\"Lista zawieraj\u0105ca wszystkie obrazy CLOCK_ po kolei.\"\"\"\n    ALL_ARROWS: List[Image]\n    \"\"\"Lista zawieraj\u0105ca wszystkie obrazy ARROW_ po kolei.\"\"\"\n\n    @overload\n    def __init__(self, string: str) -> None:\n        \"\"\"Utw\u00f3rz obraz z \u0142a\u0144cucha opisuj\u0105cego, kt\u00f3re diody LED s\u0105 zapalone.\n\n``string`` has to consist of digits 0-9 arranged into lines,\ndescribing the image, for example::\n\n    image = Image(\"90009:\"\n                  \"09090:\"\n                  \"00900:\"\n                  \"09090:\"\n                  \"90009\")\n\nwill create a 5\u00d75 image of an X. The end of a line is indicated by a\ncolon. It's also possible to use newlines (\\\\n) insead of the colons.\n\n:param string: \u0141a\u0144cuch opisuj\u0105cy obraz.\"\"\"\n        ...\n\n    @overload\n    def __init__(self, width: int=5, height: int=5, buffer: ReadableBuffer=None) -> None:\n        \"\"\"Utw\u00f3rz pusty obraz z ``width`` kolumnami i ``height`` wierszami.\n\n:param width: Opcjonalna szeroko\u015b\u0107 obrazu\n:param height: Opcjonalna wysoko\u015b\u0107 obrazu\n:param buffer: Opcjonalna tablica lub bajty ``width``\u00d7``height`` liczb ca\u0142kowitych w zakresie 0-9 do zainicjowania obrazu\n\nExamples::\n\n    Image(2, 2, b'\\x08\\x08\\x08\\x08')\n    Image(2, 2, bytearray([9,9,9,9]))\n\nThese create 2 x 2 pixel images at full brightness.\"\"\"\n        ...\n\n    def width(self) -> int:\n        \"\"\"Ustal liczb\u0119 kolumn\n\n:return: The number of columns in the image\"\"\"\n        ...\n\n    def height(self) -> int:\n        \"\"\"Uzyskaj liczb\u0119 wierszy\n\n:return: The number of rows in the image\"\"\"\n        ...\n\n    def set_pixel(self, x: int, y: int, value: int) -> None:\n        \"\"\"Ustaw jasno\u015b\u0107 piksela.\n\nExample: ``my_image.set_pixel(0, 0, 9)``\n\n:param x: Numer kolumny\n:param y: Numer wiersza\n:param value: Jasno\u015b\u0107 jako liczba ca\u0142kowita mi\u0119dzy 0 (ciemny) i 9 (jasna)\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def get_pixel(self, x: int, y: int) -> int:\n        \"\"\"uzyskaj jasno\u015b\u0107 piksela.\n\nExample: ``my_image.get_pixel(0, 0)``\n\n:param x: Numer kolumny\n:param y: Numer wiersza\n:return: The brightness as an integer between 0 and 9.\"\"\"\n        ...\n\n    def shift_left(self, n: int) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz przesuwaj\u0105c ten obraz w lewo.\n\nExample: ``Image.HEART_SMALL.shift_left(1)``\n\n:param n: Liczba kolumn do przesuni\u0119cia\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_right(self, n: int) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz, przesuwaj\u0105c ten obraz w prawo.\n\nExample: ``Image.HEART_SMALL.shift_right(1)``\n\n:param n: Liczba kolumn do przesuni\u0119cia\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_up(self, n: int) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz, przesuwaj\u0105c obraz do g\u00f3ry.\n\nExample: ``Image.HEART_SMALL.shift_up(1)``\n\n:param n: Liczba wierszy do przesuni\u0119cia o\n:return: The shifted image\"\"\"\n        ...\n\n    def shift_down(self, n: int) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz, przesuwaj\u0105c obraz do do\u0142u.\n\nExample: ``Image.HEART_SMALL.shift_down(1)``\n\n:param n: Liczba wierszy do przesuni\u0119cia o\n:return: The shifted image\"\"\"\n        ...\n\n    def crop(self, x: int, y: int, w: int, h: int) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz przez przyci\u0119cie zdj\u0119cia.\n\nExample: ``Image.HEART.crop(1, 1, 3, 3)``\n\n:param x: Kolumna przesuni\u0119cia przyci\u0119cia\n:param y: Wiersz przesuni\u0119cia przyci\u0119cia\n:param w: Szeroko\u015b\u0107 przyci\u0119cia\n:param h: Wysoko\u015b\u0107 przyci\u0119cia\n:return: The new image\"\"\"\n        ...\n\n    def copy(self) -> Image:\n        \"\"\"Utw\u00f3rz dok\u0142adn\u0105 kopi\u0119 obrazu.\n\nExample: ``Image.HEART.copy()``\n\n:return: The new image\"\"\"\n        ...\n\n    def invert(self) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz przez odwr\u00f3cenie jasno\u015bci pikseli w obrazie \u017ar\u00f3d\u0142owym.\n\nExample: ``Image.SMALL_HEART.invert()``\n\n:return: The new image.\"\"\"\n        ...\n\n    def fill(self, value: int) -> None:\n        \"\"\"Ustaw jasno\u015b\u0107 wszystkich pikseli obrazka.\n\nExample: ``my_image.fill(5)``\n\n:param value: Nowa jasno\u015b\u0107 jako liczba mi\u0119dzy 0 (ciemny) a 9 (jasny).\n\nThis method will raise an exception when called on any of the built-in\nread-only images, like ``Image.HEART``.\"\"\"\n        ...\n\n    def blit(self, src: Image, x: int, y: int, w: int, h: int, xdest: int=0, ydest: int=0) -> None:\n        \"\"\"Skopiuj obszar z innego obrazu na ten obraz.\n\nExample: ``my_image.blit(Image.HEART, 1, 1, 3, 3, 1, 1)``\n\n:param src: Zdj\u0119cie \u017ar\u00f3d\u0142owe\n:param x: Pocz\u0105tkowe przesuni\u0119cie kolumny w obrazie \u017ar\u00f3d\u0142owym\n:param y: Pocz\u0105tkowe przesuni\u0119cie wiersza na obrazie \u017ar\u00f3d\u0142owym\n:param w: Liczba kolumn do skopiowania\n:param h: Liczba wierszy do skopiowania\n:param xdest: Przesuni\u0119cie kolumny do modyfikacji na tym obrazie\n:param ydest: Przesuni\u0119cie wiersza do modyfikacji na tym obrazie\n\nPixels outside the source image are treated as having a brightness of 0.\n\n``shift_left()``, ``shift_right()``, ``shift_up()``, ``shift_down()``\nand ``crop()`` can are all implemented by using ``blit()``.\n\nFor example, img.crop(x, y, w, h) can be implemented as::\n\n    def crop(self, x, y, w, h):\n        res = Image(w, h)\n        res.blit(self, x, y, w, h)\n        return res\"\"\"\n        ...\n\n    def __repr__(self) -> str:\n        \"\"\"Uzyskaj kompaktow\u0105 reprezentacj\u0119 obrazu w postaci \u0142a\u0144cucha.\"\"\"\n        ...\n\n    def __str__(self) -> str:\n        \"\"\"Uzyskaj czyteln\u0105 reprezentacj\u0119 obrazu w postaci \u0142a\u0144cucha.\"\"\"\n        ...\n\n    def __add__(self, other: Image) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz, dodaj\u0105c warto\u015bci jasno\u015bci z dw\u00f3ch\nobraz\u00f3w dla ka\u017cdego piksela.\n\nExample: ``Image.HEART + Image.HAPPY``\n\n:param other: Obraz do dodania.\"\"\"\n        ...\n\n    def __sub__(self, other: Image) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz, odejmuj\u0105c warto\u015bci jasno\u015bci\ninnego obrazu od tego obrazu.\n\nExample: ``Image.HEART - Image.HEART_SMALL``\n\n:param other: Obraz do odj\u0119cia.\"\"\"\n        ...\n\n    def __mul__(self, n: float) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz, mno\u017c\u0105c jasno\u015b\u0107 ka\u017cdego piksela przez\n``n``.\n\nExample: ``Image.HEART * 0.5``\n\n:param n: Warto\u015b\u0107 do mno\u017cenia przez.\"\"\"\n        ...\n\n    def __truediv__(self, n: float) -> Image:\n        \"\"\"Utw\u00f3rz nowy obraz, dziel\u0105c jasno\u015b\u0107 ka\u017cdego piksela przez\n``n``.\n\nExample: ``Image.HEART / 2``\n\n:param n: Warto\u015b\u0107 do dzielenia przez.\"\"\"\n        ...\n\nclass SoundEvent:\n    LOUD: SoundEvent\n    \"\"\"Przedstawia przej\u015bcie zdarze\u0144 d\u017awi\u0119kowych z ``quiet`` do ``loud``, jak klaskanie lub krzyczenie.\"\"\"\n    QUIET: SoundEvent\n    \"\"\"Przedstawia przej\u015bcie zdarze\u0144 d\u017awi\u0119kowych z ``loud`` do ``quiet``, jak m\u00f3wienie lub muzyka w tle.\"\"\"\n\nclass Sound:\n    \"\"\"Wbudowane d\u017awi\u0119ki mo\u017cna wywo\u0142a\u0107 za pomoc\u0105 ``audio.play(Sound.NAME)``.\"\"\"\n    GIGGLE: Sound\n    \"\"\"Chichocz\u0105cy d\u017awi\u0119k.\"\"\"\n    HAPPY: Sound\n    \"\"\"Szcz\u0119\u015bliwy d\u017awi\u0119k.\"\"\"\n    HELLO: Sound\n    \"\"\"D\u017awi\u0119k powitania.\"\"\"\n    MYSTERIOUS: Sound\n    \"\"\"Tajemniczy d\u017awi\u0119k.\"\"\"\n    SAD: Sound\n    \"\"\"Smutny d\u017awi\u0119k.\"\"\"\n    SLIDE: Sound\n    \"\"\"Przesuwaj\u0105cy si\u0119 d\u017awi\u0119k.\"\"\"\n    SOARING: Sound\n    \"\"\"Wznosz\u0105cy si\u0119 d\u017awi\u0119k.\"\"\"\n    SPRING: Sound\n    \"\"\"Wiosny d\u017awi\u0119k.\"\"\"\n    TWINKLE: Sound\n    \"\"\"Migocz\u0105cy d\u017awi\u0119k.\"\"\"\n    YAWN: Sound\n    \"\"\"D\u017awi\u0119k ziewania.\"\"\"",
    "/typeshed/stdlib/microbit/accelerometer.pyi": "\"\"\"Zmierz przyspieszenie micro:bita i rozpoznawaj gesty.\"\"\"\nfrom typing import Tuple\n\ndef get_x() -> int:\n    \"\"\"Uzyskaj pomiar przyspieszenia na osi ``x`` w mili-g.\n\nExample: ``accelerometer.get_x()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Uzyskaj pomiar przyspieszenia na osi ``y`` w mili-g.\n\nExample: ``accelerometer.get_y()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Uzyskaj pomiar przyspieszenia na osi ``z`` w mili-g.\n\nExample: ``accelerometer.get_z()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.\"\"\"\n    ...\n\ndef get_values() -> Tuple[int, int, int]:\n    \"\"\"Uzyskaj pomiary przyspieszenia na wszystkich osiach jednocze\u015bnie, jako krotk\u0119.\n\nExample: ``x, y, z = accelerometer.get_values()``\n\n:return: a three-element tuple of integers ordered as X, Y, Z, each value a positive or negative integer depending on direction in the range +/- 2000mg\"\"\"\n    ...\n\ndef get_strength() -> int:\n    \"\"\"Uzyskaj pomiar przyspieszenia wszystkich osi \u0142\u0105cznie jako dodatni\u0105 liczb\u0119 ca\u0142kowit\u0105. Jest to suma pitagorejska osi X, Y i Z.\n\nExample: ``accelerometer.get_strength()``\n\n:return: The combined acceleration strength of all the axes, in milli-g.\"\"\"\n    ...\n\ndef current_gesture() -> str:\n    \"\"\"Pobierz nazw\u0119 aktualnego gestu.\n\nExample: ``accelerometer.current_gesture()``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:return: The current gesture\"\"\"\n    ...\n\ndef is_gesture(name: str) -> bool:\n    \"\"\"Sprawd\u017a, czy nazwany gest jest aktualnie aktywny.\n\nExample: ``accelerometer.is_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: Nazwa gestu.\n:return: ``True`` if the gesture is active, ``False`` otherwise.\"\"\"\n    ...\n\ndef was_gesture(name: str) -> bool:\n    \"\"\"Sprawd\u017a, czy nazwany gest by\u0142 aktywny od ostatniego po\u0142\u0105czenia.\n\nExample: ``accelerometer.was_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: Nazwa gestu.\n:return: ``True`` if the gesture was active since the last call, ``False`` otherwise.\"\"\"\n\ndef get_gestures() -> Tuple[str, ...]:\n    \"\"\"Zwr\u00f3\u0107 krotk\u0119 historii gest\u00f3w.\n\nExample: ``accelerometer.get_gestures()``\n\nClears the gesture history before returning.\n\nGestures are not updated in the background so there needs to be constant\ncalls to some accelerometer method to do the gesture detection. Usually\ngestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n\n:return: The history as a tuple, most recent last.\"\"\"\n    ...\n\ndef set_range(value: int) -> None:\n    \"\"\"Ustaw zakres czu\u0142o\u015bci akcelerometru w g (standardowa grawitacja) na najbli\u017csze warto\u015bci obs\u0142ugiwane przez sprz\u0119t tak, aby zaokr\u0105gla\u0142 si\u0119 do ``2``, ``4`` lub ``8`` g.\n\nExample: ``accelerometer.set_range(8)``\n\n:param value: Nowy zakres dla akcelerometru, liczba ca\u0142kowita w ``g``.\"\"\"",
    "/typeshed/stdlib/microbit/audio.pyi": "\"\"\"Odtwarzaj d\u017awi\u0119ki za pomoc\u0105 micro:bita (importuj ``audio`` dla kompatybilno\u015bci V1).\"\"\"\nfrom ..microbit import MicroBitDigitalPin, Sound, pin0\nfrom typing import ClassVar, Iterable, Union\n\ndef play(source: Union[Iterable[AudioFrame], Sound, SoundEffect], wait: bool=True, pin: MicroBitDigitalPin=pin0, return_pin: Union[MicroBitDigitalPin, None]=None) -> None:\n    \"\"\"Odtw\u00f3rz wbudowany d\u017awi\u0119k, efekt d\u017awi\u0119kowy lub niestandardowe ramki audio.\n\nExample: ``audio.play(Sound.GIGGLE)``\n\n:param source: Wbudowany ``Sound``, taki jak ``Sound.GIGGLE``, ``SoundEffect`` lub przyk\u0142adowe dane jako iteracja obiekt\u00f3w ``AudioFrame``.\n:param wait: Je\u015bli ``wait`` jest ``True``, ta funkcja b\u0119dzie blokowa\u0107, a\u017c d\u017awi\u0119k zostanie zako\u0144czony.\n:param pin: Opcjonalny argument do okre\u015blenia pinu wyj\u015bciowego mo\u017ce by\u0107 u\u017cyty do nadpisania domy\u015blnej warto\u015bci ``pin0``. Je\u015bli nie chcemy, aby \u017caden d\u017awi\u0119k nie by\u0142 odtwarzany, mo\u017cemy u\u017cy\u0107 ``pin=None``.\n:param return_pin: Okre\u015bla pin \u0142\u0105cznika r\u00f3\u017cnicowego, aby pod\u0142\u0105czy\u0107 p\u0142ytk\u0119 do zewn\u0119trznego g\u0142o\u015bnika zamiast do ziemi. Jest to ignorowane dla **V2**.\"\"\"\n\ndef is_playing() -> bool:\n    \"\"\"Sprawd\u017a, czy d\u017awi\u0119k jest odtwarzany.\n\nExample: ``audio.is_playing()``\n\n:return: ``True`` if audio is playing, otherwise ``False``.\"\"\"\n    ...\n\ndef stop() -> None:\n    \"\"\"Zatrzymaj odtwarzania audio.\n\nExample: ``audio.stop()``\"\"\"\n    ...\n\nclass SoundEffect:\n    \"\"\"Efekt d\u017awi\u0119kowy, utworzony przez zestaw parametr\u00f3w skonfigurowanych za pomoc\u0105 konstruktora lub atrybut\u00f3w.\"\"\"\n    WAVEFORM_SINE: ClassVar[int]\n    \"\"\"Opcja sinusoidalnej fali u\u017cywana dla parametru ``waveform``.\"\"\"\n    WAVEFORM_SAWTOOTH: ClassVar[int]\n    \"\"\"Opcja fali pi\u0142okszta\u0142tnej u\u017cywana dla parametru ``waveform``.\"\"\"\n    WAVEFORM_TRIANGLE: ClassVar[int]\n    \"\"\"Opcja fali tr\u00f3jk\u0105tnej u\u017cywana dla parametru ``waveform``.\"\"\"\n    WAVEFORM_SQUARE: ClassVar[int]\n    \"\"\"Opcja fali kwadratowj u\u017cywana dla parametru ``waveform``.\"\"\"\n    WAVEFORM_NOISE: ClassVar[int]\n    \"\"\"Opcja szumu u\u017cywana dla parametru ``waveform``.\"\"\"\n    SHAPE_LINEAR: ClassVar[int]\n    \"\"\"Opcja interpolacji liniowej u\u017cywana dla parametru ``shape``.\"\"\"\n    SHAPE_CURVE: ClassVar[int]\n    \"\"\"Opcja interpolacji krzywej u\u017cywana dla parametru ``shape``.\"\"\"\n    SHAPE_LOG: ClassVar[int]\n    \"\"\"Opcja interpolacji logarytmicznej u\u017cywana dla parametru ``shape``.\"\"\"\n    FX_NONE: ClassVar[int]\n    \"\"\"Opcja braku efektu u\u017cyta dla parametru ``fx``.\"\"\"\n    FX_TREMOLO: ClassVar[int]\n    \"\"\"Opcja efektu Tremelo u\u017cyta dla parametru ``fx``.\"\"\"\n    FX_VIBRATO: ClassVar[int]\n    \"\"\"Opcja efektu Vibrato u\u017cyta dla parametru ``fx``.\"\"\"\n    FX_WARBLE: ClassVar[int]\n    \"\"\"Opcja efektu Warble u\u017cyta dla parametru ``fx``.\"\"\"\n    freq_start: int\n    \"\"\"Cz\u0119stotliwo\u015b\u0107 pocz\u0105tkowa w hercach (Hz), liczba mi\u0119dzy ``0`` i ``9999``\"\"\"\n    freq_end: int\n    \"\"\"Cz\u0119stotliwo\u015b\u0107 ko\u0144cowa w hercach (Hz), liczba mi\u0119dzy ``0`` i ``9999``\"\"\"\n    duration: int\n    \"\"\"Czas trwania d\u017awi\u0119ku w milisekundach, liczba pomi\u0119dzy ``0`` i ``9999``\"\"\"\n    vol_start: int\n    \"\"\"Warto\u015b\u0107 g\u0142o\u015bno\u015bci pocz\u0105tkowej, liczba mi\u0119dzy ``0`` i ``255``\"\"\"\n    vol_end: int\n    \"\"\"Warto\u015b\u0107 g\u0142o\u015bno\u015bci ko\u0144cowej, liczba mi\u0119dzy ``0`` i ``255``\"\"\"\n    waveform: int\n    \"\"\"Rodzaj kszta\u0142tu fali, jedna z tych warto\u015bci:``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (losowo generowany szum)\"\"\"\n    fx: int\n    \"\"\"Efekt do dodania do d\u017awi\u0119ku, jedna z nast\u0119puj\u0105cych warto\u015bci: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE`` lub ``FX_NONE``\"\"\"\n    shape: int\n    \"\"\"Rodzaj krzywej interpolacji mi\u0119dzy cz\u0119stotliwo\u015bci\u0105 pocz\u0105tkow\u0105 i ko\u0144cow\u0105, r\u00f3\u017cne kszta\u0142ty fal maj\u0105 r\u00f3\u017cne szybko\u015bci zmian cz\u0119stotliwo\u015bci. Jedna z nast\u0119puj\u0105cych warto\u015bci: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``\"\"\"\n\n    def __init__(self, freq_start: int=500, freq_end: int=2500, duration: int=500, vol_start: int=255, vol_end: int=0, waveform: int=WAVEFORM_SQUARE, fx: int=FX_NONE, shape: int=SHAPE_LOG):\n        \"\"\"Utw\u00f3rz nowy efekt d\u017awi\u0119kowy.\n\nExample: ``my_effect = SoundEffect(duration=1000)``\n\nAll the parameters are optional, with default values as shown above, and\nthey can all be modified via attributes of the same name. For example, we\ncan first create an effect ``my_effect = SoundEffect(duration=1000)``,\nand then change its attributes ``my_effect.duration = 500``.\n\n:param freq_start: Cz\u0119stotliwo\u015b\u0107 pocz\u0105tkowa w hercach (Hz), liczba mi\u0119dzy ``0`` i ``9999``.\n:param freq_end: Cz\u0119stotliwo\u015b\u0107 ko\u0144cowa w hercach (Hz), liczba mi\u0119dzy ``0`` i ``9999``.\n:param duration: Czas trwania d\u017awi\u0119ku w milisekundach, liczba mi\u0119dzy ``0`` i ``9999``.\n:param vol_start: Pocz\u0105tkowa warto\u015b\u0107 g\u0142o\u015bno\u015bci, liczba pomi\u0119dzy ``0`` i ``255``.\n:param vol_end: Ko\u0144cowa warto\u015b\u0107 g\u0142o\u015bno\u015bci, liczba pomi\u0119dzy ``0`` i ``255``.\n:param waveform: Rodzaj kszta\u0142tu fali, jedna z tych warto\u015bci: ``WAVEFORM_SINE``, ``WAVEFORM_SAWTOOTH``, ``WAVEFORM_TRIANGLE``, ``WAVEFORM_SQUARE``, ``WAVEFORM_NOISE`` (losowo generowany szum).\n:param fx: Efekt do dodania do d\u017awi\u0119ku, jedna z nast\u0119puj\u0105cych warto\u015bci: ``FX_TREMOLO``, ``FX_VIBRATO``, ``FX_WARBLE`` lub ``FX_NONE``.\n:param shape: Rodzaj krzywej interpolacji mi\u0119dzy cz\u0119stotliwo\u015bci\u0105 pocz\u0105tkow\u0105 i ko\u0144cow\u0105, r\u00f3\u017cne kszta\u0142ty fal maj\u0105 r\u00f3\u017cne szybko\u015bci zmian cz\u0119stotliwo\u015bci. Jedna z nast\u0119puj\u0105cych warto\u015bci: ``SHAPE_LINEAR``, ``SHAPE_CURVE``, ``SHAPE_LOG``.\"\"\"\n\n    def copy(self) -> SoundEffect:\n        \"\"\"Utw\u00f3rz kopi\u0119 ``SoundEffect``.\n\nExample: ``sound_2 = sound_1.copy()``\n\n:return: A copy of the SoundEffect.\"\"\"\n\nclass AudioFrame:\n    \"\"\"Obiekt ``AudioFrame`` jest list\u0105 32 pr\u00f3bek, z kt\u00f3rych ka\u017cda jest niepodpisanym bajtem (liczba ca\u0142kowita mi\u0119dzy 0 a 255).\n\nIt takes just over 4 ms to play a single frame.\n\nExample::\n\n    frame = AudioFrame()\n    for i in range(len(frame)):\n        frame[i] = 252 - i * 8\"\"\"\n\n    def copyfrom(self, other: AudioFrame) -> None:\n        \"\"\"Zast\u0105p dane w tym ``AudioFrame`` danymi z innej instancji ``AudioFrame``.\n\nExample: ``my_frame.copyfrom(source_frame)``\n\n:param other: Instancja ``AudioFrame``, z kt\u00f3rej skopiowane s\u0105 dane.\"\"\"\n\n    def __len__(self) -> int:\n        ...\n\n    def __setitem__(self, key: int, value: int) -> None:\n        ...\n\n    def __getitem__(self, key: int) -> int:\n        ...",
    "/typeshed/stdlib/microbit/compass.pyi": "\"\"\"U\u017cyj wbudowanego kompasu.\"\"\"\n\ndef calibrate() -> None:\n    \"\"\"Rozpoczyna proces kalibracji.\n\nExample: ``compass.calibrate()``\n\nAn instructive message will be scrolled to the user after which they will need\nto rotate the device in order to draw a circle on the LED display.\"\"\"\n    ...\n\ndef is_calibrated() -> bool:\n    \"\"\"Sprawd\u017a, czy kompas jest skalibrowany.\n\nExample: ``compass.is_calibrated()``\n\n:return: ``True`` if the compass has been successfully calibrated, ``False`` otherwise.\"\"\"\n    ...\n\ndef clear_calibration() -> None:\n    \"\"\"Cofnij kalibracj\u0119, czyni\u0105c kompas ponownie niekalibrowanym.\n\nExample: ``compass.clear_calibration()``\"\"\"\n    ...\n\ndef get_x() -> int:\n    \"\"\"Uzyskaj nat\u0119\u017cenie pola magnetycznego na osi ``x``.\n\nExample: ``compass.get_x()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_y() -> int:\n    \"\"\"Uzyskaj nat\u0119\u017cenie pola magnetycznego na osi ``y``.\n\nExample: ``compass.get_y()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef get_z() -> int:\n    \"\"\"Uzyskaj nat\u0119\u017cenie pola magnetycznego na osi ``z``.\n\nExample: ``compass.get_z()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.\"\"\"\n    ...\n\ndef heading() -> int:\n    \"\"\"Pobierz kierunek kompasu.\n\nExample: ``compass.heading()``\n\n:return: An integer in the range from 0 to 360, representing the angle in degrees, clockwise, with north as 0.\"\"\"\n    ...\n\ndef get_field_strength() -> int:\n    \"\"\"Uzyskaj wielko\u015b\u0107 pola magnetycznego wok\u00f3\u0142 urz\u0105dzenia.\n\nExample: ``compass.get_field_strength()``\n\n:return: An integer indication of the magnitude of the magnetic field in nano tesla.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/display.pyi": "\"\"\"Poka\u017c tekst, obrazy i animacje na wy\u015bwietlaczu 5x5 LED.\"\"\"\nfrom ..microbit import Image\nfrom typing import Union, overload, Iterable\n\ndef get_pixel(x: int, y: int) -> int:\n    \"\"\"Uzyskaj jasno\u015b\u0107 LED w kolumnie ``x`` i w wierszu ``y``.\n\nExample: ``display.get_pixel(0, 0)``\n\n:param x: Wy\u015bwietlana kolumna (0..4)\n:param y: Wy\u015bwietlany wiersz (0..4)\n:return: A number between 0 (off) and 9 (bright)\"\"\"\n    ...\n\ndef set_pixel(x: int, y: int, value: int) -> None:\n    \"\"\"Ustaw jasno\u015b\u0107 LED w kolumnie ``x`` i wierszu ``y``.\n\nExample: ``display.set_pixel(0, 0, 9)``\n\n:param x: Wy\u015bwietlana kolumna (0..4)\n:param y: Wy\u015bwietlany wiersz (0..4)\n:param value: Jasno\u015b\u0107 mi\u0119dzy 0 (wy\u0142\u0105czona) i 9 (jasna)\"\"\"\n    ...\n\ndef clear() -> None:\n    \"\"\"Ustaw jasno\u015b\u0107 wszystkich diod LED na 0 (wy\u0142\u0105czone).\n\nExample: ``display.clear()``\"\"\"\n    ...\n\ndef show(image: Union[str, float, int, Image, Iterable[Image]], delay: int=400, wait: bool=True, loop: bool=False, clear: bool=False) -> None:\n    \"\"\"Pokazuje obrazy, litery lub cyfry na wy\u015bwietlaczu LED.\n\nExample: ``display.show(Image.HEART)``\n\nWhen ``image`` is an image or a list of images then each image is displayed in turn.\nIf ``image`` is a string or number, each letter or digit is displayed in turn.\n\n:param image: \u0141a\u0144cuch, liczba, obraz lub lista obraz\u00f3w do pokazania.\n:param delay: Ka\u017cda litera, cyfra lub obraz s\u0105 wy\u015bwietlane z ``delay`` milisekundami mi\u0119dzy sob\u0105.\n:param wait: Je\u015bli ``wait`` jest ``True``, ta funkcja b\u0119dzie blokowa\u0107, a\u017c zako\u0144czy si\u0119 animacja, w przeciwnym razie animacja pojawi si\u0119 w tle.\n:param loop: Je\u015bli ``loop`` jest ``True``, animacja b\u0119dzie powtarzana w niesko\u0144czono\u015b\u0107.\n:param clear: Je\u015bli ``clear`` jest ``True``, wy\u015bwietlacz zostanie wyczyszczony po zako\u0144czeniu sekwencji.\n\nThe ``wait``, ``loop`` and ``clear`` arguments must be specified using their keyword.\"\"\"\n    ...\n\ndef scroll(text: Union[str, float, int], delay: int=150, wait: bool=True, loop: bool=False, monospace: bool=False) -> None:\n    \"\"\"Przewija liczb\u0119 lub tekst na wy\u015bwietlaczu LED.\n\nExample: ``display.scroll('micro:bit')``\n\n:param text: \u0141a\u0144cuch do przewini\u0119cia. Je\u015bli ``text`` jest liczb\u0105 ca\u0142kowit\u0105 lub zmiennopozycyjn\u0105, najpierw zostanie przekonwertowany na \u0142a\u0144cuch za pomoc\u0105 ``str()``.\n:param delay: Parametr ``delay`` kontroluje szybko\u015b\u0107 przewijania tekstu.\n:param wait: Je\u015bli ``wait`` jest ``True``, ta funkcja b\u0119dzie blokowa\u0107, a\u017c zako\u0144czy si\u0119 animacja, w przeciwnym razie animacja pojawi si\u0119 w tle.\n:param loop: Je\u015bli ``loop`` jest ``True``, animacja b\u0119dzie powtarzana w niesko\u0144czono\u015b\u0107.\n:param monospace: Je\u015bli ``monospace`` jest ``True``, wszystkie znaki zajm\u0105 co najwy\u017cej 5 kolumn pikseli na szeroko\u015b\u0107, w przeciwnym razie b\u0119dzie dok\u0142adnie 1 pusta kolumna pikseli pomi\u0119dzy ka\u017cdym znakiem, gdy si\u0119 przewijaj\u0105.\n\nThe ``wait``, ``loop`` and ``monospace`` arguments must be specified\nusing their keyword.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"W\u0142\u0105cz wy\u015bwietlacz LED.\n\nExample: ``display.on()``\"\"\"\n    ...\n\ndef off() -> None:\n    \"\"\"Wy\u0142\u0105cz wy\u015bwietlacz LED (wy\u0142\u0105czenie wy\u015bwietlania pozwala na ponowne u\u017cycie pin\u00f3w GPIO do innych cel\u00f3w).\n\nExample: ``display.off()``\"\"\"\n    ...\n\ndef is_on() -> bool:\n    \"\"\"Sprawd\u017a, czy wy\u015bwietlacz LED jest w\u0142\u0105czony.\n\nExample: ``display.is_on()``\n\n:return: ``True`` if the display is on, otherwise returns ``False``.\"\"\"\n    ...\n\ndef read_light_level() -> int:\n    \"\"\"Odczytuj poziom \u015bwiat\u0142a.\n\nExample: ``display.read_light_level()``\n\nUses the display's LEDs in reverse-bias mode to sense the amount of light\nfalling on the display.\n\n:return: An integer between 0 and 255 representing the light level, with larger meaning more light.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/i2c.pyi": "\"\"\"Komunikuj si\u0119 z urz\u0105dzeniami za pomoc\u0105 protoko\u0142u magistrali I2C.\"\"\"\nfrom _typeshed import ReadableBuffer\nfrom ..microbit import MicroBitDigitalPin, pin19, pin20\nfrom typing import List\n\ndef init(freq: int=100000, sda: MicroBitDigitalPin=pin20, scl: MicroBitDigitalPin=pin19) -> None:\n    \"\"\"Ponownie zainicjuj peryferia.\n\nExample: ``i2c.init()``\n\n:param freq: clock frequency\n:param sda: ``sda`` pin (domy\u015blnie 20)\n:param scl: ``scl`` pin (domy\u015blnie 19)\n\nOn a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\nthe accelerometer and compass stop working, as they are connected\ninternally to those pins. This warning does not apply to the **V2**\nrevision of the micro:bit as this has `separate I\u00b2C lines <https://tech.microbit.org/hardware/i2c/>`_\nfor the motion sensors and the edge connector.\"\"\"\n    ...\n\ndef scan() -> List[int]:\n    \"\"\"Przeskanuj magistral\u0119 w poszukiwaniu urz\u0105dze\u0144.\n\nExample: ``i2c.scan()``\n\n:return: A list of 7-bit addresses corresponding to those devices that responded to the scan.\"\"\"\n    ...\n\ndef read(addr: int, n: int, repeat: bool=False) -> bytes:\n    \"\"\"Odczytaj bajty z urz\u0105dzenia..\n\nExample: ``i2c.read(0x50, 64)``\n\n:param addr: 7-bitowy adres urz\u0105dzenia\n:param n: Liczba bajt\u00f3w do odczytu\n:param repeat: Je\u015bli ``True``, nie zostan\u0105 wys\u0142ane \u017cadne bity zatrzymania\n:return: The bytes read\"\"\"\n    ...\n\ndef write(addr: int, buf: ReadableBuffer, repeat: bool=False) -> None:\n    \"\"\"Zapisz bajty na urz\u0105dzenie.\n\nExample: ``i2c.write(0x50, bytes([1, 2, 3]))``\n\n:param addr: 7-bitowy adres urz\u0105dzenia\n:param buf: Bufor zawieraj\u0105cy bajty do zapisu\n:param repeat: Je\u015bli ``True``, nie zostan\u0105 wys\u0142ane \u017cadne bity zatrzymania\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/microphone.pyi": "\"\"\"Odpowiedz na d\u017awi\u0119k przy u\u017cyciu wbudowanego mikrofonu (tylko V2).\"\"\"\nfrom typing import Optional, Tuple\nfrom ..microbit import SoundEvent\n\ndef current_event() -> Optional[SoundEvent]:\n    \"\"\"Pobierz ostatnie nagrane zdarzenie d\u017awi\u0119kowe\n\nExample: ``microphone.current_event()``\n\n:return: The event, ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.\"\"\"\n    ...\n\ndef was_event(event: SoundEvent) -> bool:\n    \"\"\"Sprawd\u017a, czy d\u017awi\u0119k by\u0142 s\u0142yszany co najmniej raz od ostatniego po\u0142\u0105czenia.\n\nExample: ``microphone.was_event(SoundEvent.LOUD)``\n\nThis call clears the sound history before returning.\n\n:param event: Zdarzenie do sprawdzenia, takie jak ``SoundEvent.LOUD`` lub ``SoundEvent.QUIET``\n:return: ``True`` if sound was heard at least once since the last call, otherwise ``False``.\"\"\"\n    ...\n\ndef is_event(event: SoundEvent) -> bool:\n    \"\"\"Sprawd\u017a najnowsze wykryte zdarzenie d\u017awi\u0119kowe.\n\nExample: ``microphone.is_event(SoundEvent.LOUD)``\n\nThis call does not clear the sound event history.\n\n:param event: Zdarzenie do sprawdzenia, takie jak ``SoundEvent.LOUD`` lub ``SoundEvent.QUIET``\n:return: ``True`` if sound was the most recent heard, ``False`` otherwise.\"\"\"\n    ...\n\ndef get_events() -> Tuple[SoundEvent, ...]:\n    \"\"\"Pobierz histori\u0119 zdarze\u0144 d\u017awi\u0119kowych jako krotk\u0119.\n\nExample: ``microphone.get_events()``\n\nThis call clears the sound history before returning.\n\n:return: A tuple of the event history with the most recent event last.\"\"\"\n    ...\n\ndef set_threshold(event: SoundEvent, value: int) -> None:\n    \"\"\"Ustaw pr\u00f3g dla zdarzenia d\u017awi\u0119kowego.\n\nExample: ``microphone.set_threshold(SoundEvent.LOUD, 250)``\n\nA high threshold means the event will only trigger if the sound is very loud (>= 250 in the example).\n\n:param event: Zdarzenie d\u017awi\u0119kowe, takie jak ``SoundEvent.LOUD`` lub ``SoundEvent.QUIET``.\n:param value: Poziom progu w zakresie 0-255.\"\"\"\n    ...\n\ndef sound_level() -> int:\n    \"\"\"Uzyskaj poziom ci\u015bnienia akustycznego.\n\nExample: ``microphone.sound_level()``\n\n:return: A representation of the sound pressure level in the range 0 to 255.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/speaker.pyi": "\"\"\"Sprawd\u017a wbudowany g\u0142o\u015bnik (tylko V2).\"\"\"\n\ndef off() -> None:\n    \"\"\"Wy\u0142\u0105cz g\u0142o\u015bnik.\n\nExample: ``speaker.off()``\n\nThis does not disable sound output to an edge connector pin.\"\"\"\n    ...\n\ndef on() -> None:\n    \"\"\"W\u0142\u0105cz g\u0142o\u015bnik.\n\nExample: ``speaker.on()``\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/spi.pyi": "\"\"\"Komunikuj si\u0119 z urz\u0105dzeniami za pomoc\u0105 magistrali szeregowego interfejsu (SPI).\"\"\"\nfrom _typeshed import ReadableBuffer, WriteableBuffer\nfrom ..microbit import pin13, pin14, pin15, MicroBitDigitalPin\n\ndef init(baudrate: int=1000000, bits: int=8, mode: int=0, sclk: MicroBitDigitalPin=pin13, mosi: MicroBitDigitalPin=pin15, miso: MicroBitDigitalPin=pin14) -> None:\n    \"\"\"Zainicjuj komunikacj\u0119 SPI.\n\nExample: ``spi.init()``\n\nFor correct communication, the parameters have to be the same on both communicating devices.\n\n:param baudrate: Szybko\u015b\u0107 komunikacji.\n:param bits: Szeroko\u015b\u0107 w bitach ka\u017cdego transferu. Obecnie obs\u0142ugiwanych jest tylko ``bits=8``. Mo\u017ce to jednak ulec zmianie w przysz\u0142o\u015bci.\n:param mode: Okre\u015bla po\u0142\u0105czenie polarno\u015bci zegara i fazy - `zobacz tabel\u0119 online <https://microbit-micropython.readthedocs.io/en/v2-docs/spi.html#microbit.spi.init>`_.\n:param sclk: pin sclk (domy\u015blnie 13)\n:param mosi: pin mosi (domy\u015blnie 15)\n:param miso: pin miso (domy\u015blnie 14)\"\"\"\n    ...\n\ndef read(nbytes: int, out: int=0) -> bytes:\n    \"\"\"Przeczytaj co najwy\u017cej ``nbytes`` podczas ci\u0105g\u0142ego pisania pojedynczego bajtu danego przez ``out``.\n\nExample: ``spi.read(64)``\n\n:param nbytes: Maksymalna liczba bajt\u00f3w do odczytu.\n:param out: Warto\u015b\u0107 bajtu do zapisu (domy\u015blnie 0).\n:return: The bytes read.\"\"\"\n    ...\n\ndef write(buffer: ReadableBuffer) -> None:\n    \"\"\"Zapisz bajty na magistrali.\n\nExample: ``spi.write(bytes([1, 2, 3]))``\n\n:param buffer: Bufor do odczytu danych.\"\"\"\n    ...\n\ndef write_readinto(out: WriteableBuffer, in_: ReadableBuffer) -> None:\n    \"\"\"Zapisz bufor ``out`` do magistrali i wczytaj dowoln\u0105 odpowied\u017a do bufora ``in_``.\n\nExample: ``spi.write_readinto(out_buffer, in_buffer)``\n\nThe length of the buffers should be the same. The buffers can be the same object.\n\n:param out: Bufor do zapisu dowolnej odpowiedzi.\n:param in_: Bufor do odczytu danych.\"\"\"\n    ...",
    "/typeshed/stdlib/microbit/uart.pyi": "\"\"\"Komunikuj si\u0119 z urz\u0105dzeniem za pomoc\u0105 interfejsu szeregowego.\"\"\"\nfrom _typeshed import WriteableBuffer\nfrom ..microbit import MicroBitDigitalPin\nfrom typing import Optional, Union\nODD: int\n\"\"\"Nieparzysta parzysto\u015b\u0107\"\"\"\nEVEN: int\n\"\"\"Parzysta parzysto\u015b\u0107\"\"\"\n\ndef init(baudrate: int=9600, bits: int=8, parity: Optional[int]=None, stop: int=1, tx: Optional[MicroBitDigitalPin]=None, rx: Optional[MicroBitDigitalPin]=None) -> None:\n    \"\"\"Zainicjuj komunikacj\u0119 seryjn\u0105.\n\nExample: ``uart.init(115200, tx=pin0, rx=pin1)``\n\n:param baudrate: Szybko\u015b\u0107 komunikacji.\n:param bits: Rozmiar przesy\u0142anych bajt\u00f3w. micro:bit obs\u0142uguje tylko 8.\n:param parity: Jak sprawdzana jest parzysto\u015b\u0107, ``None``, ``uart.ODD`` lub ``uart.EVEN``.\n:param stop: Liczba bit\u00f3w stopu musi wynosi\u0107 1 dla micro:bita.\n:param tx: Transmituj\u0105c pin.\n:param rx: Odbieranie pinu.\n\nInitializing the UART on external pins will cause the Python console on\nUSB to become unaccessible, as it uses the same hardware. To bring the\nconsole back you must reinitialize the UART without passing anything for\n``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\nthat calling ``uart.init(115200)`` is enough to restore the Python console.\n\nFor more details see `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/uart.html>`_.\"\"\"\n    ...\n\ndef any() -> bool:\n    \"\"\"Sprawd\u017a, czy czekaj\u0105 jakie\u015b dane.\n\nExample: ``uart.any()``\n\n:return: ``True`` if any data is waiting, else ``False``.\"\"\"\n    ...\n\ndef read(nbytes: Optional[int]=None) -> Optional[bytes]:\n    \"\"\"Czytaj bajty.\n\nExample: ``uart.read()``\n\n:param nbytes: Je\u015bli ``nbytes`` jest okre\u015blony, przeczytaj co najwy\u017cej t\u0119 liczb\u0119 bajt\u00f3w, w przeciwnym razie przeczytaj jak najwi\u0119cej bajt\u00f3w\n:return: A bytes object or ``None`` on timeout\"\"\"\n    ...\n\ndef readinto(buf: WriteableBuffer, nbytes: Optional[int]=None) -> Optional[int]:\n    \"\"\"Przeczytaj bajty do ``buf``.\n\nExample: ``uart.readinto(input_buffer)``\n\n:param buf: Bufor do zapisu.\n:param nbytes: Je\u015bli ``nbytes`` jest okre\u015blony,  przeczytaj co najwy\u017cej t\u0119 liczb\u0119 bajt\u00f3w, w przeciwnym razie przeczytaj ``len(buf)`` bajt\u00f3w.\n:return: number of bytes read and stored into ``buf`` or ``None`` on timeout.\"\"\"\n    ...\n\ndef readline() -> Optional[bytes]:\n    \"\"\"Przeczytaj wiersz ko\u0144cz\u0105cy si\u0119 znakiem nowej linii.\n\nExample: ``uart.readline()``\n\n:return: The line read or ``None`` on timeout. The newline character is included in the returned bytes.\"\"\"\n    ...\n\ndef write(buf: Union[bytes, str]) -> Optional[int]:\n    \"\"\"Zapisz bufor na magistrali.\n\nExample: ``uart.write('hello world')``\n\n:param buf: Obiekt bajt\u00f3w lub \u0142a\u0144cuch.\n:return: The number of bytes written, or ``None`` on timeout.\n\nExamples::\n\n    uart.write('hello world')\n    uart.write(b'hello world')\n    uart.write(bytes([1, 2, 3]))\"\"\"\n    ...",
    "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Optional,\n    Reversible,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    ValuesView,\n)\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n\nif sys.version_info >= (3, 7):\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n        defaults: Optional[Iterable[Any]] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nelse:\n    def namedtuple(\n        typename: str,\n        field_names: Union[str, Iterable[str]],\n        *,\n        verbose: bool = ...,\n        rename: bool = ...,\n        module: Optional[str] = ...,\n    ) -> Type[Tuple[Any, ...]]: ...\n\nclass _OrderedDictKeysView(KeysView[_KT], Reversible[_KT]):\n    def __reversed__(self) -> Iterator[_KT]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT, _VT], Reversible[Tuple[_KT, _VT]]):\n    def __reversed__(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT], Reversible[_VT]):\n    def __reversed__(self) -> Iterator[_VT]: ...\n\nclass OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n    def popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = ...) -> None: ...\n    def copy(self: _S) -> _S: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _OrderedDictKeysView[_KT]: ...\n    def items(self) -> _OrderedDictItemsView[_KT, _VT]: ...\n    def values(self) -> _OrderedDictValuesView[_VT]: ...\n",
    "/src/pyrightconfig.json": "{ \n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n  \"typeCheckingMode\": \"basic\",\n  \"typeshedPath\": \"/typeshed/\",\n  \"reportMissingModuleSource\": false,\n  \"reportWildcardImportFromLibrary\": false,\n  \"verboseOutput\": true\n }\n"
  }
}